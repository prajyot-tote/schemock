// GENERATED BY SCHEMOCK - DO NOT EDIT
import { db } from './db';
import type * as Types from './types';


// Row-Level Security Context (generic key-value)
export interface RLSContext {
  [key: string]: unknown;
}

// =============================================================================
// Browser-Compatible RLS Context Storage
// 
// Uses a simple global context that works in both browsers and Node.js.
// This is appropriate for development/mock scenarios where concurrent
// request isolation is not required.
// =============================================================================

// Global context storage - works in browsers and Node.js
let currentContext: RLSContext | null = null;

/**
 * Set RLS context for the current execution.
 * 
 * @param ctx - The RLS context to set, or null to clear
 * 
 * @example
 * ```typescript
 * // Set context for a request
 * setContext({ userId: 'user-123', role: 'admin' });
 * 
 * // Clear context
 * setContext(null);
 * ```
 */
export function setContext(ctx: RLSContext | null): void {
  currentContext = ctx;
}

/**
 * Get RLS context for the current execution.
 * 
 * @returns The current RLS context, or null if not set
 */
export function getContext(): RLSContext | null {
  return currentContext;
}

/**
 * Run a function with RLS context.
 * Context is set before the function runs and restored after.
 * 
 * @param ctx - The RLS context to use
 * @param fn - The function to run with the context
 * @returns The result of the function
 * 
 * @example
 * ```typescript
 * // Run with context
 * const result = runWithContext({ userId: '123' }, () => {
 *   return api.posts.list();
 * });
 * ```
 */
export function runWithContext<T>(ctx: RLSContext | null, fn: () => T): T {
  const previousContext = currentContext;
  currentContext = ctx;
  try {
    return fn();
  } finally {
    currentContext = previousContext;
  }
}

/**
 * Async version of runWithContext for async functions.
 * 
 * @param ctx - The RLS context to use
 * @param fn - The async function to run with the context
 * @returns Promise resolving to the result of the function
 */
export async function runWithContextAsync<T>(ctx: RLSContext | null, fn: () => Promise<T>): Promise<T> {
  const previousContext = currentContext;
  currentContext = ctx;
  try {
    return await fn();
  } finally {
    currentContext = previousContext;
  }
}

// RLS Error for unauthorized access
export class RLSError extends Error {
  readonly code = "RLS_DENIED";
  constructor(operation: string, entity: string) {
    super(`Access denied: ${operation} on ${entity}`);
    this.name = "RLSError";
  }
}

function checkBypass(_ctx: RLSContext | null): boolean {
  return false;
}

// RLS filters for User (disabled)
const rlsUserSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;

// RLS filters for Post
const rlsPostSelect = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  return row.published||row.authorId===ctx.userId;
};
const rlsPostInsert = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  // Scope: undefined must match context.undefined
  if (!ctx || row.undefined !== ctx.undefined) return false;
  return true;
};
const rlsPostUpdate = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  return row.authorId===ctx.userId;
};
const rlsPostDelete = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  return row.authorId===ctx.userId;
};

// RLS filters for Comment (disabled)
const rlsCommentSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsCommentInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsCommentUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsCommentDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;

// RLS filters for PostDetail (disabled)
const rlsPostDetailSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsPostDetailInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsPostDetailUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsPostDetailDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;

// RLS filters for UserProfile (disabled)
const rlsUserProfileSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserProfileInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserProfileUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserProfileDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;


function applyFilter<T>(items: T[], filter: Record<string, unknown>): T[] {
  return items.filter(item => {
    for (const [key, value] of Object.entries(filter)) {
      const itemValue = (item as Record<string, unknown>)[key];
      if (typeof value === "object" && value !== null) {
        const f = value as Record<string, unknown>;
        if ('equals' in f && itemValue !== f.equals) return false;
        if ('not' in f && itemValue === f.not) return false;
        if ('in' in f && !(f.in as unknown[]).includes(itemValue)) return false;
        if ('notIn' in f && (f.notIn as unknown[]).includes(itemValue)) return false;
        if ('contains' in f && !String(itemValue).includes(f.contains as string)) return false;
        if ('startsWith' in f && !String(itemValue).startsWith(f.startsWith as string)) return false;
        if ('endsWith' in f && !String(itemValue).endsWith(f.endsWith as string)) return false;
        if ('gt' in f && (itemValue as number) <= (f.gt as number)) return false;
        if ('lt' in f && (itemValue as number) >= (f.lt as number)) return false;
        if ('gte' in f && (itemValue as number) < (f.gte as number)) return false;
        if ('lte' in f && (itemValue as number) > (f.lte as number)) return false;
        if ('isNull' in f && f.isNull && itemValue !== null && itemValue !== undefined) return false;
        if ('isNull' in f && !f.isNull && (itemValue === null || itemValue === undefined)) return false;
      } else {
        if (itemValue !== value) return false;
      }
    }
    return true;
  });
}

// Parse JSONB fields stored as strings by @mswjs/data
function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {
  const result = { ...row };
  for (const field of jsonFields) {
    if (result[field] && typeof result[field] === "string") {
      try {
        result[field] = JSON.parse(result[field] as string);
      } catch { /* keep as string */ }
    }
  }
  return result as T;
}

export const api = {
  user: {
    list: async (options?: Types.QueryOptions<Types.UserFilter, never>): Promise<Types.ListResponse<Types.User>> => {
      let items = db.user.getAll() as unknown as Types.User[];

      // Apply RLS filter
      const ctx = getContext();
      items = items.filter(item => rlsUserSelect(item as unknown as Record<string, unknown>, ctx));

      if (options?.where) {
        items = applyFilter(items, options.where);
      }

      const total = items.length;

      if (options?.orderBy) {
        const [field, dir] = Object.entries(options.orderBy)[0];
        items = [...items].sort((a, b) => {
          const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
          const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
          if (aVal < bVal) return dir === 'asc' ? -1 : 1;
          if (aVal > bVal) return dir === 'asc' ? 1 : -1;
          return 0;
        });
      }

      const limit = options?.limit ?? 20;
      const offset = options?.offset ?? 0;
      items = items.slice(offset, offset + limit);

      return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
    },

    get: async (id: string, options?: { include?: never[] }): Promise<Types.ItemResponse<Types.User>> => {
      const rawItem = db.user.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!rawItem) throw new Error('User not found');
      const item = rawItem as Types.User;

      // Apply RLS check
      const ctx = getContext();
      if (!rlsUserSelect(item as unknown as Record<string, unknown>, ctx)) {
        throw new RLSError('select', 'User');
      }

      return { data: item };
    },

    create: async (input: Types.UserCreate): Promise<Types.ItemResponse<Types.User>> => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const rawItem = db.user.create(input as any) as unknown as Record<string, unknown>;
      const item = rawItem as Types.User;

      // Check RLS on created item
      const ctx = getContext();
      if (!rlsUserInsert(item as unknown as Record<string, unknown>, ctx)) {
        // Rollback by deleting
        db.user.delete({ where: { id: { equals: item.id } } });
        throw new RLSError('insert', 'User');
      }

      return { data: item };
    },

    update: async (id: string, input: Types.UserUpdate): Promise<Types.ItemResponse<Types.User>> => {
      // Check RLS before update
      const existing = db.user.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('User not found');
      const ctx = getContext();
      if (!rlsUserUpdate(existing, ctx)) {
        throw new RLSError('update', 'User');
      }

      const rawItem = db.user.update({
        where: { id: { equals: id } },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data: { ...input, updatedAt: new Date() } as any,
      }) as unknown as Record<string, unknown> | null;
      return { data: rawItem as Types.User };
    },

    delete: async (id: string): Promise<void> => {
      // Check RLS before delete
      const existing = db.user.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('User not found');
      const ctx = getContext();
      if (!rlsUserDelete(existing, ctx)) {
        throw new RLSError('delete', 'User');
      }

      const item = db.user.delete({ where: { id: { equals: id } } });
    },
  },

  post: {
    list: async (options?: Types.QueryOptions<Types.PostFilter, never>): Promise<Types.ListResponse<Types.Post>> => {
      let items = db.post.getAll() as unknown as Types.Post[];

      // Apply RLS filter
      const ctx = getContext();
      items = items.filter(item => rlsPostSelect(item as unknown as Record<string, unknown>, ctx));

      if (options?.where) {
        items = applyFilter(items, options.where);
      }

      const total = items.length;

      if (options?.orderBy) {
        const [field, dir] = Object.entries(options.orderBy)[0];
        items = [...items].sort((a, b) => {
          const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
          const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
          if (aVal < bVal) return dir === 'asc' ? -1 : 1;
          if (aVal > bVal) return dir === 'asc' ? 1 : -1;
          return 0;
        });
      }

      const limit = options?.limit ?? 20;
      const offset = options?.offset ?? 0;
      items = items.slice(offset, offset + limit);

      return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
    },

    get: async (id: string, options?: { include?: never[] }): Promise<Types.ItemResponse<Types.Post>> => {
      const rawItem = db.post.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!rawItem) throw new Error('Post not found');
      const item = rawItem as Types.Post;

      // Apply RLS check
      const ctx = getContext();
      if (!rlsPostSelect(item as unknown as Record<string, unknown>, ctx)) {
        throw new RLSError('select', 'Post');
      }

      return { data: item };
    },

    create: async (input: Types.PostCreate): Promise<Types.ItemResponse<Types.Post>> => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const rawItem = db.post.create(input as any) as unknown as Record<string, unknown>;
      const item = rawItem as Types.Post;

      // Check RLS on created item
      const ctx = getContext();
      if (!rlsPostInsert(item as unknown as Record<string, unknown>, ctx)) {
        // Rollback by deleting
        db.post.delete({ where: { id: { equals: item.id } } });
        throw new RLSError('insert', 'Post');
      }

      return { data: item };
    },

    update: async (id: string, input: Types.PostUpdate): Promise<Types.ItemResponse<Types.Post>> => {
      // Check RLS before update
      const existing = db.post.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('Post not found');
      const ctx = getContext();
      if (!rlsPostUpdate(existing, ctx)) {
        throw new RLSError('update', 'Post');
      }

      const rawItem = db.post.update({
        where: { id: { equals: id } },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data: { ...input, updatedAt: new Date() } as any,
      }) as unknown as Record<string, unknown> | null;
      return { data: rawItem as Types.Post };
    },

    delete: async (id: string): Promise<void> => {
      // Check RLS before delete
      const existing = db.post.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('Post not found');
      const ctx = getContext();
      if (!rlsPostDelete(existing, ctx)) {
        throw new RLSError('delete', 'Post');
      }

      const item = db.post.delete({ where: { id: { equals: id } } });
    },
  },

  comment: {
    list: async (options?: Types.QueryOptions<Types.CommentFilter, never>): Promise<Types.ListResponse<Types.Comment>> => {
      let items = db.comment.getAll() as unknown as Types.Comment[];

      // Apply RLS filter
      const ctx = getContext();
      items = items.filter(item => rlsCommentSelect(item as unknown as Record<string, unknown>, ctx));

      if (options?.where) {
        items = applyFilter(items, options.where);
      }

      const total = items.length;

      if (options?.orderBy) {
        const [field, dir] = Object.entries(options.orderBy)[0];
        items = [...items].sort((a, b) => {
          const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
          const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
          if (aVal < bVal) return dir === 'asc' ? -1 : 1;
          if (aVal > bVal) return dir === 'asc' ? 1 : -1;
          return 0;
        });
      }

      const limit = options?.limit ?? 20;
      const offset = options?.offset ?? 0;
      items = items.slice(offset, offset + limit);

      return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
    },

    get: async (id: string, options?: { include?: never[] }): Promise<Types.ItemResponse<Types.Comment>> => {
      const rawItem = db.comment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!rawItem) throw new Error('Comment not found');
      const item = rawItem as Types.Comment;

      // Apply RLS check
      const ctx = getContext();
      if (!rlsCommentSelect(item as unknown as Record<string, unknown>, ctx)) {
        throw new RLSError('select', 'Comment');
      }

      return { data: item };
    },

    create: async (input: Types.CommentCreate): Promise<Types.ItemResponse<Types.Comment>> => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const rawItem = db.comment.create(input as any) as unknown as Record<string, unknown>;
      const item = rawItem as Types.Comment;

      // Check RLS on created item
      const ctx = getContext();
      if (!rlsCommentInsert(item as unknown as Record<string, unknown>, ctx)) {
        // Rollback by deleting
        db.comment.delete({ where: { id: { equals: item.id } } });
        throw new RLSError('insert', 'Comment');
      }

      return { data: item };
    },

    update: async (id: string, input: Types.CommentUpdate): Promise<Types.ItemResponse<Types.Comment>> => {
      // Check RLS before update
      const existing = db.comment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('Comment not found');
      const ctx = getContext();
      if (!rlsCommentUpdate(existing, ctx)) {
        throw new RLSError('update', 'Comment');
      }

      const rawItem = db.comment.update({
        where: { id: { equals: id } },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data: { ...input, updatedAt: new Date() } as any,
      }) as unknown as Record<string, unknown> | null;
      return { data: rawItem as Types.Comment };
    },

    delete: async (id: string): Promise<void> => {
      // Check RLS before delete
      const existing = db.comment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('Comment not found');
      const ctx = getContext();
      if (!rlsCommentDelete(existing, ctx)) {
        throw new RLSError('delete', 'Comment');
      }

      const item = db.comment.delete({ where: { id: { equals: id } } });
    },
  },

  post-detail: {
    list: async (options?: Types.QueryOptions<Types.PostDetailFilter, never>): Promise<Types.ListResponse<Types.PostDetail>> => {
      let rawItems = db.post-detail.getAll() as unknown as Record<string, unknown>[];
      let items = rawItems.map(row => parseRow<Types.PostDetail>(row, ['author', 'comments']));

      // Apply RLS filter
      const ctx = getContext();
      items = items.filter(item => rlsPostDetailSelect(item as unknown as Record<string, unknown>, ctx));

      if (options?.where) {
        items = applyFilter(items, options.where);
      }

      const total = items.length;

      if (options?.orderBy) {
        const [field, dir] = Object.entries(options.orderBy)[0];
        items = [...items].sort((a, b) => {
          const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
          const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
          if (aVal < bVal) return dir === 'asc' ? -1 : 1;
          if (aVal > bVal) return dir === 'asc' ? 1 : -1;
          return 0;
        });
      }

      const limit = options?.limit ?? 20;
      const offset = options?.offset ?? 0;
      items = items.slice(offset, offset + limit);

      return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
    },

    get: async (id: string, options?: { include?: never[] }): Promise<Types.ItemResponse<Types.PostDetail>> => {
      const rawItem = db.post-detail.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!rawItem) throw new Error('PostDetail not found');
      const item = parseRow<Types.PostDetail>(rawItem, ['author', 'comments']);

      // Apply RLS check
      const ctx = getContext();
      if (!rlsPostDetailSelect(item as unknown as Record<string, unknown>, ctx)) {
        throw new RLSError('select', 'PostDetail');
      }

      return { data: item };
    },

    create: async (input: Types.PostDetailCreate): Promise<Types.ItemResponse<Types.PostDetail>> => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const rawItem = db.post-detail.create(input as any) as unknown as Record<string, unknown>;
      const item = parseRow<Types.PostDetail>(rawItem, ['author', 'comments']);

      // Check RLS on created item
      const ctx = getContext();
      if (!rlsPostDetailInsert(item as unknown as Record<string, unknown>, ctx)) {
        // Rollback by deleting
        db.post-detail.delete({ where: { id: { equals: item.id } } });
        throw new RLSError('insert', 'PostDetail');
      }

      return { data: item };
    },

    update: async (id: string, input: Types.PostDetailUpdate): Promise<Types.ItemResponse<Types.PostDetail>> => {
      // Check RLS before update
      const existing = db.post-detail.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('PostDetail not found');
      const ctx = getContext();
      if (!rlsPostDetailUpdate(existing, ctx)) {
        throw new RLSError('update', 'PostDetail');
      }

      const rawItem = db.post-detail.update({
        where: { id: { equals: id } },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data: { ...input, updatedAt: new Date() } as any,
      }) as unknown as Record<string, unknown> | null;
      return { data: parseRow<Types.PostDetail>(rawItem!, ['author', 'comments']) };
    },

    delete: async (id: string): Promise<void> => {
      // Check RLS before delete
      const existing = db.post-detail.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('PostDetail not found');
      const ctx = getContext();
      if (!rlsPostDetailDelete(existing, ctx)) {
        throw new RLSError('delete', 'PostDetail');
      }

      const item = db.post-detail.delete({ where: { id: { equals: id } } });
    },
  },

  user-profile: {
    list: async (options?: Types.QueryOptions<Types.UserProfileFilter, never>): Promise<Types.ListResponse<Types.UserProfile>> => {
      let rawItems = db.user-profile.getAll() as unknown as Record<string, unknown>[];
      let items = rawItems.map(row => parseRow<Types.UserProfile>(row, ['stats', 'recentPosts']));

      // Apply RLS filter
      const ctx = getContext();
      items = items.filter(item => rlsUserProfileSelect(item as unknown as Record<string, unknown>, ctx));

      if (options?.where) {
        items = applyFilter(items, options.where);
      }

      const total = items.length;

      if (options?.orderBy) {
        const [field, dir] = Object.entries(options.orderBy)[0];
        items = [...items].sort((a, b) => {
          const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
          const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
          if (aVal < bVal) return dir === 'asc' ? -1 : 1;
          if (aVal > bVal) return dir === 'asc' ? 1 : -1;
          return 0;
        });
      }

      const limit = options?.limit ?? 20;
      const offset = options?.offset ?? 0;
      items = items.slice(offset, offset + limit);

      return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
    },

    get: async (id: string, options?: { include?: never[] }): Promise<Types.ItemResponse<Types.UserProfile>> => {
      const rawItem = db.user-profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!rawItem) throw new Error('UserProfile not found');
      const item = parseRow<Types.UserProfile>(rawItem, ['stats', 'recentPosts']);

      // Apply RLS check
      const ctx = getContext();
      if (!rlsUserProfileSelect(item as unknown as Record<string, unknown>, ctx)) {
        throw new RLSError('select', 'UserProfile');
      }

      return { data: item };
    },

    create: async (input: Types.UserProfileCreate): Promise<Types.ItemResponse<Types.UserProfile>> => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const rawItem = db.user-profile.create(input as any) as unknown as Record<string, unknown>;
      const item = parseRow<Types.UserProfile>(rawItem, ['stats', 'recentPosts']);

      // Check RLS on created item
      const ctx = getContext();
      if (!rlsUserProfileInsert(item as unknown as Record<string, unknown>, ctx)) {
        // Rollback by deleting
        db.user-profile.delete({ where: { id: { equals: item.id } } });
        throw new RLSError('insert', 'UserProfile');
      }

      return { data: item };
    },

    update: async (id: string, input: Types.UserProfileUpdate): Promise<Types.ItemResponse<Types.UserProfile>> => {
      // Check RLS before update
      const existing = db.user-profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('UserProfile not found');
      const ctx = getContext();
      if (!rlsUserProfileUpdate(existing, ctx)) {
        throw new RLSError('update', 'UserProfile');
      }

      const rawItem = db.user-profile.update({
        where: { id: { equals: id } },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data: { ...input, updatedAt: new Date() } as any,
      }) as unknown as Record<string, unknown> | null;
      return { data: parseRow<Types.UserProfile>(rawItem!, ['stats', 'recentPosts']) };
    },

    delete: async (id: string): Promise<void> => {
      // Check RLS before delete
      const existing = db.user-profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
      if (!existing) throw new Error('UserProfile not found');
      const ctx = getContext();
      if (!rlsUserProfileDelete(existing, ctx)) {
        throw new RLSError('delete', 'UserProfile');
      }

      const item = db.user-profile.delete({ where: { id: { equals: id } } });
    },
  },

};