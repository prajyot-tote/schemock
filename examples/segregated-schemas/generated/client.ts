// GENERATED BY SCHEMOCK - DO NOT EDIT
import { db } from './db';
import type * as Types from './types';


// =============================================================================
// RLS Context & Client Configuration
// 
// Production-ready interceptor pattern for centralized auth and error handling.
// Configure once at app startup, auth headers are added to every request.
// =============================================================================

// RLS Context - internal type for mock RLS simulation (not exported)
interface RLSContext {
  [key: string]: unknown;
}

// Request context passed to onRequest interceptor
export interface RequestContext {
  headers: Record<string, string>;
  operation: string;  // e.g., "post.list", "user.create"
}

// API Error with HTTP-like status codes
export class ApiError extends Error {
  readonly status: number;
  readonly code: string;
  readonly operation: string;

  constructor(message: string, status: number, code: string, operation: string) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.code = code;
    this.operation = operation;
  }
}

/**
 * Client configuration for interceptors.
 * 
 * @example
 * ```typescript
 * const api = createClient({
 *   onRequest: (ctx) => {
 *     const token = localStorage.getItem("token");
 *     if (token) {
 *       ctx.headers.Authorization = `Bearer ${token}`;
 *     }
 *     return ctx;
 *   },
 *   onError: (error) => {
 *     if (error.status === 401) {
 *       window.location.href = "/login";
 *     }
 *   }
 * });
 * ```
 */
export interface ClientConfig {
  /**
   * Called before each API operation.
   * Use this to add auth headers, logging, etc.
   */
  onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;

  /**
   * Called when an error occurs.
   * Use this for centralized error handling (401 redirect, toast notifications, etc.)
   */
  onError?: (error: ApiError) => void | Promise<void>;
}

// Decode JWT payload without validation (mock mode trusts the token)
function decodeJwtPayload(token: string): RLSContext | null {
  try {
    const parts = token.split(".");
    if (parts.length !== 3) return null;

    const payload = parts[1].replace(/-/g, "+").replace(/_/g, "/");
    const decoded = typeof atob === "function"
      ? atob(payload)
      : Buffer.from(payload, "base64").toString("utf-8");

    return JSON.parse(decoded);
  } catch {
    return null;
  }
}

// Extract RLS context from request headers
function extractContextFromHeaders(headers: Record<string, string>): RLSContext | null {
  const authHeader = headers["Authorization"] || headers["authorization"];
  if (!authHeader) return null;

  const token = authHeader.startsWith("Bearer ")
    ? authHeader.slice(7)
    : authHeader;

  return token ? decodeJwtPayload(token) : null;
}

// Helper to create not found error
function createNotFoundError(entity: string, id: string): ApiError {
  return new ApiError(
    `${entity} not found: ${id}`,
    404,
    "NOT_FOUND",
    `${entity}.get`
  );
}

// Helper to create RLS denial error
function createRLSError(operation: string, entity: string): ApiError {
  return new ApiError(
    `Access denied: ${operation} on ${entity}`,
    403,
    "RLS_DENIED",
    `${entity}.${operation}`
  );
}

function checkBypass(_ctx: RLSContext | null): boolean {
  return false;
}

// RLS filters for User (disabled)
const rlsUserSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;

// RLS filters for Post
const rlsPostSelect = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  return row.published || row.authorId === ctx.userId;
};
const rlsPostInsert = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  // Scope: undefined must match context.undefined
  if (!ctx || row.undefined !== ctx.undefined) return false;
  return true;
};
const rlsPostUpdate = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  return row.authorId === ctx.userId;
};
const rlsPostDelete = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {
  return row.authorId === ctx.userId;
};

// RLS filters for Comment (disabled)
const rlsCommentSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsCommentInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsCommentUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsCommentDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;

// RLS filters for PostDetail (disabled)
const rlsPostDetailSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsPostDetailInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsPostDetailUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsPostDetailDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;

// RLS filters for UserProfile (disabled)
const rlsUserProfileSelect = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserProfileInsert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserProfileUpdate = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;
const rlsUserProfileDelete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;


function applyFilter<T>(items: T[], filter: Record<string, unknown>): T[] {
  return items.filter(item => {
    for (const [key, value] of Object.entries(filter)) {
      const itemValue = (item as Record<string, unknown>)[key];
      if (typeof value === "object" && value !== null) {
        const f = value as Record<string, unknown>;
        if ('equals' in f && itemValue !== f.equals) return false;
        if ('not' in f && itemValue === f.not) return false;
        if ('in' in f && !(f.in as unknown[]).includes(itemValue)) return false;
        if ('notIn' in f && (f.notIn as unknown[]).includes(itemValue)) return false;
        if ('contains' in f && !String(itemValue).includes(f.contains as string)) return false;
        if ('startsWith' in f && !String(itemValue).startsWith(f.startsWith as string)) return false;
        if ('endsWith' in f && !String(itemValue).endsWith(f.endsWith as string)) return false;
        if ('gt' in f && (itemValue as number) <= (f.gt as number)) return false;
        if ('lt' in f && (itemValue as number) >= (f.lt as number)) return false;
        if ('gte' in f && (itemValue as number) < (f.gte as number)) return false;
        if ('lte' in f && (itemValue as number) > (f.lte as number)) return false;
        if ('isNull' in f && f.isNull && itemValue !== null && itemValue !== undefined) return false;
        if ('isNull' in f && !f.isNull && (itemValue === null || itemValue === undefined)) return false;
      } else {
        if (itemValue !== value) return false;
      }
    }
    return true;
  });
}

// Parse JSONB fields stored as strings by @mswjs/data
function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {
  const result = { ...row };
  for (const field of jsonFields) {
    if (result[field] && typeof result[field] === "string") {
      try {
        result[field] = JSON.parse(result[field] as string);
      } catch { /* keep as string */ }
    }
  }
  return result as T;
}

// API client type
export interface ApiClient {
  user: {
    list: (options?: Types.QueryOptions<Types.UserFilter, never>) => Promise<Types.ListResponse<Types.User>>;
    get: (id: string, options?: { include?: never[] }) => Promise<Types.ItemResponse<Types.User>>;
    create: (input: Types.UserCreate) => Promise<Types.ItemResponse<Types.User>>;
    update: (id: string, input: Types.UserUpdate) => Promise<Types.ItemResponse<Types.User>>;
    delete: (id: string) => Promise<void>;
  };
  post: {
    list: (options?: Types.QueryOptions<Types.PostFilter, never>) => Promise<Types.ListResponse<Types.Post>>;
    get: (id: string, options?: { include?: never[] }) => Promise<Types.ItemResponse<Types.Post>>;
    create: (input: Types.PostCreate) => Promise<Types.ItemResponse<Types.Post>>;
    update: (id: string, input: Types.PostUpdate) => Promise<Types.ItemResponse<Types.Post>>;
    delete: (id: string) => Promise<void>;
  };
  comment: {
    list: (options?: Types.QueryOptions<Types.CommentFilter, never>) => Promise<Types.ListResponse<Types.Comment>>;
    get: (id: string, options?: { include?: never[] }) => Promise<Types.ItemResponse<Types.Comment>>;
    create: (input: Types.CommentCreate) => Promise<Types.ItemResponse<Types.Comment>>;
    update: (id: string, input: Types.CommentUpdate) => Promise<Types.ItemResponse<Types.Comment>>;
    delete: (id: string) => Promise<void>;
  };
  post-detail: {
    list: (options?: Types.QueryOptions<Types.PostDetailFilter, never>) => Promise<Types.ListResponse<Types.PostDetail>>;
    get: (id: string, options?: { include?: never[] }) => Promise<Types.ItemResponse<Types.PostDetail>>;
    create: (input: Types.PostDetailCreate) => Promise<Types.ItemResponse<Types.PostDetail>>;
    update: (id: string, input: Types.PostDetailUpdate) => Promise<Types.ItemResponse<Types.PostDetail>>;
    delete: (id: string) => Promise<void>;
  };
  user-profile: {
    list: (options?: Types.QueryOptions<Types.UserProfileFilter, never>) => Promise<Types.ListResponse<Types.UserProfile>>;
    get: (id: string, options?: { include?: never[] }) => Promise<Types.ItemResponse<Types.UserProfile>>;
    create: (input: Types.UserProfileCreate) => Promise<Types.ItemResponse<Types.UserProfile>>;
    update: (id: string, input: Types.UserProfileUpdate) => Promise<Types.ItemResponse<Types.UserProfile>>;
    delete: (id: string) => Promise<void>;
  };
}

/**
 * Create a configured API client with interceptors.
 * 
 * Use this for production code to centralize auth and error handling.
 * 
 * @param config - Client configuration with interceptors
 * @returns Configured API client
 * 
 * @example
 * ```typescript
 * import { createClient } from './generated/client';
 * import { createMockJwt } from 'schemock/middleware';
 * 
 * const api = createClient({
 *   // Add auth headers to every request
 *   onRequest: (ctx) => {
 *     const token = localStorage.getItem("authToken");
 *     if (token) {
 *       ctx.headers.Authorization = `Bearer ${token}`;
 *     }
 *     return ctx;
 *   },
 * 
 *   // Centralized error handling
 *   onError: (error) => {
 *     if (error.status === 401) {
 *       // Token expired - redirect to login
 *       window.location.href = "/login";
 *     }
 *     if (error.status === 403) {
 *       // Access denied - show notification
 *       toast.error("Access denied");
 *     }
 *   }
 * });
 * 
 * // Now use the API - auth is automatic
 * const posts = await api.post.list();
 * ```
 */
export function createClient(config?: ClientConfig): ApiClient {
  const interceptors = config ?? {};

  // Internal helper to run request through interceptors
  async function executeRequest<T>(
    operation: string,
    fn: (ctx: RLSContext | null) => T | Promise<T>
  ): Promise<T> {
    // Build request context
    let requestCtx: RequestContext = { headers: {}, operation };

    // Run onRequest interceptor (user adds auth headers here)
    if (interceptors.onRequest) {
      requestCtx = await interceptors.onRequest(requestCtx);
    }

    // Extract RLS context from headers
    const rlsCtx = extractContextFromHeaders(requestCtx.headers);

    try {
      return await fn(rlsCtx);
    } catch (err) {
      // Enhance error if not already ApiError
      const error = err instanceof ApiError ? err : new ApiError(
        err instanceof Error ? err.message : String(err),
        500,
        "INTERNAL_ERROR",
        operation
      );

      // Run onError interceptor
      if (interceptors.onError) {
        await interceptors.onError(error);
      }

      throw error;
    }
  }

  // Build API client with all entity methods
  return {
    user: {
      list: (options?: Types.QueryOptions<Types.UserFilter, never>) =>
        executeRequest('user.list', (ctx) => {
          let items = db.user.getAll() as unknown as Types.User[];

          // Apply RLS filter
          items = items.filter(item => rlsUserSelect(item as unknown as Record<string, unknown>, ctx));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: never[] }) =>
        executeRequest('user.get', (ctx) => {
          const rawItem = db.user.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('User', id);
          const item = rawItem as Types.User;

          // Apply RLS check
          if (!rlsUserSelect(item as unknown as Record<string, unknown>, ctx)) {
            throw createRLSError('select', 'User');
          }

          return { data: item };
        }),

      create: (input: Types.UserCreate) =>
        executeRequest('user.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.user.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.User;

          // Check RLS on created item
          if (!rlsUserInsert(item as unknown as Record<string, unknown>, ctx)) {
            // Rollback by deleting
            db.user.delete({ where: { id: { equals: item.id } } });
            throw createRLSError('insert', 'User');
          }

          return { data: item };
        }),

      update: (id: string, input: Types.UserUpdate) =>
        executeRequest('user.update', (ctx) => {
          // Check RLS before update
          const existing = db.user.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('User', id);
          if (!rlsUserUpdate(existing, ctx)) {
            throw createRLSError('update', 'User');
          }

          const rawItem = db.user.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          return { data: rawItem as Types.User };
        }),

      delete: (id: string) =>
        executeRequest('user.delete', (ctx) => {
          // Check RLS before delete
          const existing = db.user.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('User', id);
          if (!rlsUserDelete(existing, ctx)) {
            throw createRLSError('delete', 'User');
          }

          const item = db.user.delete({ where: { id: { equals: id } } });
        }),
    },

    post: {
      list: (options?: Types.QueryOptions<Types.PostFilter, never>) =>
        executeRequest('post.list', (ctx) => {
          let items = db.post.getAll() as unknown as Types.Post[];

          // Apply RLS filter
          items = items.filter(item => rlsPostSelect(item as unknown as Record<string, unknown>, ctx));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: never[] }) =>
        executeRequest('post.get', (ctx) => {
          const rawItem = db.post.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Post', id);
          const item = rawItem as Types.Post;

          // Apply RLS check
          if (!rlsPostSelect(item as unknown as Record<string, unknown>, ctx)) {
            throw createRLSError('select', 'Post');
          }

          return { data: item };
        }),

      create: (input: Types.PostCreate) =>
        executeRequest('post.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.post.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Post;

          // Check RLS on created item
          if (!rlsPostInsert(item as unknown as Record<string, unknown>, ctx)) {
            // Rollback by deleting
            db.post.delete({ where: { id: { equals: item.id } } });
            throw createRLSError('insert', 'Post');
          }

          return { data: item };
        }),

      update: (id: string, input: Types.PostUpdate) =>
        executeRequest('post.update', (ctx) => {
          // Check RLS before update
          const existing = db.post.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('Post', id);
          if (!rlsPostUpdate(existing, ctx)) {
            throw createRLSError('update', 'Post');
          }

          const rawItem = db.post.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          return { data: rawItem as Types.Post };
        }),

      delete: (id: string) =>
        executeRequest('post.delete', (ctx) => {
          // Check RLS before delete
          const existing = db.post.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('Post', id);
          if (!rlsPostDelete(existing, ctx)) {
            throw createRLSError('delete', 'Post');
          }

          const item = db.post.delete({ where: { id: { equals: id } } });
        }),
    },

    comment: {
      list: (options?: Types.QueryOptions<Types.CommentFilter, never>) =>
        executeRequest('comment.list', (ctx) => {
          let items = db.comment.getAll() as unknown as Types.Comment[];

          // Apply RLS filter
          items = items.filter(item => rlsCommentSelect(item as unknown as Record<string, unknown>, ctx));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: never[] }) =>
        executeRequest('comment.get', (ctx) => {
          const rawItem = db.comment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Comment', id);
          const item = rawItem as Types.Comment;

          // Apply RLS check
          if (!rlsCommentSelect(item as unknown as Record<string, unknown>, ctx)) {
            throw createRLSError('select', 'Comment');
          }

          return { data: item };
        }),

      create: (input: Types.CommentCreate) =>
        executeRequest('comment.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.comment.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Comment;

          // Check RLS on created item
          if (!rlsCommentInsert(item as unknown as Record<string, unknown>, ctx)) {
            // Rollback by deleting
            db.comment.delete({ where: { id: { equals: item.id } } });
            throw createRLSError('insert', 'Comment');
          }

          return { data: item };
        }),

      update: (id: string, input: Types.CommentUpdate) =>
        executeRequest('comment.update', (ctx) => {
          // Check RLS before update
          const existing = db.comment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('Comment', id);
          if (!rlsCommentUpdate(existing, ctx)) {
            throw createRLSError('update', 'Comment');
          }

          const rawItem = db.comment.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          return { data: rawItem as Types.Comment };
        }),

      delete: (id: string) =>
        executeRequest('comment.delete', (ctx) => {
          // Check RLS before delete
          const existing = db.comment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('Comment', id);
          if (!rlsCommentDelete(existing, ctx)) {
            throw createRLSError('delete', 'Comment');
          }

          const item = db.comment.delete({ where: { id: { equals: id } } });
        }),
    },

    post-detail: {
      list: (options?: Types.QueryOptions<Types.PostDetailFilter, never>) =>
        executeRequest('post-detail.list', (ctx) => {
          let rawItems = db.post-detail.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.PostDetail>(row, ['author', 'comments']));

          // Apply RLS filter
          items = items.filter(item => rlsPostDetailSelect(item as unknown as Record<string, unknown>, ctx));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: never[] }) =>
        executeRequest('post-detail.get', (ctx) => {
          const rawItem = db.post-detail.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('PostDetail', id);
          const item = parseRow<Types.PostDetail>(rawItem, ['author', 'comments']);

          // Apply RLS check
          if (!rlsPostDetailSelect(item as unknown as Record<string, unknown>, ctx)) {
            throw createRLSError('select', 'PostDetail');
          }

          return { data: item };
        }),

      create: (input: Types.PostDetailCreate) =>
        executeRequest('post-detail.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.post-detail.create(input as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.PostDetail>(rawItem, ['author', 'comments']);

          // Check RLS on created item
          if (!rlsPostDetailInsert(item as unknown as Record<string, unknown>, ctx)) {
            // Rollback by deleting
            db.post-detail.delete({ where: { id: { equals: item.id } } });
            throw createRLSError('insert', 'PostDetail');
          }

          return { data: item };
        }),

      update: (id: string, input: Types.PostDetailUpdate) =>
        executeRequest('post-detail.update', (ctx) => {
          // Check RLS before update
          const existing = db.post-detail.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('PostDetail', id);
          if (!rlsPostDetailUpdate(existing, ctx)) {
            throw createRLSError('update', 'PostDetail');
          }

          const rawItem = db.post-detail.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          return { data: parseRow<Types.PostDetail>(rawItem!, ['author', 'comments']) };
        }),

      delete: (id: string) =>
        executeRequest('post-detail.delete', (ctx) => {
          // Check RLS before delete
          const existing = db.post-detail.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('PostDetail', id);
          if (!rlsPostDetailDelete(existing, ctx)) {
            throw createRLSError('delete', 'PostDetail');
          }

          const item = db.post-detail.delete({ where: { id: { equals: id } } });
        }),
    },

    user-profile: {
      list: (options?: Types.QueryOptions<Types.UserProfileFilter, never>) =>
        executeRequest('user-profile.list', (ctx) => {
          let rawItems = db.user-profile.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.UserProfile>(row, ['stats', 'recentPosts']));

          // Apply RLS filter
          items = items.filter(item => rlsUserProfileSelect(item as unknown as Record<string, unknown>, ctx));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: never[] }) =>
        executeRequest('user-profile.get', (ctx) => {
          const rawItem = db.user-profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('UserProfile', id);
          const item = parseRow<Types.UserProfile>(rawItem, ['stats', 'recentPosts']);

          // Apply RLS check
          if (!rlsUserProfileSelect(item as unknown as Record<string, unknown>, ctx)) {
            throw createRLSError('select', 'UserProfile');
          }

          return { data: item };
        }),

      create: (input: Types.UserProfileCreate) =>
        executeRequest('user-profile.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.user-profile.create(input as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.UserProfile>(rawItem, ['stats', 'recentPosts']);

          // Check RLS on created item
          if (!rlsUserProfileInsert(item as unknown as Record<string, unknown>, ctx)) {
            // Rollback by deleting
            db.user-profile.delete({ where: { id: { equals: item.id } } });
            throw createRLSError('insert', 'UserProfile');
          }

          return { data: item };
        }),

      update: (id: string, input: Types.UserProfileUpdate) =>
        executeRequest('user-profile.update', (ctx) => {
          // Check RLS before update
          const existing = db.user-profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('UserProfile', id);
          if (!rlsUserProfileUpdate(existing, ctx)) {
            throw createRLSError('update', 'UserProfile');
          }

          const rawItem = db.user-profile.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          return { data: parseRow<Types.UserProfile>(rawItem!, ['stats', 'recentPosts']) };
        }),

      delete: (id: string) =>
        executeRequest('user-profile.delete', (ctx) => {
          // Check RLS before delete
          const existing = db.user-profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!existing) throw createNotFoundError('UserProfile', id);
          if (!rlsUserProfileDelete(existing, ctx)) {
            throw createRLSError('delete', 'UserProfile');
          }

          const item = db.user-profile.delete({ where: { id: { equals: id } } });
        }),
    },

  };
}

/**
 * Default API client (no interceptors configured).
 * For production, use createClient() with interceptors instead.
 * 
 * @example
 * ```typescript
 * // Simple usage (no auth)
 * const posts = await api.post.list();
 * 
 * // For production with auth, use createClient instead:
 * const api = createClient({
 *   onRequest: (ctx) => {
 *     ctx.headers.Authorization = `Bearer ${getToken()}`;
 *     return ctx;
 *   }
 * });
 * ```
 */
export const api = createClient();