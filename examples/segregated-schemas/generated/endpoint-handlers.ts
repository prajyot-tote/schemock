// GENERATED BY SCHEMOCK - DO NOT EDIT
// MSW handlers for custom endpoints

import { http, HttpResponse } from 'msw';
import { db } from './db';
import { endpointResolvers } from './endpoint-resolvers';
import type * as Types from './types';

// Error classes for typed error handling
class ApiError extends Error {
  readonly status: number;
  readonly code: string;

  constructor(message: string, status: number, code?: string) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.code = code ?? "API_ERROR";
  }
}

class RLSError extends Error {
  constructor(message: string = "Access denied") {
    super(message);
    this.name = "RLSError";
  }
}

// Centralized error handler for endpoint handlers
function handleError(error: unknown): Response {
  if (error instanceof ApiError) {
    return HttpResponse.json({ error: error.message, code: error.code }, { status: error.status });
  }
  if (error instanceof RLSError) {
    return HttpResponse.json({ error: error.message }, { status: 403 });
  }
  if (error instanceof Error) {
    if (error.message.toLowerCase().includes("not found")) {
      return HttpResponse.json({ error: error.message }, { status: 404 });
    }
    console.error("Endpoint error:", error);
    return HttpResponse.json({ error: error.message }, { status: 500 });
  }
  console.error("Unknown endpoint error:", error);
  return HttpResponse.json({ error: "Internal server error" }, { status: 500 });
}

// Decode JWT payload for context extraction (middleware support)
function decodeJwtPayload(token: string): Record<string, unknown> | undefined {
  try {
    const base64Url = token.split('.')[1];
    if (!base64Url) return undefined;
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(atob(base64).split('').map(c =>
      '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
    ).join(''));
    return JSON.parse(jsonPayload);
  } catch {
    return undefined;
  }
}

// Extract context from request headers (JWT Bearer token)
function extractContextFromHeaders(headers: Record<string, string>): Record<string, unknown> | undefined {
  const authHeader = headers["Authorization"] || headers["authorization"];
  if (!authHeader) return undefined;

  const token = authHeader.startsWith("Bearer ")
    ? authHeader.slice(7)
    : authHeader;

  return token ? decodeJwtPayload(token) : undefined;
}

export const endpointHandlers = [
  // POST /api/posts/bulk-delete
  http.post('/api/posts/bulk-delete', async ({ request, params: pathParams }) => {
    const params = {};

    const body = await request.json();

    const headers: Record<string, string> = {};
    request.headers.forEach((value, key) => { headers[key] = value; });

    const context = extractContextFromHeaders(headers);

    try {
      const result = await endpointResolvers.postsBulkDelete({ db, params: params, body: body as Types.PostsBulkDeleteBody, headers, context });
      return HttpResponse.json(result);
    } catch (error) {
      return handleError(error);
    }
  }),

  // POST /api/posts/bulk-publish
  http.post('/api/posts/bulk-publish', async ({ request, params: pathParams }) => {
    const params = {};

    const body = await request.json();

    const headers: Record<string, string> = {};
    request.headers.forEach((value, key) => { headers[key] = value; });

    const context = extractContextFromHeaders(headers);

    try {
      const result = await endpointResolvers.postsBulkPublish({ db, params: params, body: body as Types.PostsBulkPublishBody, headers, context });
      return HttpResponse.json(result);
    } catch (error) {
      return handleError(error);
    }
  }),

  // GET /api/users/:userId/stats
  http.get('/api/users/:userId/stats', async ({ request, params: pathParams }) => {
    const url = new URL(request.url);
    const params = {
      userId: pathParams.userId as string,
    };

    const body = {};

    const headers: Record<string, string> = {};
    request.headers.forEach((value, key) => { headers[key] = value; });

    const context = extractContextFromHeaders(headers);

    try {
      const result = await endpointResolvers.usersByUserIdStats({ db, params: params as Types.UsersByUserIdStatsParams, body: body, headers, context });
      return HttpResponse.json(result);
    } catch (error) {
      return handleError(error);
    }
  }),

  // GET /api/search
  http.get('/api/search', async ({ request, params: pathParams }) => {
    const url = new URL(request.url);
    const params = {
      q: url.searchParams.get('q') ?? undefined,
      type: url.searchParams.get('type') ?? "all",
      limit: Number(url.searchParams.get('limit') ?? 20),
    };

    const body = {};

    const headers: Record<string, string> = {};
    request.headers.forEach((value, key) => { headers[key] = value; });

    const context = extractContextFromHeaders(headers);

    try {
      const result = await endpointResolvers.search({ db, params: params as Types.SearchParams, body: body, headers, context });
      return HttpResponse.json(result);
    } catch (error) {
      return handleError(error);
    }
  }),

];