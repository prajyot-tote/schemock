// GENERATED BY SCHEMOCK - DO NOT EDIT
import { db } from './db';
import { faker } from '@faker-js/faker';

faker.seed(Date.now());

export interface SeedCounts {
  user?: number;
  post?: number;
  comment?: number;
  postDetail?: number;
  userProfile?: number;
}

const defaultCounts: Required<SeedCounts> = {
  user: 5,
  post: 15,
  comment: 30,
  postDetail: 10,
  userProfile: 10,
};

function pickRandom<T>(arr: T[]): T | undefined {
  if (arr.length === 0) return undefined;
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateUser(): { email: string; name: string; role: 'admin' | 'user' | 'guest'; avatar: string | null; createdAt: Date } {
  return {
    email: faker.internet.email(),
    name: faker.person.fullName(),
    role: faker.helpers.arrayElement(['admin', 'user', 'guest']),
    avatar: Math.random() > 0.1 ? faker.image.avatar() : null,
    createdAt: faker.date.recent(),
  };
}

function generatePost(): { title: string; content: string; authorId: string; published: boolean; views: number; createdAt: Date; updatedAt: Date } {
  return {
    title: faker.lorem.sentence(),
    content: faker.lorem.paragraphs(2),
    authorId: '',
    published: faker.datatype.boolean(),
    views: faker.number.float({ min: 0, max: 1000, fractionDigits: 2 }),
    createdAt: faker.date.recent(),
    updatedAt: faker.date.recent(),
  };
}

function generateComment(): { content: string; userId: string; postId: string; createdAt: Date } {
  return {
    content: faker.lorem.paragraph(),
    userId: '',
    postId: '',
    createdAt: faker.date.recent(),
  };
}

function generatePostDetail(): {  } {
  return {
  };
}

function generateUserProfile(): {  } {
  return {
  };
}

/**
 * Seed the database with fake data.
 * 
 * Creates entities in dependency order to ensure valid foreign key references.
 * Uses the db layer directly, which naturally bypasses RLS.
 * 
 * @param counts - Optional count overrides per entity
 * 
 * @example
 * ```typescript
 * // Seed with defaults
 * await seed();
 * 
 * // Seed with custom counts
 * await seed({ user: 5, post: 20 });
 * ```
 */
export async function seed(counts: SeedCounts = {}): Promise<void> {
  const merged = { ...defaultCounts, ...counts };

  // Track created entity IDs for foreign key references
  const ids: Record<string, string[]> = {};

  ids.user = [];
  for (let i = 0; i < merged.user; i++) {
    const data = generateUser();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.user.create(data as any);
    ids.user.push(created.id);
  }

  ids.post = [];
  for (let i = 0; i < merged.post; i++) {
    const data = generatePost();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.post.create(data as any);
    ids.post.push(created.id);
  }

  ids.comment = [];
  for (let i = 0; i < merged.comment; i++) {
    const data = generateComment();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.comment.create(data as any);
    ids.comment.push(created.id);
  }

  ids.postDetail = [];
  for (let i = 0; i < merged.postDetail; i++) {
    const data = generatePostDetail();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.postDetail.create(data as any);
    ids.postDetail.push(created.id);
  }

  ids.userProfile = [];
  for (let i = 0; i < merged.userProfile; i++) {
    const data = generateUserProfile();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.userProfile.create(data as any);
    ids.userProfile.push(created.id);
  }

  console.log('\u2713 Database seeded');
}

/**
 * Reset the database by deleting all data.
 * 
 * Deletes entities in reverse dependency order to respect foreign key constraints.
 * 
 * @example
 * ```typescript
 * await reset();
 * ```
 */
export async function reset(): Promise<void> {
  const userProfileList = db.userProfile.getAll();
  for (const item of userProfileList) {
    db.userProfile.delete({ where: { id: { equals: item.id } } });
  }

  const postDetailList = db.postDetail.getAll();
  for (const item of postDetailList) {
    db.postDetail.delete({ where: { id: { equals: item.id } } });
  }

  const commentList = db.comment.getAll();
  for (const item of commentList) {
    db.comment.delete({ where: { id: { equals: item.id } } });
  }

  const postList = db.post.getAll();
  for (const item of postList) {
    db.post.delete({ where: { id: { equals: item.id } } });
  }

  const userList = db.user.getAll();
  for (const item of userList) {
    db.user.delete({ where: { id: { equals: item.id } } });
  }

  console.log('\u2713 Database reset');
}

/**
 * Get all data from the database.
 * 
 * Useful for debugging and testing.
 * 
 * @returns Record of entity name to array of items
 * 
 * @example
 * ```typescript
 * const data = await getAll();
 * console.log(data.user); // All users
 * ```
 */
export async function getAll(): Promise<Record<string, unknown[]>> {
  return {
    user: db.user.getAll(),
    post: db.post.getAll(),
    comment: db.comment.getAll(),
    postDetail: db.postDetail.getAll(),
    userProfile: db.userProfile.getAll(),
  };
}

/**
 * Get the count of each entity in the database.
 * 
 * @returns Record of entity name to count
 * 
 * @example
 * ```typescript
 * const counts = await count();
 * console.log(counts.user); // Number of users
 * ```
 */
export async function count(): Promise<Record<string, number>> {
  return {
    user: db.user.getAll().length,
    post: db.post.getAll().length,
    comment: db.comment.getAll().length,
    postDetail: db.postDetail.getAll().length,
    userProfile: db.userProfile.getAll().length,
  };
}

// ======================================================================
// Production Seed Utilities
// ======================================================================

// Import production seed configuration
// Create a seed-data.ts file in your project root with:
// export const seedConfig = { secret: "your-secret", data: { users: [...], products: [...] } };

/**
 * Result of a production seed operation.
 */
export interface SeedResult {
  success: boolean;
  error?: 'INVALID_SECRET' | 'ALREADY_SEEDED';
  seededAt?: Date;
}

/**
 * Configuration for production seed data.
 * 
 * Define this in your seed-data.ts file:
 * ```typescript
 * export const seedConfig = {
 *   secret: 'my-production-secret-123',
 *   data: {
 *     users: [{ id: 'admin-uuid', name: 'Super Admin', email: 'admin@example.com' }],
 *     products: [{ id: 'prod-1', name: 'Default Product', price: 9.99 }],
 *   },
 * };
 * ```
 */
export interface ProductionSeedData {
  secret: string;
  data: Record<string, Record<string, unknown>[]>;
}

// localStorage key for kill switch
const SEED_STORAGE_KEY = '_schemock_seeded';

/**
 * Check if production data has already been seeded.
 * 
 * @returns true if production seed has already run
 * 
 * @example
 * ```typescript
 * if (!isSeeded()) {
 *   await runProductionSeed('my-secret');
 * }
 * ```
 */
export function isSeeded(): boolean {
  if (typeof localStorage === 'undefined') return false;
  return localStorage.getItem(SEED_STORAGE_KEY) !== null;
}

/**
 * Reset the production seed kill switch.
 * 
 * Call this if you need to re-seed production data.
 * 
 * @example
 * ```typescript
 * resetProductionSeed();
 * await runProductionSeed('my-secret');
 * ```
 */
export function resetProductionSeed(): void {
  if (typeof localStorage === 'undefined') return;
  localStorage.removeItem(SEED_STORAGE_KEY);
}

/**
 * Get the timestamp when production data was seeded.
 * 
 * @returns Date when seeded, or null if not seeded
 */
export function getSeededAt(): Date | null {
  if (typeof localStorage === 'undefined') return null;
  const timestamp = localStorage.getItem(SEED_STORAGE_KEY);
  if (!timestamp) return null;
  return new Date(parseInt(timestamp, 10));
}

// Seed reference resolution helpers
const SEED_REF_BRAND = '__schemock_seed_ref__';

function isSeedReference(value: unknown): boolean {
  return (
    typeof value === 'object' &&
    value !== null &&
    SEED_REF_BRAND in value &&
    (value as Record<string, unknown>)[SEED_REF_BRAND] === true
  );
}

function resolveRef(marker: Record<string, unknown>, createdRecords: Map<string, Record<string, unknown>[]>): unknown {
  const entity = marker.entity as string;
  const field = marker.field as string;
  const records = createdRecords.get(entity);

  if (marker.type === 'ref') {
    const index = marker.index as number;
    if (!records || records.length <= index) {
      throw new Error(`Seed ref error: entity '${entity}' has ${records?.length ?? 0} records, but ref() requested index ${index}`);
    }
    return records[index][field];
  }

  if (marker.type === 'lookup') {
    const where = marker.where as Record<string, unknown>;
    if (!records) {
      throw new Error(`Seed lookup error: entity '${entity}' has no records yet. Ensure it is seeded before entities that reference it.`);
    }
    const match = records.find((r) => {
      return Object.entries(where).every(([k, v]) => r[k] === v);
    });
    if (!match) {
      throw new Error(`Seed lookup error: no '${entity}' record matches ${JSON.stringify(where)}`);
    }
    return match[field];
  }

  throw new Error(`Unknown seed reference type: ${String(marker.type)}`);
}

function resolveItem(item: Record<string, unknown>, createdRecords: Map<string, Record<string, unknown>[]>, entityName: string): Record<string, unknown> {
  const resolved: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(item)) {
    if (isSeedReference(value)) {
      resolved[key] = resolveRef(value as Record<string, unknown>, createdRecords);
    } else {
      resolved[key] = value;
    }
  }
  return resolved;
}

// Entity insertion order (topologically sorted by dependencies)
const entityOrder: string[] = ['user', 'post', 'comment', 'postDetail', 'userProfile'];

/**
 * Run the production seed with secret validation and kill switch.
 * 
 * This function:
 * 1. Validates the provided secret against seedConfig.secret
 * 2. Checks if data has already been seeded (kill switch)
 * 3. Inserts the seed data into the database
 * 4. Sets the kill switch to prevent re-seeding
 * 
 * @param secretKey - The secret key to validate against seedConfig.secret
 * @param seedConfig - The seed configuration with secret and data
 * @returns SeedResult indicating success or failure
 * 
 * @example
 * ```typescript
 * // First, import your seed config
 * import { seedConfig } from './seed-data';
 * 
 * // Run the seed
 * const result = await runProductionSeed('my-secret', seedConfig);
 * 
 * if (result.success) {
 *   console.log("Seeded at:", result.seededAt);
 * } else if (result.error === "ALREADY_SEEDED") {
 *   console.log("Already seeded at:", result.seededAt);
 * } else if (result.error === "INVALID_SECRET") {
 *   console.error("Invalid secret key");
 * }
 * ```
 */
export async function runProductionSeed(
  secretKey: string,
  seedConfig: ProductionSeedData
): Promise<SeedResult> {
  // 1. Validate secret
  if (secretKey !== seedConfig.secret) {
    return { success: false, error: 'INVALID_SECRET' };
  }

  // 2. Check kill switch
  if (isSeeded()) {
    return {
      success: false,
      error: 'ALREADY_SEEDED',
      seededAt: getSeededAt() ?? undefined,
    };
  }

  // 3. Insert data for each entity (ordered by dependencies)
  const createdRecords = new Map<string, Record<string, unknown>[]>();

  // Determine insertion order: entityOrder first, then any remaining keys
  const orderedEntities = [
    ...entityOrder.filter((e) => e in seedConfig.data),
    ...Object.keys(seedConfig.data).filter((e) => !entityOrder.includes(e)),
  ];

  for (const entity of orderedEntities) {
    const items = seedConfig.data[entity];
    // Get the db method for this entity
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const entityDb = (db as any)[entity];
    if (!entityDb) {
      console.warn(`Unknown entity in seed data: ${entity}`);
      continue;
    }

    const entityRecords: Record<string, unknown>[] = [];
    for (const item of items) {
      try {
        const resolved = resolveItem(item, createdRecords, entity);
        const created = entityDb.create(resolved);
        entityRecords.push(created);
      } catch (e) {
        // Ignore duplicate key errors, log others
        const error = e as Error;
        if (!error.message?.includes('duplicate')) {
          console.warn(`Failed to seed ${entity}:`, error.message);
        }
      }
    }
    createdRecords.set(entity, entityRecords);
  }

  // 4. Set kill switch
  const seededAt = new Date();
  if (typeof localStorage !== 'undefined') {
    localStorage.setItem(SEED_STORAGE_KEY, seededAt.getTime().toString());
  }

  console.log('\u2713 Production data seeded');
  return { success: true, seededAt };
}