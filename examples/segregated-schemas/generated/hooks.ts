// GENERATED BY SCHEMOCK - DO NOT EDIT
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useMemo } from 'react';
import { api } from './client';
import type * as Types from './types';

// =============================================================================
// Stable Query Key Helper
// 
// Creates stable query keys from options objects to prevent unnecessary
// refetches when object references change but values are the same.
// =============================================================================

/**
 * Create a stable serialized key from an options object.
 * Uses JSON.stringify with sorted keys for consistent ordering.
 * 
 * @param options - The options object to serialize
 * @returns A stable string representation of the options
 */
function stableKey(options: unknown): string {
  if (options === undefined || options === null) return "";
  try {
    // Sort object keys for consistent serialization
    return JSON.stringify(options, (_, value) => {
      if (value && typeof value === "object" && !Array.isArray(value)) {
        return Object.keys(value).sort().reduce((sorted, key) => {
          sorted[key] = value[key];
          return sorted;
        }, {} as Record<string, unknown>);
      }
      return value;
    });
  } catch {
    // Fallback for non-serializable values
    return String(options);
  }
}

/**
 * React hook that memoizes a stable query key from options.
 * Only recomputes when the serialized value changes.
 * 
 * @param baseKey - The base query key (e.g., "users")
 * @param options - Optional options to include in the key
 * @returns A stable query key array
 */
function useStableQueryKey(baseKey: string, ...parts: unknown[]): unknown[] {
  const serialized = parts.map(p => stableKey(p)).join("|");
  return useMemo(() => [baseKey, ...parts], [baseKey, serialized]);
}

// ==================== User Hooks ====================

/** Fetch list of users */
export function useUsers(options?: {
  where?: Types.UserFilter;
  orderBy?: Record<string, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
  enabled?: boolean;
}) {
  // Use stable query key to prevent unnecessary refetches
  const queryKey = useStableQueryKey('users', options);
  return useQuery({
    queryKey,
    queryFn: () => api.user.list(options),
    enabled: options?.enabled ?? true,
  });
}

/** Fetch single User by ID */
export function useUser(id: string | undefined, options?: {
  enabled?: boolean;
}) {
  return useQuery({
    queryKey: ['users', id],
    queryFn: () => api.user.get(id!),
    enabled: (options?.enabled ?? true) && !!id,
  });
}

/** Create a new User */
export function useCreateUser() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: Types.UserCreate) => api.user.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}

/** Update an existing User */
export function useUpdateUser() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Types.UserUpdate }) =>
      api.user.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
      queryClient.invalidateQueries({ queryKey: ['users', id] });
    },
  });
}

/** Delete a User */
export function useDeleteUser() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.user.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });
}

// ==================== Post Hooks ====================

/** Fetch list of posts */
export function usePosts(options?: {
  where?: Types.PostFilter;
  orderBy?: Record<string, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
  enabled?: boolean;
}) {
  // Use stable query key to prevent unnecessary refetches
  const queryKey = useStableQueryKey('posts', options);
  return useQuery({
    queryKey,
    queryFn: () => api.post.list(options),
    enabled: options?.enabled ?? true,
  });
}

/** Fetch single Post by ID */
export function usePost(id: string | undefined, options?: {
  enabled?: boolean;
}) {
  return useQuery({
    queryKey: ['posts', id],
    queryFn: () => api.post.get(id!),
    enabled: (options?.enabled ?? true) && !!id,
  });
}

/** Create a new Post */
export function useCreatePost() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: Types.PostCreate) => api.post.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
  });
}

/** Update an existing Post */
export function useUpdatePost() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Types.PostUpdate }) =>
      api.post.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['posts'] });
      queryClient.invalidateQueries({ queryKey: ['posts', id] });
    },
  });
}

/** Delete a Post */
export function useDeletePost() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.post.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    },
  });
}

// ==================== Comment Hooks ====================

/** Fetch list of comments */
export function useComments(options?: {
  where?: Types.CommentFilter;
  orderBy?: Record<string, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
  enabled?: boolean;
}) {
  // Use stable query key to prevent unnecessary refetches
  const queryKey = useStableQueryKey('comments', options);
  return useQuery({
    queryKey,
    queryFn: () => api.comment.list(options),
    enabled: options?.enabled ?? true,
  });
}

/** Fetch single Comment by ID */
export function useComment(id: string | undefined, options?: {
  enabled?: boolean;
}) {
  return useQuery({
    queryKey: ['comments', id],
    queryFn: () => api.comment.get(id!),
    enabled: (options?.enabled ?? true) && !!id,
  });
}

/** Create a new Comment */
export function useCreateComment() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: Types.CommentCreate) => api.comment.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['comments'] });
    },
  });
}

/** Update an existing Comment */
export function useUpdateComment() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Types.CommentUpdate }) =>
      api.comment.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['comments'] });
      queryClient.invalidateQueries({ queryKey: ['comments', id] });
    },
  });
}

/** Delete a Comment */
export function useDeleteComment() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.comment.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['comments'] });
    },
  });
}

// ==================== PostDetail Hooks ====================

/** Fetch list of post-details */
export function usePostDetails(options?: {
  where?: Types.PostDetailFilter;
  orderBy?: Record<string, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
  enabled?: boolean;
}) {
  // Use stable query key to prevent unnecessary refetches
  const queryKey = useStableQueryKey('post-details', options);
  return useQuery({
    queryKey,
    queryFn: () => api.post-detail.list(options),
    enabled: options?.enabled ?? true,
  });
}

/** Fetch single PostDetail by ID */
export function usePostDetail(id: string | undefined, options?: {
  enabled?: boolean;
}) {
  return useQuery({
    queryKey: ['post-details', id],
    queryFn: () => api.post-detail.get(id!),
    enabled: (options?.enabled ?? true) && !!id,
  });
}

/** Create a new PostDetail */
export function useCreatePostDetail() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: Types.PostDetailCreate) => api.post-detail.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['post-details'] });
    },
  });
}

/** Update an existing PostDetail */
export function useUpdatePostDetail() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Types.PostDetailUpdate }) =>
      api.post-detail.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['post-details'] });
      queryClient.invalidateQueries({ queryKey: ['post-details', id] });
    },
  });
}

/** Delete a PostDetail */
export function useDeletePostDetail() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.post-detail.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['post-details'] });
    },
  });
}

// ==================== UserProfile Hooks ====================

/** Fetch list of user-profiles */
export function useUserProfiles(options?: {
  where?: Types.UserProfileFilter;
  orderBy?: Record<string, 'asc' | 'desc'>;
  limit?: number;
  offset?: number;
  enabled?: boolean;
}) {
  // Use stable query key to prevent unnecessary refetches
  const queryKey = useStableQueryKey('user-profiles', options);
  return useQuery({
    queryKey,
    queryFn: () => api.user-profile.list(options),
    enabled: options?.enabled ?? true,
  });
}

/** Fetch single UserProfile by ID */
export function useUserProfile(id: string | undefined, options?: {
  enabled?: boolean;
}) {
  return useQuery({
    queryKey: ['user-profiles', id],
    queryFn: () => api.user-profile.get(id!),
    enabled: (options?.enabled ?? true) && !!id,
  });
}

/** Create a new UserProfile */
export function useCreateUserProfile() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: Types.UserProfileCreate) => api.user-profile.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user-profiles'] });
    },
  });
}

/** Update an existing UserProfile */
export function useUpdateUserProfile() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Types.UserProfileUpdate }) =>
      api.user-profile.update(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['user-profiles'] });
      queryClient.invalidateQueries({ queryKey: ['user-profiles', id] });
    },
  });
}

/** Delete a UserProfile */
export function useDeleteUserProfile() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) => api.user-profile.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user-profiles'] });
    },
  });
}
