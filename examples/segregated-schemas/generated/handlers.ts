// GENERATED BY SCHEMOCK - DO NOT EDIT
import { http, HttpResponse } from 'msw';
import { api } from './client';
import { routes } from './routes';
import type * as Types from './types';

// RLS error class for access denied responses
class RLSError extends Error {
  readonly code = "RLS_DENIED";
  constructor(operation: string, entity: string) {
    super(`Access denied: ${operation} on ${entity}`);
    this.name = "RLSError";
  }
}

// Handle errors and return appropriate HTTP responses
function handleError(error: unknown): Response {
  if (error instanceof RLSError) {
    return HttpResponse.json({ error: error.message }, { status: 403 });
  }
  if (error instanceof Error && error.message.includes("not found")) {
    return HttpResponse.json({ error: error.message }, { status: 404 });
  }
  console.error(error);
  return HttpResponse.json({ error: 'Internal server error' }, { status: 500 });
}

export const handlers = [
  // User handlers
  http.get(routes.users.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    try {
      const response = await api.user.list({ limit, offset });
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.get(routes.users.get.path, async ({ params }) => {
    try {
      const response = await api.user.get(params.id as string);
      if (!response.data) {
        return HttpResponse.json({ error: 'User not found' }, { status: 404 });
      }
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.post(routes.users.create.path, async ({ request }) => {
    const body = await request.json() as Types.UserCreate;

    try {
      const response = await api.user.create(body);
      return HttpResponse.json(response, { status: 201 });
    } catch (error) {
      return handleError(error);
    }
  }),

  http.put(routes.users.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.UserUpdate;

    try {
      const response = await api.user.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.patch(routes.users.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.UserUpdate;

    try {
      const response = await api.user.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.delete(routes.users.delete.path, async ({ params }) => {
    try {
      await api.user.delete(params.id as string);
      return new HttpResponse(null, { status: 204 });
    } catch (error) {
      return handleError(error);
    }
  }),

  // Post handlers
  http.get(routes.posts.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    try {
      const response = await api.post.list({ limit, offset });
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.get(routes.posts.get.path, async ({ params }) => {
    try {
      const response = await api.post.get(params.id as string);
      if (!response.data) {
        return HttpResponse.json({ error: 'Post not found' }, { status: 404 });
      }
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.post(routes.posts.create.path, async ({ request }) => {
    const body = await request.json() as Types.PostCreate;

    try {
      const response = await api.post.create(body);
      return HttpResponse.json(response, { status: 201 });
    } catch (error) {
      return handleError(error);
    }
  }),

  http.put(routes.posts.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.PostUpdate;

    try {
      const response = await api.post.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.patch(routes.posts.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.PostUpdate;

    try {
      const response = await api.post.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.delete(routes.posts.delete.path, async ({ params }) => {
    try {
      await api.post.delete(params.id as string);
      return new HttpResponse(null, { status: 204 });
    } catch (error) {
      return handleError(error);
    }
  }),

  // Comment handlers
  http.get(routes.comments.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    try {
      const response = await api.comment.list({ limit, offset });
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.get(routes.comments.get.path, async ({ params }) => {
    try {
      const response = await api.comment.get(params.id as string);
      if (!response.data) {
        return HttpResponse.json({ error: 'Comment not found' }, { status: 404 });
      }
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.post(routes.comments.create.path, async ({ request }) => {
    const body = await request.json() as Types.CommentCreate;

    try {
      const response = await api.comment.create(body);
      return HttpResponse.json(response, { status: 201 });
    } catch (error) {
      return handleError(error);
    }
  }),

  http.put(routes.comments.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.CommentUpdate;

    try {
      const response = await api.comment.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.patch(routes.comments.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.CommentUpdate;

    try {
      const response = await api.comment.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.delete(routes.comments.delete.path, async ({ params }) => {
    try {
      await api.comment.delete(params.id as string);
      return new HttpResponse(null, { status: 204 });
    } catch (error) {
      return handleError(error);
    }
  }),

  // PostDetail handlers
  http.get(routes.post-details.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    try {
      const response = await api.post-detail.list({ limit, offset });
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.get(routes.post-details.get.path, async ({ params }) => {
    try {
      const response = await api.post-detail.get(params.id as string);
      if (!response.data) {
        return HttpResponse.json({ error: 'PostDetail not found' }, { status: 404 });
      }
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.post(routes.post-details.create.path, async ({ request }) => {
    const body = await request.json() as Types.PostDetailCreate;

    try {
      const response = await api.post-detail.create(body);
      return HttpResponse.json(response, { status: 201 });
    } catch (error) {
      return handleError(error);
    }
  }),

  http.put(routes.post-details.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.PostDetailUpdate;

    try {
      const response = await api.post-detail.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.patch(routes.post-details.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.PostDetailUpdate;

    try {
      const response = await api.post-detail.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.delete(routes.post-details.delete.path, async ({ params }) => {
    try {
      await api.post-detail.delete(params.id as string);
      return new HttpResponse(null, { status: 204 });
    } catch (error) {
      return handleError(error);
    }
  }),

  // UserProfile handlers
  http.get(routes.user-profiles.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    try {
      const response = await api.user-profile.list({ limit, offset });
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.get(routes.user-profiles.get.path, async ({ params }) => {
    try {
      const response = await api.user-profile.get(params.id as string);
      if (!response.data) {
        return HttpResponse.json({ error: 'UserProfile not found' }, { status: 404 });
      }
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.post(routes.user-profiles.create.path, async ({ request }) => {
    const body = await request.json() as Types.UserProfileCreate;

    try {
      const response = await api.user-profile.create(body);
      return HttpResponse.json(response, { status: 201 });
    } catch (error) {
      return handleError(error);
    }
  }),

  http.put(routes.user-profiles.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.UserProfileUpdate;

    try {
      const response = await api.user-profile.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.patch(routes.user-profiles.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.UserProfileUpdate;

    try {
      const response = await api.user-profile.update(params.id as string, body);
      return HttpResponse.json(response);
    } catch (error) {
      return handleError(error);
    }
  }),

  http.delete(routes.user-profiles.delete.path, async ({ params }) => {
    try {
      await api.user-profile.delete(params.id as string);
      return new HttpResponse(null, { status: 204 });
    } catch (error) {
      return handleError(error);
    }
  }),

];