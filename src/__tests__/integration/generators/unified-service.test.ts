import { describe, it, expect } from 'vitest';
import {
  generateEntityService,
  generateServices,
  generateServicesIndex,
  generateEndpointService,
} from '../../../cli/generators/unified/service';
import { analyzeSchemas } from '../../../cli/analyze';
import { analyzeEndpoints } from '../../../cli/analyze-endpoints';
import { defineData, field, belongsTo, defineEndpoint } from '../../../schema';

describe('Service Generator', () => {
  // Test schemas
  const userSchema = defineData('user', {
    id: field.uuid(),
    name: field.string(),
    email: field.email(),
    tenantId: field.uuid(),
    role: field.enum(['admin', 'user']).default('user'),
  }, {
    rls: {
      scope: [{ field: 'tenantId', contextKey: 'tenantId' }],
      bypass: [{ contextKey: 'role', values: ['admin'] }],
    },
  });

  const postSchema = defineData('post', {
    id: field.uuid(),
    title: field.string(),
    content: field.string(),
    authorId: field.uuid(),
    published: field.boolean().default(false),
    author: belongsTo('user', { foreignKey: 'authorId' }),
  });

  const schemas = analyzeSchemas([userSchema, postSchema], { apiPrefix: '/api' });
  const userSchemaAnalyzed = schemas.find(s => s.name === 'user')!;
  const postSchemaAnalyzed = schemas.find(s => s.name === 'post')!;

  describe('generateEntityService', () => {
    describe('basic structure', () => {
      it('should generate service file with imports', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
        expect(code).toContain("import { db } from './db'");
        expect(code).toContain('import type { User, UserCreate, UserUpdate');
      });

      it('should use custom db import path', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas, {
          dbImport: '@/lib/db',
        });

        expect(code).toContain("import { db } from '@/lib/db'");
      });

      it('should use custom types import path', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas, {
          typesImport: '@/generated/types',
        });

        expect(code).toContain("import type { User, UserCreate, UserUpdate, QueryOptions, UserFilter } from '@/generated/types'");
      });
    });

    describe('MiddlewareContext', () => {
      it('should generate MiddlewareContext interface', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('export interface MiddlewareContext');
        expect(code).toContain('userId?: string');
        expect(code).toContain('role?: string');
      });

      it('should include RLS scope keys in context', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        // tenantId from RLS scope should be in context
        expect(code).toContain('tenantId?: string');
      });
    });

    describe('error classes', () => {
      it('should generate NotFoundError', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('export class NotFoundError extends Error');
        expect(code).toContain('readonly status = 404');
        expect(code).toContain("readonly code = 'NOT_FOUND'");
      });

      it('should generate RLSError', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('export class RLSError extends Error');
        expect(code).toContain('readonly status = 403');
        expect(code).toContain("readonly code = 'RLS_VIOLATION'");
      });
    });

    describe('service methods', () => {
      it('should generate service object with CRUD methods', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('export const userService = {');
        expect(code).toContain('async list(ctx: MiddlewareContext');
        expect(code).toContain('async get(ctx: MiddlewareContext');
        expect(code).toContain('async create(ctx: MiddlewareContext');
        expect(code).toContain('async update(ctx: MiddlewareContext');
        expect(code).toContain('async delete(ctx: MiddlewareContext');
      });

      it('should export service as default', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('export default userService');
      });
    });

    describe('list method', () => {
      it('should generate list with pagination', () => {
        const code = generateEntityService(postSchemaAnalyzed, schemas);

        expect(code).toContain('async list(ctx: MiddlewareContext, options?: QueryOptions<PostFilter>): Promise<Post[]>');
        expect(code).toContain('take: options?.limit ?? 20');
        expect(code).toContain('skip: options?.offset ?? 0');
      });

      it('should apply RLS scope filter when RLS is enabled', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('// Apply RLS scope to filter');
        expect(code).toContain('const rlsFilter: Record<string, unknown> = {}');
        expect(code).toContain('if (ctx.tenantId) {');
        expect(code).toContain('rlsFilter.tenantId = ctx.tenantId');
      });

      it('should not apply RLS filter when RLS is disabled', () => {
        const code = generateEntityService(postSchemaAnalyzed, schemas);

        expect(code).not.toContain('rlsFilter');
        expect(code).toContain("const where = options?.where ?? {}");
      });
    });

    describe('get method', () => {
      it('should throw NotFoundError when record not found', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain("throw new NotFoundError('User', id)");
      });

      it('should check RLS scope when RLS is enabled', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('// Check RLS scope');
        expect(code).toContain('if (ctx.tenantId && record.tenantId !== ctx.tenantId)');
        expect(code).toContain("throw new RLSError('read', 'User')");
      });
    });

    describe('create method', () => {
      it('should inject RLS scope values on create', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('// Inject RLS scope values from context');
        expect(code).toContain('tenantId: ctx.tenantId ?? data.tenantId');
      });

      it('should create directly without RLS injection when RLS disabled', () => {
        const code = generateEntityService(postSchemaAnalyzed, schemas);

        expect(code).toContain('return db.post.create({ data });');
        expect(code).not.toContain('// Inject RLS scope values');
      });
    });

    describe('update method', () => {
      it('should verify access before update', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('// Verify access before update');
        expect(code).toContain('const existing = await this.get(ctx, id)');
      });
    });

    describe('delete method', () => {
      it('should verify access before delete', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas);

        expect(code).toContain('// Verify access before delete');
        expect(code).toContain('await this.get(ctx, id)');
        expect(code).toContain('await db.user.delete({ where: { id } })');
      });
    });

    describe('RLS configuration', () => {
      it('should skip RLS checks in methods when includeRLS is false', () => {
        const code = generateEntityService(userSchemaAnalyzed, schemas, {
          includeRLS: false,
        });

        // RLS filter should not be applied in list method
        expect(code).not.toContain('rlsFilter');
        expect(code).toContain("const where = options?.where ?? {}");

        // RLS checks should not be in get method
        expect(code).not.toContain('// Check RLS scope');
        expect(code).not.toContain("throw new RLSError('read'");

        // Create should not inject RLS scope values
        expect(code).not.toContain('// Inject RLS scope values');
      });
    });
  });

  describe('generateServices', () => {
    it('should generate services for all non-junction schemas', () => {
      const services = generateServices(schemas);

      expect(services.size).toBe(2);
      expect(services.has('user')).toBe(true);
      expect(services.has('post')).toBe(true);
    });

    it('should pass config to each service', () => {
      const services = generateServices(schemas, { dbImport: '@/lib/prisma' });

      const userService = services.get('user')!;
      expect(userService).toContain("import { db } from '@/lib/prisma'");

      const postService = services.get('post')!;
      expect(postService).toContain("import { db } from '@/lib/prisma'");
    });
  });

  describe('generateServicesIndex', () => {
    it('should generate barrel exports for all services', () => {
      const code = generateServicesIndex(schemas);

      expect(code).toContain("export { userService } from './user.service'");
      expect(code).toContain("export { postService } from './post.service'");
    });

    it('should export context types', () => {
      const code = generateServicesIndex(schemas);

      expect(code).toContain("export type { MiddlewareContext as UserContext } from './user.service'");
      expect(code).toContain("export type { MiddlewareContext as PostContext } from './post.service'");
    });
  });

  describe('generateEndpointService', () => {
    const searchEndpoint = defineEndpoint('/api/search', {
      method: 'POST',
      params: {
        q: field.string(),
      },
      body: {
        filters: field.object({ category: field.string().nullable() }).nullable(),
      },
      response: {
        results: field.array(field.object({ id: field.uuid(), name: field.string() })),
        total: field.number(),
      },
      mockResolver: async ({ params, body, db }) => ({ results: [], total: 0 }),
    });

    const endpoints = analyzeEndpoints([searchEndpoint]);
    const searchEndpointAnalyzed = endpoints[0];

    it('should generate endpoint service with imports', () => {
      const code = generateEndpointService(searchEndpointAnalyzed);

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain("import { db } from './db'");
      expect(code).toContain('import type { SearchParams, SearchBody, SearchResponse }');
    });

    it('should generate execute method with correct signature', () => {
      const code = generateEndpointService(searchEndpointAnalyzed);

      expect(code).toContain('export const searchService = {');
      expect(code).toContain('async execute(ctx: MiddlewareContext, params: SearchParams, body: SearchBody): Promise<SearchResponse>');
    });

    it('should include TODO placeholder for implementation in stub mode', () => {
      const code = generateEndpointService(searchEndpointAnalyzed, { mode: 'stub' });

      expect(code).toContain('// TODO: Implement endpoint logic');
      expect(code).toContain("throw new Error('Not implemented: search')");
    });

    it('should call resolver in default (resolver) mode', () => {
      const code = generateEndpointService(searchEndpointAnalyzed);

      expect(code).toContain('return searchResolver({ params, body, db, ctx });');
      expect(code).not.toContain('// TODO: Implement endpoint logic');
    });

    it('should export service as default', () => {
      const code = generateEndpointService(searchEndpointAnalyzed);

      expect(code).toContain('export default searchService');
    });

    describe('endpoint without body', () => {
      const healthEndpoint = defineEndpoint('/api/health', {
        method: 'GET',
        response: {
          status: field.string(),
        },
        mockResolver: async () => ({ status: 'ok' }),
      });

      const healthEndpoints = analyzeEndpoints([healthEndpoint]);
      const healthAnalyzed = healthEndpoints[0];

      it('should generate method without body parameter', () => {
        const code = generateEndpointService(healthAnalyzed);

        expect(code).toContain('async execute(ctx: MiddlewareContext): Promise<HealthResponse>');
        expect(code).not.toContain('body:');
      });
    });
  });
});
