import { describe, it, expect } from 'vitest';
import { generateMockHandlersWithServices } from '../../../cli/generators/mock/handlers';
import { generateServiceHandlerFile } from '../../../cli/generators/node-handlers/handler-template';
import {
  generateServiceRouteFile,
  generateServiceDynamicRouteFile,
} from '../../../cli/generators/nextjs-api/route-template';
import { analyzeSchemas } from '../../../cli/analyze';
import { defineData, field, belongsTo } from '../../../schema';

describe('Service-based Handler Generators', () => {
  // Test schemas
  const userSchema = defineData('user', {
    id: field.uuid(),
    name: field.string(),
    email: field.email(),
    tenantId: field.uuid(),
    role: field.enum(['admin', 'user']).default('user'),
  }, {
    rls: {
      scope: [{ field: 'tenantId', contextKey: 'tenantId' }],
    },
  });

  const postSchema = defineData('post', {
    id: field.uuid(),
    title: field.string(),
    content: field.string(),
    authorId: field.uuid(),
    author: belongsTo('user', { foreignKey: 'authorId' }),
  });

  const schemas = analyzeSchemas([userSchema, postSchema], { apiPrefix: '/api' });
  const userSchemaAnalyzed = schemas.find(s => s.name === 'user')!;
  const postSchemaAnalyzed = schemas.find(s => s.name === 'post')!;

  describe('generateMockHandlersWithServices', () => {
    it('should generate MSW handlers using service layer', () => {
      const code = generateMockHandlersWithServices(schemas, [], {
        servicesImport: './services',
        middlewareImport: './middleware',
      });

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain('// MSW handlers using service layer with middleware');
      expect(code).toContain("import { http, HttpResponse } from 'msw'");
      expect(code).toContain("import { withMiddleware, getMiddleware, type MiddlewareContext } from './middleware'");
      expect(code).toContain("import { userService, postService } from './services'");
    });

    it('should import types for create/update operations', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain('import type { UserCreate, UserUpdate, PostCreate, PostUpdate }');
    });

    it('should generate parseQueryOptions function', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain('function parseQueryOptions(url: URL)');
      expect(code).toContain("url.searchParams.get('limit')");
      expect(code).toContain("url.searchParams.get('offset')");
    });

    it('should generate list handler using service', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain("http.get('/api/users', async ({ request }) => {");
      expect(code).toContain("return withMiddleware(getMiddleware('user', 'list'), request, async (ctx) => {");
      expect(code).toContain('const data = await userService.list(ctx, options)');
      expect(code).toContain('return HttpResponse.json({');
    });

    it('should generate get handler using service', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain("http.get('/api/users/:id', async ({ request, params }) => {");
      expect(code).toContain("getMiddleware('user', 'get')");
      expect(code).toContain('await userService.get(ctx, params.id as string)');
    });

    it('should generate create handler using service', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain("http.post('/api/users', async ({ request }) => {");
      expect(code).toContain("getMiddleware('user', 'create')");
      expect(code).toContain('const body = await request.json() as UserCreate');
      expect(code).toContain('await userService.create(ctx, body)');
      expect(code).toContain('status: 201');
    });

    it('should generate update handlers (PUT and PATCH)', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain("http.put('/api/users/:id', async ({ request, params }) => {");
      expect(code).toContain("http.patch('/api/users/:id', async ({ request, params }) => {");
      expect(code).toContain("getMiddleware('user', 'update')");
      expect(code).toContain('const body = await request.json() as UserUpdate');
      expect(code).toContain('await userService.update(ctx, params.id as string, body)');
    });

    it('should generate delete handler using service', () => {
      const code = generateMockHandlersWithServices(schemas);

      expect(code).toContain("http.delete('/api/users/:id', async ({ request, params }) => {");
      expect(code).toContain("getMiddleware('user', 'delete')");
      expect(code).toContain('await userService.delete(ctx, params.id as string)');
      expect(code).toContain('status: 204');
    });

    it('should respect skip configuration', () => {
      const code = generateMockHandlersWithServices(schemas, [], {
        skip: ['user.delete', 'post.list'],
      });

      // user.delete should be skipped
      expect(code).not.toContain('userService.delete');

      // post.list should be skipped
      expect(code).not.toContain('postService.list');

      // Other operations should exist
      expect(code).toContain('userService.list');
      expect(code).toContain('postService.get');
    });

    it('should use custom API prefix', () => {
      const code = generateMockHandlersWithServices(schemas, [], {
        apiPrefix: '/v2',
      });

      expect(code).toContain("http.get('/v2/users'");
      expect(code).toContain("http.get('/v2/posts'");
    });
  });

  describe('generateServiceHandlerFile', () => {
    it('should generate Express handler file using service layer', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed, {
        servicesImport: '../services',
        middlewareImport: '../middleware',
        typesImport: '../types',
      });

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain("import type { Request, Response, NextFunction } from 'express'");
      expect(code).toContain("import { withMiddleware, getMiddleware, type MiddlewareContext } from '../middleware'");
      expect(code).toContain("import { userService } from '../services'");
      expect(code).toContain("import type { UserCreate, UserUpdate } from '../types'");
    });

    it('should generate list handler', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed);

      expect(code).toContain('export async function list(');
      expect(code).toContain('req: Request');
      expect(code).toContain('res: Response');
      expect(code).toContain('next: NextFunction');
      expect(code).toContain("await withMiddleware(getMiddleware('user', 'list'), req, res, async (ctx) => {");
      expect(code).toContain('await userService.list(ctx, { limit, offset })');
      expect(code).toContain('res.json({');
    });

    it('should generate getOne handler', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed);

      expect(code).toContain('export async function getOne(');
      expect(code).toContain("getMiddleware('user', 'get')");
      expect(code).toContain('const { id } = req.params');
      expect(code).toContain('await userService.get(ctx, id)');
    });

    it('should generate create handler', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed);

      expect(code).toContain('export async function create(');
      expect(code).toContain("getMiddleware('user', 'create')");
      expect(code).toContain('const body = req.body as UserCreate');
      expect(code).toContain('await userService.create(ctx, body)');
      expect(code).toContain('res.status(201).json({ data })');
    });

    it('should generate update handler', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed);

      expect(code).toContain('export async function update(');
      expect(code).toContain("getMiddleware('user', 'update')");
      expect(code).toContain('const body = req.body as UserUpdate');
      expect(code).toContain('await userService.update(ctx, id, body)');
    });

    it('should generate remove handler', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed);

      expect(code).toContain('export async function remove(');
      expect(code).toContain("getMiddleware('user', 'delete')");
      expect(code).toContain('await userService.delete(ctx, id)');
      expect(code).toContain('res.status(204).send()');
    });

    it('should wrap handlers in try-catch', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed);

      expect(code).toContain('try {');
      expect(code).toContain('} catch (error) {');
      expect(code).toContain('next(error)');
    });

    it('should respect skip configuration', () => {
      const code = generateServiceHandlerFile(userSchemaAnalyzed, {
        skip: ['user.delete', 'user.create'],
      });

      expect(code).not.toContain('export async function remove');
      expect(code).not.toContain('export async function create');
      expect(code).toContain('export async function list');
      expect(code).toContain('export async function getOne');
    });
  });

  describe('generateServiceRouteFile (Next.js collection)', () => {
    it('should generate Next.js collection route using service layer', () => {
      const code = generateServiceRouteFile(userSchemaAnalyzed, {
        servicesImport: '../_lib/services',
        middlewareImport: '../_lib/middleware',
        typesImport: '../_lib/types',
      });

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain("import { NextRequest, NextResponse } from 'next/server'");
      expect(code).toContain("import { withMiddleware, getMiddleware } from '../_lib/middleware'");
      expect(code).toContain("import { userService } from '../_lib/services'");
      expect(code).toContain("import type { UserCreate } from '../_lib/types'");
    });

    it('should generate parseQueryOptions function', () => {
      const code = generateServiceRouteFile(userSchemaAnalyzed);

      expect(code).toContain('function parseQueryOptions(url: { searchParams: URLSearchParams })');
    });

    it('should generate GET handler for list', () => {
      const code = generateServiceRouteFile(userSchemaAnalyzed);

      expect(code).toContain('export async function GET(request: NextRequest) {');
      expect(code).toContain("return withMiddleware(getMiddleware('user', 'list'), request, async (ctx) => {");
      expect(code).toContain('const options = parseQueryOptions(request.nextUrl)');
      expect(code).toContain('await userService.list(ctx, options)');
      expect(code).toContain('return NextResponse.json({');
    });

    it('should generate POST handler for create', () => {
      const code = generateServiceRouteFile(userSchemaAnalyzed);

      expect(code).toContain('export async function POST(request: NextRequest) {');
      expect(code).toContain("getMiddleware('user', 'create')");
      expect(code).toContain('const body = await request.json() as UserCreate');
      expect(code).toContain('await userService.create(ctx, body)');
      expect(code).toContain('status: 201');
    });

    it('should respect skip configuration', () => {
      const code = generateServiceRouteFile(userSchemaAnalyzed, {
        skip: ['user.create'],
      });

      expect(code).toContain('export async function GET');
      expect(code).not.toContain('export async function POST');
    });
  });

  describe('generateServiceDynamicRouteFile (Next.js [id])', () => {
    it('should generate Next.js dynamic route using service layer', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed, {
        servicesImport: '../../_lib/services',
        middlewareImport: '../../_lib/middleware',
        typesImport: '../../_lib/types',
      });

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain("import { NextRequest, NextResponse } from 'next/server'");
      expect(code).toContain("import { userService } from '../../_lib/services'");
      expect(code).toContain("import type { UserUpdate } from '../../_lib/types'");
    });

    it('should define RouteParams interface', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed);

      expect(code).toContain('interface RouteParams {');
      expect(code).toContain('params: Promise<{ id: string }>');
    });

    it('should generate GET handler with params extraction', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed);

      expect(code).toContain('export async function GET(request: NextRequest, { params }: RouteParams) {');
      expect(code).toContain('const { id } = await params');
      expect(code).toContain("getMiddleware('user', 'get')");
      expect(code).toContain('await userService.get(ctx, id)');
    });

    it('should generate PUT handler', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed);

      expect(code).toContain('export async function PUT(request: NextRequest, { params }: RouteParams) {');
      expect(code).toContain("getMiddleware('user', 'update')");
      expect(code).toContain('const body = await request.json() as UserUpdate');
      expect(code).toContain('await userService.update(ctx, id, body)');
    });

    it('should generate PATCH handler', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed);

      expect(code).toContain('export async function PATCH(request: NextRequest, { params }: RouteParams) {');
      expect(code).toContain("getMiddleware('user', 'update')");
    });

    it('should generate DELETE handler', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed);

      expect(code).toContain('export async function DELETE(request: NextRequest, { params }: RouteParams) {');
      expect(code).toContain("getMiddleware('user', 'delete')");
      expect(code).toContain('await userService.delete(ctx, id)');
      expect(code).toContain('return new NextResponse(null, { status: 204 })');
    });

    it('should respect skip configuration', () => {
      const code = generateServiceDynamicRouteFile(userSchemaAnalyzed, {
        skip: ['user.delete', 'user.update'],
      });

      expect(code).toContain('export async function GET');
      expect(code).not.toContain('export async function PUT');
      expect(code).not.toContain('export async function PATCH');
      expect(code).not.toContain('export async function DELETE');
    });
  });
});
