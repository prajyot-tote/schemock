import { describe, it, expect } from 'vitest';
import { generateWithMiddleware } from '../../../cli/generators/unified/with-middleware';
import { generateUnifiedHandlers } from '../../../cli/generators/unified/handler';
import { generateEndpointService } from '../../../cli/generators/unified/service';
import { analyzeSchemas } from '../../../cli/analyze';
import { analyzeEndpoints } from '../../../cli/analyze-endpoints';
import { defineData, field, belongsTo, defineEndpoint } from '../../../schema';
import type { AnalyzedMiddlewareRef } from '../../../cli/types';

describe('Custom Endpoint Unified Generation', () => {
  // Test schemas for entity context
  const userSchema = defineData('user', {
    id: field.uuid(),
    name: field.string(),
    email: field.email(),
    role: field.enum(['admin', 'user']).default('user'),
  });

  const postSchema = defineData('post', {
    id: field.uuid(),
    title: field.string(),
    content: field.string(),
    authorId: field.uuid(),
    published: field.boolean().default(false),
    author: belongsTo('user', { foreignKey: 'authorId' }),
  });

  const schemas = analyzeSchemas([userSchema, postSchema], { apiPrefix: '/api' });

  // Test endpoints
  const searchEndpoint = defineEndpoint('/api/search', {
    method: 'POST',
    params: {
      q: field.string(),
      page: field.number().default(1),
      limit: field.number().default(20),
    },
    body: {
      filters: field.object({
        category: field.string().nullable(),
        minPrice: field.number().nullable(),
      }).nullable(),
    },
    response: {
      results: field.array(field.object({ id: field.uuid(), name: field.string(), score: field.number() })),
      total: field.number(),
      page: field.number(),
    },
    mockResolver: async ({ params, body, db }) => ({
      results: [],
      total: 0,
      page: params.page ?? 1,
    }),
  });

  const healthEndpoint = defineEndpoint('/api/health', {
    method: 'GET',
    response: {
      status: field.string(),
      timestamp: field.date(),
    },
    mockResolver: async () => ({
      status: 'ok',
      timestamp: new Date(),
    }),
  });

  const statsEndpoint = defineEndpoint('/api/stats/:entityType', {
    method: 'GET',
    params: {
      entityType: field.string(),
    },
    response: {
      count: field.number(),
      entityType: field.string(),
    },
    mockResolver: async ({ params }) => ({
      count: 0,
      entityType: params.entityType,
    }),
  });

  const endpoints = analyzeEndpoints([searchEndpoint, healthEndpoint, statsEndpoint]);
  const searchAnalyzed = endpoints.find((e) => e.name === 'search')!;
  const healthAnalyzed = endpoints.find((e) => e.name === 'health')!;
  // Note: path params are included in the name, so /api/stats/:entityType becomes statsByEntityType
  const statsAnalyzed = endpoints.find((e) => e.name === 'statsByEntityType')!;

  describe('generateEndpointService', () => {
    describe('resolver mode', () => {
      it('should generate service with execute method calling resolver', () => {
        const code = generateEndpointService(searchAnalyzed, { mode: 'resolver' });

        expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
        expect(code).toContain('export const searchService = {');
        expect(code).toContain('async execute(ctx: MiddlewareContext, params: SearchParams, body: SearchBody): Promise<SearchResponse>');
      });

      it('should call the resolver function from execute method', () => {
        const code = generateEndpointService(searchAnalyzed, { mode: 'resolver' });

        expect(code).toContain('return searchResolver({ params, body, db, ctx });');
      });

      it('should generate resolver function from mockResolverSource', () => {
        const code = generateEndpointService(searchAnalyzed, { mode: 'resolver' });

        expect(code).toContain('const searchResolver =');
        // Should include the resolver context type
        expect(code).toContain('interface SearchResolverContext');
      });

      it('should export service as default', () => {
        const code = generateEndpointService(searchAnalyzed, { mode: 'resolver' });

        expect(code).toContain('export default searchService');
      });
    });

    describe('stub mode', () => {
      it('should generate service with TODO placeholder', () => {
        const code = generateEndpointService(searchAnalyzed, { mode: 'stub' });

        expect(code).toContain('// TODO: Implement endpoint logic');
        expect(code).toContain("throw new Error('Not implemented: search')");
      });

      it('should not include resolver function', () => {
        const code = generateEndpointService(searchAnalyzed, { mode: 'stub' });

        expect(code).not.toContain('const searchResolver =');
      });
    });

    describe('endpoint without body', () => {
      it('should generate method without body parameter', () => {
        const code = generateEndpointService(healthAnalyzed, { mode: 'resolver' });

        expect(code).toContain('async execute(ctx: MiddlewareContext): Promise<HealthResponse>');
        expect(code).not.toContain('body: HealthBody');
      });

      it('should call resolver without body argument', () => {
        const code = generateEndpointService(healthAnalyzed, { mode: 'resolver' });

        expect(code).toContain('return healthResolver({ db, ctx });');
      });
    });

    describe('endpoint with path params', () => {
      it('should include path params in params type', () => {
        const code = generateEndpointService(statsAnalyzed, { mode: 'resolver' });

        // Type names include the full endpoint name (statsByEntityType)
        expect(code).toContain('params: StatsByEntityTypeParams');
        expect(code).toContain('return statsByEntityTypeResolver({ params, db, ctx });');
      });
    });

    describe('custom imports', () => {
      it('should use custom db import path', () => {
        const code = generateEndpointService(searchAnalyzed, {
          mode: 'resolver',
          dbImport: '@/lib/db',
        });

        expect(code).toContain("import { db } from '@/lib/db'");
      });

      it('should use custom types import path', () => {
        const code = generateEndpointService(searchAnalyzed, {
          mode: 'resolver',
          typesImport: '@/generated/types',
        });

        expect(code).toContain("import type { SearchParams, SearchBody, SearchResponse } from '@/generated/types'");
      });
    });
  });

  describe('generateUnifiedHandlers with endpoints', () => {
    describe('MSW target', () => {
      it('should import endpoint services', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          servicesImport: './services',
          includeEndpoints: true,
        });

        expect(code).toContain('searchService');
        expect(code).toContain('healthService');
        expect(code).toContain('statsByEntityTypeService');
      });

      it('should import getEndpointMiddleware', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          middlewareImport: './middleware',
          includeEndpoints: true,
        });

        expect(code).toContain('getEndpointMiddleware');
      });

      it('should import endpoint types', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: true,
        });

        expect(code).toContain('SearchParams');
        expect(code).toContain('SearchBody');
      });

      it('should generate handler for POST endpoint', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          apiPrefix: '/api',
          includeEndpoints: true,
        });

        expect(code).toContain("http.post('/api/search'");
        expect(code).toContain('Custom endpoint: search');
      });

      it('should generate handler for GET endpoint', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          apiPrefix: '/api',
          includeEndpoints: true,
        });

        expect(code).toContain("http.get('/api/health'");
        expect(code).toContain('Custom endpoint: health');
      });

      it('should use withMiddleware with getEndpointMiddleware', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: true,
        });

        expect(code).toContain("getEndpointMiddleware('search')");
        expect(code).toContain("getEndpointMiddleware('health')");
      });

      it('should parse query parameters for endpoints with params', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: true,
        });

        expect(code).toContain('const url = new URL(request.url)');
        expect(code).toContain('const params: SearchParams = {');
      });

      it('should parse body for endpoints with body', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: true,
        });

        expect(code).toContain('const body = await request.json() as SearchBody');
      });

      it('should call endpoint service execute method', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: true,
        });

        expect(code).toContain('await searchService.execute(ctx, params, body)');
        expect(code).toContain('await healthService.execute(ctx)');
      });

      it('should return JSON response', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: true,
        });

        expect(code).toContain('return HttpResponse.json({ data });');
      });

      it('should handle path parameters', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          apiPrefix: '/api',
          includeEndpoints: true,
        });

        // The path is /api/stats/:entityType and endpoint name becomes statsByEntityType
        expect(code).toContain("http.get('/api/stats/:entityType'");
        expect(code).toContain('Custom endpoint: statsByEntityType');
      });

      it('should not include endpoints when includeEndpoints is false', () => {
        const code = generateUnifiedHandlers(schemas, endpoints, {
          target: 'msw',
          includeEndpoints: false,
        });

        expect(code).not.toContain('searchService');
        expect(code).not.toContain("http.post('/api/search'");
      });
    });
  });

  describe('generateWithMiddleware with endpoints', () => {
    it('should generate getEndpointMiddleware function', () => {
      const code = generateWithMiddleware(schemas, {
        target: 'msw',
        endpoints,
      });

      expect(code).toContain('export function getEndpointMiddleware(endpointName: string): MiddlewareHandler[]');
      expect(code).toContain('return endpointMiddlewareConfig[endpointName] ?? []');
    });

    it('should generate endpoint middleware configuration', () => {
      const code = generateWithMiddleware(schemas, {
        target: 'msw',
        endpoints,
      });

      expect(code).toContain('const endpointMiddlewareConfig: Record<string, MiddlewareHandler[]>');
      expect(code).toContain('search: []');
      expect(code).toContain('health: []');
      expect(code).toContain('statsByEntityType: []');
    });

    describe('with endpoint middleware', () => {
      // Create endpoints with middleware for testing
      function createEndpointsWithMiddleware() {
        const searchWithAuth = analyzeEndpoints([searchEndpoint])[0];
        const authMiddleware: AnalyzedMiddlewareRef = {
          name: 'auth',
          pascalName: 'Auth',
          hasConfigOverrides: false,
          sourceFile: '@/middleware',
        };
        searchWithAuth.middleware = [authMiddleware];

        const publicHealth = analyzeEndpoints([healthEndpoint])[0];
        publicHealth.middleware = []; // Explicitly public

        return [searchWithAuth, publicHealth];
      }

      it('should import middleware from endpoints', () => {
        const endpointsWithMiddleware = createEndpointsWithMiddleware();

        const code = generateWithMiddleware(schemas, {
          target: 'msw',
          endpoints: endpointsWithMiddleware,
          middlewareImport: '@/middleware',
        });

        expect(code).toContain("import { authMiddleware } from '@/middleware'");
      });

      it('should generate endpoint middleware arrays', () => {
        const endpointsWithMiddleware = createEndpointsWithMiddleware();

        const code = generateWithMiddleware(schemas, {
          target: 'msw',
          endpoints: endpointsWithMiddleware,
          middlewareImport: '@/middleware',
        });

        expect(code).toContain('search: [authMiddleware]');
        expect(code).toContain('health: []'); // Public endpoint
      });

      it('should handle middleware with config overrides', () => {
        const endpointsWithMiddleware = createEndpointsWithMiddleware();
        endpointsWithMiddleware[0].middleware = [
          {
            name: 'rateLimit',
            pascalName: 'RateLimit',
            hasConfigOverrides: true,
            configOverrides: { max: 100, windowMs: 60000 },
          },
        ];

        const code = generateWithMiddleware(schemas, {
          target: 'msw',
          endpoints: endpointsWithMiddleware,
          middlewareImport: '@/middleware',
        });

        expect(code).toContain('search: [rateLimitMiddleware.with({"max":100,"windowMs":60000})]');
      });
    });
  });

  describe('cross-target consistency', () => {
    const targets = ['msw', 'nextjs', 'express', 'supabase-edge'] as const;

    for (const target of targets) {
      describe(`${target} target`, () => {
        it('should generate withMiddleware function', () => {
          const code = generateWithMiddleware(schemas, {
            target,
            endpoints,
          });

          expect(code).toContain('export async function withMiddleware');
        });

        it('should generate getMiddleware for entities', () => {
          const code = generateWithMiddleware(schemas, {
            target,
            endpoints,
          });

          expect(code).toContain('export function getMiddleware(entity: string, operation: Operation)');
        });

        it('should generate getEndpointMiddleware for custom endpoints', () => {
          const code = generateWithMiddleware(schemas, {
            target,
            endpoints,
          });

          expect(code).toContain('export function getEndpointMiddleware(endpointName: string)');
        });
      });
    }
  });

  describe('edge cases', () => {
    it('should handle empty endpoints array', () => {
      const code = generateUnifiedHandlers(schemas, [], {
        target: 'msw',
        includeEndpoints: true,
      });

      expect(code).toContain('export const handlers = [');
      expect(code).not.toContain('Custom endpoint:');
    });

    it('should handle endpoint with no response type', () => {
      const voidEndpoint = defineEndpoint('/api/notify', {
        method: 'POST',
        body: {
          message: field.string(),
        },
        mockResolver: async () => {},
      });

      const voidEndpoints = analyzeEndpoints([voidEndpoint]);
      const code = generateEndpointService(voidEndpoints[0], { mode: 'stub' });

      expect(code).toContain('async execute(ctx: MiddlewareContext, body: NotifyBody): Promise<void>');
    });

    it('should handle endpoint with nested object types', () => {
      const code = generateEndpointService(searchAnalyzed, { mode: 'resolver' });

      // Should handle the nested filters object
      expect(code).toContain('SearchBody');
    });

    it('should handle endpoint with array response', () => {
      const code = generateEndpointService(searchAnalyzed, { mode: 'resolver' });

      // Should handle the array results
      expect(code).toContain('SearchResponse');
    });
  });
});
