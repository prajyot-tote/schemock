/**
 * Integration tests for Mock handlers generator (MSW)
 */
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { generateMockHandlers } from '../../../cli/generators/mock/handlers';
import { schemas as blogSchemas } from '../fixtures/schemas/blog.schema';
import { schemas as ecommerceSchemas } from '../fixtures/schemas/ecommerce.schema';
import {
  createTempDir,
  cleanupTempDir,
  analyzeTestSchemas,
} from '../utils/test-helpers';
import { assertCodeContains } from '../utils/compile-checker';

describe('Mock Handlers Generator Integration', () => {
  let tempDir: string;

  beforeAll(async () => {
    tempDir = await createTempDir('mock-handlers-test-');
  });

  afterAll(async () => {
    await cleanupTempDir(tempDir);
  });

  it('generates MSW imports', () => {
    const analyzed = analyzeTestSchemas(blogSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    assertCodeContains(code, [
      "import { http, HttpResponse } from 'msw'",
    ]);
  });

  it('generates handlers array export', () => {
    const analyzed = analyzeTestSchemas(blogSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    assertCodeContains(code, [
      'export const handlers = [',
    ]);
  });

  it('generates CRUD handlers for each entity', () => {
    const analyzed = analyzeTestSchemas(blogSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    // Should have HTTP method handlers
    expect(code).toContain('http.get(');
    expect(code).toContain('http.post(');
    expect(code).toContain('http.put(') || expect(code).toContain('http.patch(');
    expect(code).toContain('http.delete(');
  });

  it('generates RLS error handling for schemas with RLS', () => {
    const analyzed = analyzeTestSchemas(ecommerceSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    assertCodeContains(code, [
      'RLSError',
      'handleError',
    ]);
  });

  it('includes 403 status for RLS errors', () => {
    const analyzed = analyzeTestSchemas(ecommerceSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    expect(code).toContain('403');
  });

  it('wraps operations in try-catch when RLS is present', () => {
    const analyzed = analyzeTestSchemas(ecommerceSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    assertCodeContains(code, [
      'try {',
      '} catch',
    ]);
  });

  it('uses routes object for path definitions', () => {
    const analyzed = analyzeTestSchemas(blogSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    expect(code).toContain("import { routes } from './routes'");
  });

  it('includes GENERATED BY header', () => {
    const analyzed = analyzeTestSchemas(blogSchemas);
    const code = generateMockHandlers(analyzed, '/api');

    expect(code).toContain('GENERATED BY SCHEMOCK');
  });

  it('handles empty schema array', () => {
    const analyzed = analyzeTestSchemas([]);
    const code = generateMockHandlers(analyzed, '/api');

    // Should still generate valid handlers array
    assertCodeContains(code, [
      'export const handlers = [',
    ]);
  });

  it('uses custom API prefix', () => {
    const analyzed = analyzeTestSchemas(blogSchemas);
    const code = generateMockHandlers(analyzed, '/v1/api');

    // The routes file would use the prefix, handlers import routes
    expect(code).toBeDefined();
  });
});
