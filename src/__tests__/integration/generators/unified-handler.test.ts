import { describe, it, expect } from 'vitest';
import { generateWithMiddleware } from '../../../cli/generators/unified/with-middleware';
import {
  generateUnifiedHandlers,
  generateNextjsRouteFile,
  generateNextjsDynamicRouteFile,
} from '../../../cli/generators/unified/handler';
import { analyzeSchemas } from '../../../cli/analyze';
import { defineData, field, belongsTo } from '../../../schema';

describe('Unified Handler Generator', () => {
  // Test schemas
  const userSchema = defineData('user', {
    id: field.uuid(),
    name: field.string(),
    email: field.email(),
    tenantId: field.uuid(),
    role: field.enum(['admin', 'user']).default('user'),
  }, {
    rls: {
      scope: [{ field: 'tenantId', contextKey: 'tenantId' }],
      bypass: [{ contextKey: 'role', values: ['admin'] }],
    },
  });

  const postSchema = defineData('post', {
    id: field.uuid(),
    title: field.string(),
    content: field.string(),
    authorId: field.uuid(),
    published: field.boolean().default(false),
    author: belongsTo('user', { foreignKey: 'authorId' }),
  });

  const schemas = analyzeSchemas([userSchema, postSchema], { apiPrefix: '/api' });
  const userSchemaAnalyzed = schemas.find(s => s.name === 'user')!;
  const postSchemaAnalyzed = schemas.find(s => s.name === 'post')!;

  describe('generateWithMiddleware', () => {
    describe('MSW target', () => {
      it('should generate middleware helper with MSW imports', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
        expect(code).toContain("import { HttpResponse } from 'msw'");
      });

      it('should generate MiddlewareContext interface', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('export interface MiddlewareContext');
        expect(code).toContain('userId?: string');
        expect(code).toContain('role?: string');
      });

      it('should include RLS scope keys in context', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('tenantId?: string');
      });

      it('should generate error classes', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('export class AuthError extends Error');
        expect(code).toContain('readonly status = 401');
        expect(code).toContain('export class ForbiddenError extends Error');
        expect(code).toContain('readonly status = 403');
      });

      it('should generate JWT extraction function', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('function decodeJwtPayload(token: string)');
        expect(code).toContain("const parts = token.split('.')");
      });

      it('should generate context extraction from headers', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('export function extractContextFromHeaders');
        expect(code).toContain("const authHeader = getHeader('Authorization')");
        expect(code).toContain("if (authHeader?.startsWith('Bearer '))");
      });

      it('should generate MiddlewareHandler type', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('export type MiddlewareHandler');
        expect(code).toContain('ctx: MiddlewareContext');
        expect(code).toContain('request: Request');
      });

      it('should generate withMiddleware function', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('export async function withMiddleware');
        expect(code).toContain('middleware: MiddlewareHandler[]');
        expect(code).toContain('handler: (ctx: MiddlewareContext) => Promise<Response>');
      });

      it('should generate getMiddleware function', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain("export type Operation = 'list' | 'get' | 'create' | 'update' | 'delete'");
        expect(code).toContain('export function getMiddleware(entity: string, operation: Operation)');
      });

      it('should generate middleware configuration for entities', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        expect(code).toContain('const middlewareConfig');
        expect(code).toContain('user: {');
        expect(code).toContain('post: {');
      });
    });

    describe('Next.js target', () => {
      it('should generate middleware helper with Next.js imports', () => {
        const code = generateWithMiddleware(schemas, { target: 'nextjs' });

        expect(code).toContain("import { NextResponse, type NextRequest } from 'next/server'");
      });

      it('should generate withMiddleware for Next.js', () => {
        const code = generateWithMiddleware(schemas, { target: 'nextjs' });

        expect(code).toContain('request: NextRequest');
        expect(code).toContain('handler: (ctx: MiddlewareContext) => Promise<NextResponse>');
        expect(code).toContain('NextResponse.json');
      });
    });

    describe('Express target', () => {
      it('should generate middleware helper with Express imports', () => {
        const code = generateWithMiddleware(schemas, { target: 'express' });

        expect(code).toContain("import type { Request, Response, NextFunction } from 'express'");
      });

      it('should generate withMiddleware for Express', () => {
        const code = generateWithMiddleware(schemas, { target: 'express' });

        expect(code).toContain('req: Request');
        expect(code).toContain('res: Response');
        expect(code).toContain('handler: (ctx: MiddlewareContext) => Promise<void>');
      });
    });

    describe('Supabase Edge target', () => {
      it('should generate middleware helper for edge functions', () => {
        const code = generateWithMiddleware(schemas, { target: 'supabase-edge' });

        // Should use standard Request/Response
        expect(code).toContain('request: Request');
        expect(code).toContain('handler: (ctx: MiddlewareContext) => Promise<Response>');
      });
    });

    describe('custom headers', () => {
      it('should extract custom headers to context', () => {
        const code = generateWithMiddleware(schemas, {
          target: 'msw',
          customHeaders: ['X-Tenant-ID', 'X-Request-ID'],
        });

        // Headers are converted to camelCase context keys
        expect(code).toContain("const tenantIDHeader = getHeader('X-Tenant-ID')");
        expect(code).toContain("const requestIDHeader = getHeader('X-Request-ID')");
      });
    });

    describe('JWT extraction toggle', () => {
      it('should skip JWT extraction when disabled', () => {
        const code = generateWithMiddleware(schemas, {
          target: 'msw',
          includeJwtExtraction: false,
        });

        expect(code).not.toContain('function decodeJwtPayload');
      });
    });

    describe('middleware wiring', () => {
      // Helper to create a fresh schema with middleware for each test
      function createProductSchemaWithMiddleware() {
        const schemaWithMiddleware = defineData('product', {
          id: field.uuid(),
          name: field.string(),
          price: field.number(),
          tenantId: field.uuid(),
        }, {
          rls: {
            scope: [{ field: 'tenantId', contextKey: 'tenantId' }],
          },
        });
        const schemasWithMiddleware = analyzeSchemas([schemaWithMiddleware], { apiPrefix: '/api' });
        const productSchema = schemasWithMiddleware.find(s => s.name === 'product')!;
        return { schemasWithMiddleware, productSchema };
      }

      it('should generate imports for middleware from middlewareImport config', () => {
        const { schemasWithMiddleware, productSchema } = createProductSchemaWithMiddleware();
        productSchema.middleware = [
          { name: 'auth', pascalName: 'Auth', hasConfigOverrides: false, sourceFile: '@/middleware' },
          { name: 'tenant', pascalName: 'Tenant', hasConfigOverrides: false, sourceFile: '@/middleware' },
        ];
        productSchema.endpointMiddleware = {
          delete: [
            { name: 'admin', pascalName: 'Admin', hasConfigOverrides: false },
          ],
        };

        const code = generateWithMiddleware(schemasWithMiddleware, {
          target: 'msw',
          middlewareImport: '@/middleware',
        });

        expect(code).toContain("import { authMiddleware, tenantMiddleware, adminMiddleware } from '@/middleware'");
      });

      it('should generate imports grouped by source file when no middlewareImport', () => {
        const { schemasWithMiddleware, productSchema } = createProductSchemaWithMiddleware();
        productSchema.middleware = [
          { name: 'auth', pascalName: 'Auth', hasConfigOverrides: false, sourceFile: './middleware/auth' },
          { name: 'tenant', pascalName: 'Tenant', hasConfigOverrides: false, sourceFile: './middleware/tenant' },
        ];

        const code = generateWithMiddleware(schemasWithMiddleware, { target: 'msw' });

        expect(code).toContain("import { authMiddleware } from './middleware/auth'");
        expect(code).toContain("import { tenantMiddleware } from './middleware/tenant'");
      });

      it('should generate actual middleware arrays in config', () => {
        const { schemasWithMiddleware, productSchema } = createProductSchemaWithMiddleware();
        productSchema.middleware = [
          { name: 'auth', pascalName: 'Auth', hasConfigOverrides: false },
          { name: 'tenant', pascalName: 'Tenant', hasConfigOverrides: false },
        ];

        const code = generateWithMiddleware(schemasWithMiddleware, {
          target: 'msw',
          middlewareImport: '@/middleware',
        });

        expect(code).toContain('default: [authMiddleware, tenantMiddleware]');
      });

      it('should handle empty middleware arrays for public endpoints', () => {
        const { schemasWithMiddleware, productSchema } = createProductSchemaWithMiddleware();
        productSchema.middleware = [
          { name: 'auth', pascalName: 'Auth', hasConfigOverrides: false },
        ];
        productSchema.endpointMiddleware = {
          list: [],  // Public list endpoint
        };

        const code = generateWithMiddleware(schemasWithMiddleware, {
          target: 'msw',
          middlewareImport: '@/middleware',
        });

        expect(code).toContain('list: []');
      });

      it('should generate per-operation middleware overrides', () => {
        const { schemasWithMiddleware, productSchema } = createProductSchemaWithMiddleware();
        productSchema.middleware = [
          { name: 'auth', pascalName: 'Auth', hasConfigOverrides: false },
        ];
        productSchema.endpointMiddleware = {
          delete: [
            { name: 'auth', pascalName: 'Auth', hasConfigOverrides: false },
            { name: 'admin', pascalName: 'Admin', hasConfigOverrides: false },
          ],
        };

        const code = generateWithMiddleware(schemasWithMiddleware, {
          target: 'msw',
          middlewareImport: '@/middleware',
        });

        expect(code).toContain('delete: [authMiddleware, adminMiddleware]');
      });

      it('should generate .with() calls for config overrides', () => {
        const { schemasWithMiddleware, productSchema } = createProductSchemaWithMiddleware();
        productSchema.middleware = [
          {
            name: 'rateLimit',
            pascalName: 'RateLimit',
            hasConfigOverrides: true,
            configOverrides: { max: 10, windowMs: 60000 },
          },
        ];

        const code = generateWithMiddleware(schemasWithMiddleware, {
          target: 'msw',
          middlewareImport: '@/middleware',
        });

        expect(code).toContain('rateLimitMiddleware.with({"max":10,"windowMs":60000})');
      });

      it('should not generate imports when no middleware configured', () => {
        const code = generateWithMiddleware(schemas, { target: 'msw' });

        // schemas (user, post) have no middleware configured
        expect(code).not.toContain("import { authMiddleware");
        expect(code).not.toContain("import { tenantMiddleware");
      });
    });
  });

  describe('generateUnifiedHandlers', () => {
    describe('MSW target', () => {
      it('should generate handlers using services and middleware', () => {
        const code = generateUnifiedHandlers(schemas, [], {
          target: 'msw',
          servicesImport: './services',
          middlewareImport: './middleware',
        });

        expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
        expect(code).toContain("import { http, HttpResponse } from 'msw'");
        expect(code).toContain("import { withMiddleware, getMiddleware, type MiddlewareContext } from './middleware'");
        expect(code).toContain("import { userService, postService } from './services'");
      });

      it('should generate type imports', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain('import type { UserCreate, UserUpdate, PostCreate, PostUpdate }');
      });

      it('should generate query options parser', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain('function parseQueryOptions');
        // The parser extracts searchParams from URL first, then uses get()
        expect(code).toContain("searchParams.get('limit')");
        expect(code).toContain("searchParams.get('offset')");
      });

      it('should generate handlers array', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain('export const handlers = [');
      });

      it('should generate list handler with service call', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain("http.get('/api/users'");
        expect(code).toContain("return withMiddleware(getMiddleware('user', 'list'), request, async (ctx) => {");
        expect(code).toContain('const data = await userService.list(ctx, options)');
        expect(code).toContain('return HttpResponse.json({');
      });

      it('should generate get handler', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain("http.get('/api/users/:id'");
        expect(code).toContain("getMiddleware('user', 'get')");
        expect(code).toContain('await userService.get(ctx, params.id as string)');
      });

      it('should generate create handler', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain("http.post('/api/users'");
        expect(code).toContain("getMiddleware('user', 'create')");
        expect(code).toContain('const body = await request.json() as UserCreate');
        expect(code).toContain('await userService.create(ctx, body)');
        expect(code).toContain('status: 201');
      });

      it('should generate update handlers (PUT and PATCH)', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain("http.put('/api/users/:id'");
        expect(code).toContain("http.patch('/api/users/:id'");
        expect(code).toContain("getMiddleware('user', 'update')");
        expect(code).toContain('await userService.update(ctx, params.id as string, body)');
      });

      it('should generate delete handler', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'msw' });

        expect(code).toContain("http.delete('/api/users/:id'");
        expect(code).toContain("getMiddleware('user', 'delete')");
        expect(code).toContain('await userService.delete(ctx, params.id as string)');
        expect(code).toContain('status: 204');
      });

      it('should skip operations when configured', () => {
        const code = generateUnifiedHandlers(schemas, [], {
          target: 'msw',
          skip: ['user.delete', 'post.create'],
        });

        // user.delete should be skipped
        expect(code).not.toContain("await userService.delete");

        // post.create should be skipped
        expect(code).not.toContain("await postService.create");

        // Other operations should still be there
        expect(code).toContain("await userService.list");
        expect(code).toContain("await postService.list");
      });

      it('should use custom API prefix', () => {
        const code = generateUnifiedHandlers(schemas, [], {
          target: 'msw',
          apiPrefix: '/v1/api',
        });

        expect(code).toContain("http.get('/v1/api/users'");
        expect(code).toContain("http.get('/v1/api/posts'");
      });
    });

    describe('Next.js target', () => {
      it('should generate Next.js handler functions', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'nextjs' });

        expect(code).toContain("import { NextRequest, NextResponse } from 'next/server'");
        expect(code).toContain('export async function listUser(request: NextRequest)');
        expect(code).toContain('export async function getUser(request: NextRequest, id: string)');
        expect(code).toContain('export async function createUser(request: NextRequest)');
        expect(code).toContain('export async function updateUser(request: NextRequest, id: string)');
        expect(code).toContain('export async function deleteUser(request: NextRequest, id: string)');
      });
    });

    describe('Express target', () => {
      it('should generate Express handler functions', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'express' });

        expect(code).toContain("import type { Request, Response, NextFunction } from 'express'");
        expect(code).toContain('export async function listUser(req: Request, res: Response, next: NextFunction)');
        expect(code).toContain('res.json({ data, meta: { limit, offset } })');
      });
    });

    describe('Supabase Edge target', () => {
      it('should generate edge function handlers', () => {
        const code = generateUnifiedHandlers(schemas, [], { target: 'supabase-edge' });

        expect(code).toContain('export async function listUser(request: Request): Promise<Response>');
        expect(code).toContain('return jsonResponse({');
      });
    });
  });

  describe('generateNextjsRouteFile', () => {
    it('should generate collection route file', () => {
      const code = generateNextjsRouteFile(userSchemaAnalyzed, {
        target: 'nextjs',
        servicesImport: '../_lib/services',
        middlewareImport: '../_lib/middleware',
        typesImport: '../_lib/types',
      });

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain("import { NextRequest, NextResponse } from 'next/server'");
      expect(code).toContain("import { userService } from '../_lib/services'");
      expect(code).toContain('export async function GET(request: NextRequest)');
      expect(code).toContain('export async function POST(request: NextRequest)');
    });

    it('should call service methods', () => {
      const code = generateNextjsRouteFile(userSchemaAnalyzed, { target: 'nextjs' });

      expect(code).toContain('await userService.list(ctx, options)');
      expect(code).toContain('await userService.create(ctx, body)');
    });
  });

  describe('generateNextjsDynamicRouteFile', () => {
    it('should generate dynamic route file', () => {
      const code = generateNextjsDynamicRouteFile(userSchemaAnalyzed, {
        target: 'nextjs',
        servicesImport: '../../_lib/services',
        middlewareImport: '../../_lib/middleware',
        typesImport: '../../_lib/types',
      });

      expect(code).toContain('// GENERATED BY SCHEMOCK - DO NOT EDIT');
      expect(code).toContain('interface RouteParams');
      expect(code).toContain('params: Promise<{ id: string }>');
      expect(code).toContain('export async function GET(request: NextRequest, { params }: RouteParams)');
      expect(code).toContain('export async function PUT(request: NextRequest, { params }: RouteParams)');
      expect(code).toContain('export async function PATCH(request: NextRequest, { params }: RouteParams)');
      expect(code).toContain('export async function DELETE(request: NextRequest, { params }: RouteParams)');
    });

    it('should extract params with await', () => {
      const code = generateNextjsDynamicRouteFile(userSchemaAnalyzed, { target: 'nextjs' });

      expect(code).toContain('const { id } = await params');
    });

    it('should call service methods with id', () => {
      const code = generateNextjsDynamicRouteFile(userSchemaAnalyzed, { target: 'nextjs' });

      expect(code).toContain('await userService.get(ctx, id)');
      expect(code).toContain('await userService.update(ctx, id, body)');
      expect(code).toContain('await userService.delete(ctx, id)');
    });
  });
});
