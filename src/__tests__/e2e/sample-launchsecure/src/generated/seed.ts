// GENERATED BY SCHEMOCK - DO NOT EDIT
import { db } from './db';
import { faker } from '@faker-js/faker';

faker.seed(Date.now());

export interface SeedCounts {
  authUser?: number;
  authSession?: number;
  profile?: number;
  organization?: number;
  permission?: number;
  permissionTemplate?: number;
  project?: number;
  userPermissionMap?: number;
  environment?: number;
  deployment?: number;
  securityScan?: number;
  teamInvitation?: number;
  teamMember?: number;
}

const defaultCounts: Required<SeedCounts> = {
  authUser: 10,
  authSession: 10,
  profile: 10,
  organization: 10,
  permission: 10,
  permissionTemplate: 10,
  project: 10,
  userPermissionMap: 10,
  environment: 10,
  deployment: 10,
  securityScan: 10,
  teamInvitation: 10,
  teamMember: 10,
};

function pickRandom<T>(arr: T[]): T | undefined {
  if (arr.length === 0) return undefined;
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateAuthuser(): { email: string; encrypted_password: string; email_confirmed_at: Date | null; full_name: string | null; avatar_url: string | null } {
  return {
    email: faker.internet.email(),
    encrypted_password: faker.lorem.word(),
    email_confirmed_at: Math.random() > 0.1 ? faker.date.recent() : null,
    full_name: Math.random() > 0.1 ? faker.person.fullName() : null,
    avatar_url: Math.random() > 0.1 ? faker.internet.url() : null,
  };
}

function generateAuthsession(): { user_id: string; access_token: string; refresh_token: string; expires_at: Date } {
  return {
    user_id: '',
    access_token: faker.string.uuid(),
    refresh_token: faker.string.uuid(),
    expires_at: faker.date.recent(),
  };
}

function generateProfile(): { email: string; full_name: string | null; avatar_url: string | null } {
  return {
    email: faker.internet.email(),
    full_name: Math.random() > 0.1 ? faker.person.fullName() : null,
    avatar_url: Math.random() > 0.1 ? faker.internet.url() : null,
  };
}

function generateOrganization(): { name: string; slug: string; logo: string | null; industry: 'technology' | 'healthcare' | 'finance' | 'retail' | 'manufacturing' | 'education' | 'government' | 'other'; company_size: '1-10' | '11-50' | '51-200' | '201-500' | '501-1000' | '1000+'; website: string | null; billing_email: string | null; owner_id: string; settings: {  } } {
  return {
    name: faker.company.name(),
    slug: faker.lorem.word(),
    logo: Math.random() > 0.1 ? faker.internet.url() : null,
    industry: faker.helpers.arrayElement(['technology', 'healthcare', 'finance', 'retail', 'manufacturing', 'education', 'government', 'other']),
    company_size: faker.helpers.arrayElement(['1-10', '11-50', '51-200', '201-500', '501-1000', '1000+']),
    website: Math.random() > 0.1 ? faker.internet.url() : null,
    billing_email: Math.random() > 0.1 ? faker.internet.email() : null,
    owner_id: '',
    settings: ({  }),
  };
}

function generatePermission(): { key: string; name: string; description: string; organization_id: string | null } {
  return {
    key: faker.lorem.word(),
    name: faker.lorem.word(),
    description: faker.lorem.sentence(),
    organization_id: null,
  };
}

function generatePermissiontemplate(): { name: string; description: string; organization_id: string | null; is_system: boolean; permissions: string[] } {
  return {
    name: faker.lorem.word(),
    description: faker.lorem.sentence(),
    organization_id: null,
    is_system: faker.datatype.boolean(),
    permissions: Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, () => faker.lorem.word()),
  };
}

function generateProject(): { name: string; description: string | null; repo_url: string | null; status: 'active' | 'archived' | 'draft'; owner_id: string; settings: {  } | null } {
  return {
    name: faker.company.name(),
    description: Math.random() > 0.1 ? faker.lorem.paragraph() : null,
    repo_url: Math.random() > 0.1 ? faker.internet.url() : null,
    status: faker.helpers.arrayElement(['active', 'archived', 'draft']),
    owner_id: '',
    settings: Math.random() > 0.1 ? ({  }) : null,
  };
}

function generateUserpermissionmap(): { user_id: string; organization_id: string | null; project_id: string | null; permissions: string[]; granted_by: string; granted_at: Date; expires_at: Date | null; reason: string | null } {
  return {
    user_id: '',
    organization_id: null,
    project_id: null,
    permissions: Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, () => faker.lorem.word()),
    granted_by: '',
    granted_at: faker.date.recent(),
    expires_at: Math.random() > 0.1 ? faker.date.recent() : null,
    reason: Math.random() > 0.1 ? faker.lorem.sentence() : null,
  };
}

function generateEnvironment(): { project_id: string; name: 'development' | 'staging' | 'uat' | 'production'; url: string | null; branch: string; variables: {  }; is_protected: boolean } {
  return {
    project_id: '',
    name: faker.helpers.arrayElement(['development', 'staging', 'uat', 'production']),
    url: Math.random() > 0.1 ? faker.internet.url() : null,
    branch: faker.lorem.word(),
    variables: ({  }),
    is_protected: faker.datatype.boolean(),
  };
}

function generateDeployment(): { project_id: string; environment_id: string; commit_sha: string; commit_message: string | null; status: 'pending' | 'building' | 'deploying' | 'success' | 'failed' | 'rolled_back'; deployed_by: string; logs: string | null; started_at: Date; completed_at: Date | null } {
  return {
    project_id: '',
    environment_id: '',
    commit_sha: faker.lorem.word(),
    commit_message: Math.random() > 0.1 ? faker.lorem.sentence() : null,
    status: faker.helpers.arrayElement(['pending', 'building', 'deploying', 'success', 'failed', 'rolled_back']),
    deployed_by: '',
    logs: Math.random() > 0.1 ? faker.lorem.word() : null,
    started_at: faker.date.recent(),
    completed_at: Math.random() > 0.1 ? faker.date.recent() : null,
  };
}

function generateSecurityscan(): { project_id: string; scan_type: 'vulnerability' | 'compliance' | 'secrets' | 'dependencies'; status: 'pending' | 'running' | 'completed' | 'failed'; findings: { critical: number; high: number; medium: number; low: number }; summary: {  }; started_at: Date; completed_at: Date | null } {
  return {
    project_id: '',
    scan_type: faker.helpers.arrayElement(['vulnerability', 'compliance', 'secrets', 'dependencies']),
    status: faker.helpers.arrayElement(['pending', 'running', 'completed', 'failed']),
    findings: ({ critical: faker.number.float({ min: 0, max: 10, fractionDigits: 2 }), high: faker.number.float({ min: 0, max: 20, fractionDigits: 2 }), medium: faker.number.float({ min: 0, max: 30, fractionDigits: 2 }), low: faker.number.float({ min: 0, max: 50, fractionDigits: 2 }) }),
    summary: ({  }),
    started_at: faker.date.recent(),
    completed_at: Math.random() > 0.1 ? faker.date.recent() : null,
  };
}

function generateTeaminvitation(): { organization_id: string; email: string; invited_by: string; expires_at: Date; status: 'pending' | 'accepted' | 'expired' | 'revoked' } {
  return {
    organization_id: '',
    email: faker.internet.email(),
    invited_by: '',
    expires_at: faker.date.recent(),
    status: faker.helpers.arrayElement(['pending', 'accepted', 'expired', 'revoked']),
  };
}

function generateTeammember(): { organization_id: string; user_id: string; joined_at: Date; last_active_at: Date | null; invited_by: string | null } {
  return {
    organization_id: '',
    user_id: '',
    joined_at: faker.date.recent(),
    last_active_at: Math.random() > 0.1 ? faker.date.recent() : null,
    invited_by: null,
  };
}

/**
 * Seed the database with fake data.
 * 
 * Creates entities in dependency order to ensure valid foreign key references.
 * Uses the db layer directly, which naturally bypasses RLS.
 * 
 * @param counts - Optional count overrides per entity
 * 
 * @example
 * ```typescript
 * // Seed with defaults
 * await seed();
 * 
 * // Seed with custom counts
 * await seed({ user: 5, post: 20 });
 * ```
 */
export async function seed(counts: SeedCounts = {}): Promise<void> {
  const merged = { ...defaultCounts, ...counts };

  // Track created entity IDs for foreign key references
  const ids: Record<string, string[]> = {};

  ids.authUser = [];
  for (let i = 0; i < merged.authUser; i++) {
    const data = generateAuthuser();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.authUser.create(data as any);
    ids.authUser.push(created.id);
  }

  ids.authSession = [];
  for (let i = 0; i < merged.authSession; i++) {
    const data = generateAuthsession();
    data.user_id = pickRandom(ids.authUser)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.authSession.create(data as any);
    ids.authSession.push(created.id);
  }

  ids.profile = [];
  for (let i = 0; i < merged.profile; i++) {
    const data = generateProfile();

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.profile.create(data as any);
    ids.profile.push(created.id);
  }

  ids.organization = [];
  for (let i = 0; i < merged.organization; i++) {
    const data = generateOrganization();
    data.owner_id = pickRandom(ids.profile)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.organization.create(data as any);
    ids.organization.push(created.id);
  }

  ids.permission = [];
  for (let i = 0; i < merged.permission; i++) {
    const data = generatePermission();
    data.organization_id = Math.random() > 0.3 ? pickRandom(ids.organization) ?? null : null;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.permission.create(data as any);
    ids.permission.push(created.id);
  }

  ids.permissionTemplate = [];
  for (let i = 0; i < merged.permissionTemplate; i++) {
    const data = generatePermissiontemplate();
    data.organization_id = Math.random() > 0.3 ? pickRandom(ids.organization) ?? null : null;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.permissionTemplate.create(data as any);
    ids.permissionTemplate.push(created.id);
  }

  ids.project = [];
  for (let i = 0; i < merged.project; i++) {
    const data = generateProject();
    data.owner_id = pickRandom(ids.profile)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.project.create(data as any);
    ids.project.push(created.id);
  }

  ids.userPermissionMap = [];
  for (let i = 0; i < merged.userPermissionMap; i++) {
    const data = generateUserpermissionmap();
    data.user_id = pickRandom(ids.profile)!;
    data.organization_id = Math.random() > 0.3 ? pickRandom(ids.organization) ?? null : null;
    data.project_id = Math.random() > 0.3 ? pickRandom(ids.project) ?? null : null;
    data.granted_by = pickRandom(ids.profile)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.userPermissionMap.create(data as any);
    ids.userPermissionMap.push(created.id);
  }

  ids.environment = [];
  for (let i = 0; i < merged.environment; i++) {
    const data = generateEnvironment();
    data.project_id = pickRandom(ids.project)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.environment.create(data as any);
    ids.environment.push(created.id);
  }

  ids.deployment = [];
  for (let i = 0; i < merged.deployment; i++) {
    const data = generateDeployment();
    data.project_id = pickRandom(ids.project)!;
    data.environment_id = pickRandom(ids.environment)!;
    data.deployed_by = pickRandom(ids.profile)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.deployment.create(data as any);
    ids.deployment.push(created.id);
  }

  ids.securityScan = [];
  for (let i = 0; i < merged.securityScan; i++) {
    const data = generateSecurityscan();
    data.project_id = pickRandom(ids.project)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.securityScan.create(data as any);
    ids.securityScan.push(created.id);
  }

  ids.teamInvitation = [];
  for (let i = 0; i < merged.teamInvitation; i++) {
    const data = generateTeaminvitation();
    data.organization_id = pickRandom(ids.organization)!;
    data.invited_by = pickRandom(ids.profile)!;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.teamInvitation.create(data as any);
    ids.teamInvitation.push(created.id);
  }

  ids.teamMember = [];
  for (let i = 0; i < merged.teamMember; i++) {
    const data = generateTeammember();
    data.organization_id = pickRandom(ids.organization)!;
    data.user_id = pickRandom(ids.profile)!;
    data.invited_by = Math.random() > 0.3 ? pickRandom(ids.profile) ?? null : null;

    // Use db layer directly - bypasses RLS
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const created = db.teamMember.create(data as any);
    ids.teamMember.push(created.id);
  }

  console.log('\u2713 Database seeded');
}

/**
 * Reset the database by deleting all data.
 * 
 * Deletes entities in reverse dependency order to respect foreign key constraints.
 * 
 * @example
 * ```typescript
 * await reset();
 * ```
 */
export async function reset(): Promise<void> {
  const teamMemberList = db.teamMember.getAll();
  for (const item of teamMemberList) {
    db.teamMember.delete({ where: { id: { equals: item.id } } });
  }

  const teamInvitationList = db.teamInvitation.getAll();
  for (const item of teamInvitationList) {
    db.teamInvitation.delete({ where: { id: { equals: item.id } } });
  }

  const securityScanList = db.securityScan.getAll();
  for (const item of securityScanList) {
    db.securityScan.delete({ where: { id: { equals: item.id } } });
  }

  const deploymentList = db.deployment.getAll();
  for (const item of deploymentList) {
    db.deployment.delete({ where: { id: { equals: item.id } } });
  }

  const environmentList = db.environment.getAll();
  for (const item of environmentList) {
    db.environment.delete({ where: { id: { equals: item.id } } });
  }

  const userPermissionMapList = db.userPermissionMap.getAll();
  for (const item of userPermissionMapList) {
    db.userPermissionMap.delete({ where: { id: { equals: item.id } } });
  }

  const projectList = db.project.getAll();
  for (const item of projectList) {
    db.project.delete({ where: { id: { equals: item.id } } });
  }

  const permissionTemplateList = db.permissionTemplate.getAll();
  for (const item of permissionTemplateList) {
    db.permissionTemplate.delete({ where: { id: { equals: item.id } } });
  }

  const permissionList = db.permission.getAll();
  for (const item of permissionList) {
    db.permission.delete({ where: { id: { equals: item.id } } });
  }

  const organizationList = db.organization.getAll();
  for (const item of organizationList) {
    db.organization.delete({ where: { id: { equals: item.id } } });
  }

  const profileList = db.profile.getAll();
  for (const item of profileList) {
    db.profile.delete({ where: { id: { equals: item.id } } });
  }

  const authSessionList = db.authSession.getAll();
  for (const item of authSessionList) {
    db.authSession.delete({ where: { id: { equals: item.id } } });
  }

  const authUserList = db.authUser.getAll();
  for (const item of authUserList) {
    db.authUser.delete({ where: { id: { equals: item.id } } });
  }

  console.log('\u2713 Database reset');
}

/**
 * Get all data from the database.
 * 
 * Useful for debugging and testing.
 * 
 * @returns Record of entity name to array of items
 * 
 * @example
 * ```typescript
 * const data = await getAll();
 * console.log(data.user); // All users
 * ```
 */
export async function getAll(): Promise<Record<string, unknown[]>> {
  return {
    authUser: db.authUser.getAll(),
    authSession: db.authSession.getAll(),
    profile: db.profile.getAll(),
    organization: db.organization.getAll(),
    permission: db.permission.getAll(),
    permissionTemplate: db.permissionTemplate.getAll(),
    project: db.project.getAll(),
    userPermissionMap: db.userPermissionMap.getAll(),
    environment: db.environment.getAll(),
    deployment: db.deployment.getAll(),
    securityScan: db.securityScan.getAll(),
    teamInvitation: db.teamInvitation.getAll(),
    teamMember: db.teamMember.getAll(),
  };
}

/**
 * Get the count of each entity in the database.
 * 
 * @returns Record of entity name to count
 * 
 * @example
 * ```typescript
 * const counts = await count();
 * console.log(counts.user); // Number of users
 * ```
 */
export async function count(): Promise<Record<string, number>> {
  return {
    authUser: db.authUser.getAll().length,
    authSession: db.authSession.getAll().length,
    profile: db.profile.getAll().length,
    organization: db.organization.getAll().length,
    permission: db.permission.getAll().length,
    permissionTemplate: db.permissionTemplate.getAll().length,
    project: db.project.getAll().length,
    userPermissionMap: db.userPermissionMap.getAll().length,
    environment: db.environment.getAll().length,
    deployment: db.deployment.getAll().length,
    securityScan: db.securityScan.getAll().length,
    teamInvitation: db.teamInvitation.getAll().length,
    teamMember: db.teamMember.getAll().length,
  };
}

// ======================================================================
// Production Seed Utilities
// ======================================================================

// Import production seed configuration
// Create a seed-data.ts file in your project root with:
// export const seedConfig = { secret: "your-secret", data: { users: [...], products: [...] } };

/**
 * Result of a production seed operation.
 */
export interface SeedResult {
  success: boolean;
  error?: 'INVALID_SECRET' | 'ALREADY_SEEDED';
  seededAt?: Date;
}

/**
 * Configuration for production seed data.
 * 
 * Define this in your seed-data.ts file:
 * ```typescript
 * export const seedConfig = {
 *   secret: 'my-production-secret-123',
 *   data: {
 *     users: [{ id: 'admin-uuid', name: 'Super Admin', email: 'admin@example.com' }],
 *     products: [{ id: 'prod-1', name: 'Default Product', price: 9.99 }],
 *   },
 * };
 * ```
 */
export interface ProductionSeedData {
  secret: string;
  data: Record<string, Record<string, unknown>[]>;
}

// localStorage key for kill switch
const SEED_STORAGE_KEY = '_schemock_seeded';

/**
 * Check if production data has already been seeded.
 * 
 * @returns true if production seed has already run
 * 
 * @example
 * ```typescript
 * if (!isSeeded()) {
 *   await runProductionSeed('my-secret');
 * }
 * ```
 */
export function isSeeded(): boolean {
  if (typeof localStorage === 'undefined') return false;
  return localStorage.getItem(SEED_STORAGE_KEY) !== null;
}

/**
 * Reset the production seed kill switch.
 * 
 * Call this if you need to re-seed production data.
 * 
 * @example
 * ```typescript
 * resetProductionSeed();
 * await runProductionSeed('my-secret');
 * ```
 */
export function resetProductionSeed(): void {
  if (typeof localStorage === 'undefined') return;
  localStorage.removeItem(SEED_STORAGE_KEY);
}

/**
 * Get the timestamp when production data was seeded.
 * 
 * @returns Date when seeded, or null if not seeded
 */
export function getSeededAt(): Date | null {
  if (typeof localStorage === 'undefined') return null;
  const timestamp = localStorage.getItem(SEED_STORAGE_KEY);
  if (!timestamp) return null;
  return new Date(parseInt(timestamp, 10));
}

// Seed reference resolution helpers
const SEED_REF_BRAND = '__schemock_seed_ref__';

function isSeedReference(value: unknown): boolean {
  return (
    typeof value === 'object' &&
    value !== null &&
    SEED_REF_BRAND in value &&
    (value as Record<string, unknown>)[SEED_REF_BRAND] === true
  );
}

function resolveRef(marker: Record<string, unknown>, createdRecords: Map<string, Record<string, unknown>[]>): unknown {
  const entity = marker.entity as string;
  const field = marker.field as string;
  const records = createdRecords.get(entity);

  if (marker.type === 'ref') {
    const index = marker.index as number;
    if (!records || records.length <= index) {
      throw new Error(`Seed ref error: entity '${entity}' has ${records?.length ?? 0} records, but ref() requested index ${index}`);
    }
    return records[index][field];
  }

  if (marker.type === 'lookup') {
    const where = marker.where as Record<string, unknown>;
    if (!records) {
      throw new Error(`Seed lookup error: entity '${entity}' has no records yet. Ensure it is seeded before entities that reference it.`);
    }
    const match = records.find((r) => {
      return Object.entries(where).every(([k, v]) => r[k] === v);
    });
    if (!match) {
      throw new Error(`Seed lookup error: no '${entity}' record matches ${JSON.stringify(where)}`);
    }
    return match[field];
  }

  throw new Error(`Unknown seed reference type: ${String(marker.type)}`);
}

function resolveItem(item: Record<string, unknown>, createdRecords: Map<string, Record<string, unknown>[]>, entityName: string): Record<string, unknown> {
  const resolved: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(item)) {
    if (isSeedReference(value)) {
      resolved[key] = resolveRef(value as Record<string, unknown>, createdRecords);
    } else {
      resolved[key] = value;
    }
  }
  return resolved;
}

// Entity insertion order (topologically sorted by dependencies)
const entityOrder: string[] = ['authUser', 'authSession', 'profile', 'organization', 'permission', 'permissionTemplate', 'project', 'userPermissionMap', 'environment', 'deployment', 'securityScan', 'teamInvitation', 'teamMember'];

/**
 * Run the production seed with secret validation and kill switch.
 * 
 * This function:
 * 1. Validates the provided secret against seedConfig.secret
 * 2. Checks if data has already been seeded (kill switch)
 * 3. Inserts the seed data into the database
 * 4. Sets the kill switch to prevent re-seeding
 * 
 * @param secretKey - The secret key to validate against seedConfig.secret
 * @param seedConfig - The seed configuration with secret and data
 * @returns SeedResult indicating success or failure
 * 
 * @example
 * ```typescript
 * // First, import your seed config
 * import { seedConfig } from './seed-data';
 * 
 * // Run the seed
 * const result = await runProductionSeed('my-secret', seedConfig);
 * 
 * if (result.success) {
 *   console.log("Seeded at:", result.seededAt);
 * } else if (result.error === "ALREADY_SEEDED") {
 *   console.log("Already seeded at:", result.seededAt);
 * } else if (result.error === "INVALID_SECRET") {
 *   console.error("Invalid secret key");
 * }
 * ```
 */
export async function runProductionSeed(
  secretKey: string,
  seedConfig: ProductionSeedData
): Promise<SeedResult> {
  // 1. Validate secret
  if (secretKey !== seedConfig.secret) {
    return { success: false, error: 'INVALID_SECRET' };
  }

  // 2. Check kill switch
  if (isSeeded()) {
    return {
      success: false,
      error: 'ALREADY_SEEDED',
      seededAt: getSeededAt() ?? undefined,
    };
  }

  // 3. Insert data for each entity (ordered by dependencies)
  const createdRecords = new Map<string, Record<string, unknown>[]>();

  // Determine insertion order: entityOrder first, then any remaining keys
  const orderedEntities = [
    ...entityOrder.filter((e) => e in seedConfig.data),
    ...Object.keys(seedConfig.data).filter((e) => !entityOrder.includes(e)),
  ];

  for (const entity of orderedEntities) {
    const items = seedConfig.data[entity];
    // Get the db method for this entity
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const entityDb = (db as any)[entity];
    if (!entityDb) {
      console.warn(`Unknown entity in seed data: ${entity}`);
      continue;
    }

    const entityRecords: Record<string, unknown>[] = [];
    for (const item of items) {
      try {
        const resolved = resolveItem(item, createdRecords, entity);
        const created = entityDb.create(resolved);
        entityRecords.push(created);
      } catch (e) {
        // Ignore duplicate key errors, log others
        const error = e as Error;
        if (!error.message?.includes('duplicate')) {
          console.warn(`Failed to seed ${entity}:`, error.message);
        }
      }
    }
    createdRecords.set(entity, entityRecords);
  }

  // 4. Set kill switch
  const seededAt = new Date();
  if (typeof localStorage !== 'undefined') {
    localStorage.setItem(SEED_STORAGE_KEY, seededAt.getTime().toString());
  }

  console.log('\u2713 Production data seeded');
  return { success: true, seededAt };
}