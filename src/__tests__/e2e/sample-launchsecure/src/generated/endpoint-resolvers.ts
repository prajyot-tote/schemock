// GENERATED BY SCHEMOCK - DO NOT EDIT
// Mock resolvers for custom endpoints
// 
// These resolvers are copied from your defineEndpoint() calls.
// They receive { params, body, db, headers } and return the response.
// 
// NOTE: If your inline resolvers use external functions (e.g., hashPassword, generateToken),
// consider using named exported functions instead - they will be automatically imported.

import type * as Types from './types';

// Base resolver context with typed database access
export interface ResolverContext<TParams = Record<string, unknown>, TBody = Record<string, unknown>> {
  params: TParams;
  body: TBody;
  db: any;
  headers: Record<string, string>;
  /** Context populated by middleware (e.g., auth middleware adds userId, role) */
  context?: Record<string, unknown>;
}

// Per-endpoint typed resolver contexts
export type AuthhubUsersResolverContext = ResolverContext<Types.AuthhubUsersParams, Record<string, never>>;
export type AuthUserPermissionsResolverContext = ResolverContext<Record<string, never>, Record<string, never>>;
export type AuthInviteUserResolverContext = ResolverContext<Types.AuthInviteUserParams, Record<string, never>>;

// Error class for HTTP errors in resolvers
export class HttpError extends Error {
  readonly status: number;
  readonly code?: string;

  constructor(message: string, status: number, code?: string) {
    super(message);
    this.name = "HttpError";
    this.status = status;
    this.code = code;
  }
}


// Local helper functions (copied from source files)
function isSuperAdmin(db: any, userId: string): boolean {
  const maps = db.userPermissionMap.findMany({
    where: { user_id: { equals: userId } },
  });
  let isSuper = false;
  maps.forEach((map: any) => {
    if (map.permissions.includes('*')) isSuper = true;
    if (map.permissions.includes('admin:access:all')) isSuper = true;
  });
  return isSuper;
}

function getUserOrgIds(db: any, userId: string): string[] {
  const memberships = db.teamMember.findMany({
    where: { user_id: { equals: userId } },
  });
  return memberships.map((m: any) => m.organization_id);
}


// Typed resolver function types
type AuthhubUsersResolverFn = (ctx: AuthhubUsersResolverContext) => Types.AuthhubUsersResponse | Promise<Types.AuthhubUsersResponse>;
type AuthUserPermissionsResolverFn = (ctx: AuthUserPermissionsResolverContext) => Types.AuthUserPermissionsResponse | Promise<Types.AuthUserPermissionsResponse>;
type AuthInviteUserResolverFn = (ctx: AuthInviteUserResolverContext) => Types.AuthInviteUserResponse | Promise<Types.AuthInviteUserResponse>;

// Typed endpoint resolvers interface
export interface EndpointResolvers {
  authhubUsers: AuthhubUsersResolverFn;
  authUserPermissions: AuthUserPermissionsResolverFn;
  authInviteUser: AuthInviteUserResolverFn;
}

export const endpointResolvers: EndpointResolvers = {
  // GET /api/authhub/users
  // List users for AuthHub wizard (filtered by access)
  authhubUsers: async ({ params, db, context }: AuthhubUsersResolverContext) => {
    const callerId = context?.userId as string;
    if (!callerId) {
      throw new Error('Unauthorized: no userId in context');
    }

    const superAdmin = isSuperAdmin(db, callerId);

    let profiles: any[];

    if (superAdmin) {
      profiles = db.profile.getAll();
    } else {
      const callerOrgIds = getUserOrgIds(db, callerId);
      if (callerOrgIds.length === 0) {
        return { users: [], total: 0 };
      }

      const memberships = db.teamMember.findMany({
        where: { organization_id: { in: callerOrgIds } },
      });
      const userIds = [...new Set(memberships.map((m: any) => m.user_id))];

      profiles = db.profile.findMany({
        where: { id: { in: userIds } },
      });
    }

    if (params.search) {
      const searchLower = params.search.toLowerCase();
      profiles = profiles.filter((p: any) =>
        p.email?.toLowerCase().includes(searchLower) ||
        p.full_name?.toLowerCase().includes(searchLower)
      );
    }

    const total = profiles.length;
    const paginatedProfiles = profiles.slice(params.offset ?? 0, (params.offset ?? 0) + (params.limit ?? 50));

    return {
      users: paginatedProfiles.map((p: any) => ({
        id: p.id,
        email: p.email,
        full_name: p.full_name,
        avatar_url: p.avatar_url,
      })),
      total,
    };
  },

  // GET /api/auth/user-permissions
  // Returns a permission JWT for the authenticated user
  authUserPermissions: async ({ db, context }: AuthUserPermissionsResolverContext) => {
    const userId = context?.userId as string;
    if (!userId) {
      throw new Error('Unauthorized: no userId in context');
    }

    const maps = db.userPermissionMap.findMany({
      where: { user_id: { equals: userId } },
    });

    const keys = new Set<string>();
    for (const map of maps) {
      for (const key of map.permissions) {
        keys.add(key);
      }
    }

    const permissions = [...keys];

    const encode = (obj: object): string => {
      const json = JSON.stringify(obj);
      if (typeof btoa === 'function') {
        return btoa(json).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      }
      return Buffer.from(json).toString('base64url');
    };

    const now = Math.floor(Date.now() / 1000);
    const token = `${encode({ alg: 'none', typ: 'JWT' })}.${encode({
      sub: userId,
      permissions,
      iat: now,
      exp: now + 24 * 60 * 60,
    })}.`;

    return { token };
  },

  // POST /api/auth/invite-user
  // Invites a user to an organization with specified permissions
  authInviteUser: async ({ params, db, context }: AuthInviteUserResolverContext) => {
    const granterId = context?.userId as string;
    if (!granterId) {
      throw new Error('Unauthorized: no userId in context');
    }

    let profile = db.profile.findFirst({
      where: { email: { equals: params.email } },
    });

    const isNewUser = !profile;

    if (!profile) {
      profile = db.profile.create({
        email: params.email,
        full_name: params.full_name || params.email.split('@')[0],
        avatar_url: null,
      });
    }

    let teamMember = db.teamMember.findFirst({
      where: {
        user_id: { equals: profile.id },
        organization_id: { equals: params.organization_id },
      },
    });

    if (!teamMember) {
      teamMember = db.teamMember.create({
        organization_id: params.organization_id,
        user_id: profile.id,
        joined_at: new Date(),
        invited_by: granterId,
      });
    }

    const permissionMap = db.userPermissionMap.create({
      user_id: profile.id,
      organization_id: params.organization_id,
      project_id: null,
      permissions: params.permissions,
      granted_by: granterId,
      granted_at: new Date(),
      reason: params.reason || null,
    });

    return {
      profile_id: profile.id,
      team_member_id: teamMember.id,
      permission_map_id: permissionMap.id,
      success: true,
      is_new_user: isNewUser,
    };
  },

};