// GENERATED BY SCHEMOCK - DO NOT EDIT
import { db } from './db';
import type * as Types from './types';

// =============================================================================
// RLS Context & Client Configuration
// 
// Production-ready interceptor pattern for centralized auth and error handling.
// Configure once at app startup, auth headers are added to every request.
// =============================================================================

// RLS Context - internal type for mock RLS simulation (not exported)
interface RLSContext {
  [key: string]: unknown;
}

// Request context passed to onRequest interceptor
export interface RequestContext {
  headers: Record<string, string>;
  operation: string;  // e.g., "post.list", "user.create"
}

// API Error with HTTP-like status codes
export class ApiError extends Error {
  readonly status: number;
  readonly code: string;
  readonly operation: string;

  constructor(message: string, status: number, code: string, operation: string) {
    super(message);
    this.name = "ApiError";
    this.status = status;
    this.code = code;
    this.operation = operation;
  }
}

/**
 * Client configuration for interceptors.
 * 
 * @example
 * ```typescript
 * const api = createClient({
 *   onRequest: (ctx) => {
 *     const token = localStorage.getItem("token");
 *     if (token) {
 *       ctx.headers.Authorization = `Bearer ${token}`;
 *     }
 *     return ctx;
 *   },
 *   onError: (error) => {
 *     if (error.status === 401) {
 *       window.location.href = "/login";
 *     }
 *   }
 * });
 * ```
 */
export interface ClientConfig {
  /**
   * Called before each API operation.
   * Use this to add auth headers, logging, etc.
   */
  onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;

  /**
   * Called when an error occurs.
   * Use this for centralized error handling (401 redirect, toast notifications, etc.)
   */
  onError?: (error: ApiError) => void | Promise<void>;
}

// Decode JWT payload without validation (mock mode trusts the token)
function decodeJwtPayload(token: string): RLSContext | null {
  try {
    const parts = token.split(".");
    if (parts.length !== 3) return null;

    const payload = parts[1].replace(/-/g, "+").replace(/_/g, "/");
    const decoded = typeof atob === "function"
      ? atob(payload)
      : Buffer.from(payload, "base64").toString("utf-8");

    return JSON.parse(decoded);
  } catch {
    return null;
  }
}

// Extract RLS context from request headers
function extractContextFromHeaders(headers: Record<string, string>): RLSContext | null {
  const authHeader = headers["Authorization"] || headers["authorization"];
  if (!authHeader) return null;

  const token = authHeader.startsWith("Bearer ")
    ? authHeader.slice(7)
    : authHeader;

  return token ? decodeJwtPayload(token) : null;
}

// Helper to create not found error
function createNotFoundError(entity: string, id: string): ApiError {
  return new ApiError(
    `${entity} not found: ${id}`,
    404,
    "NOT_FOUND",
    `${entity}.get`
  );
}

function applyFilter<T>(items: T[], filter: Record<string, unknown>): T[] {
  return items.filter(item => {
    for (const [key, value] of Object.entries(filter)) {
      const itemValue = (item as Record<string, unknown>)[key];
      if (typeof value === "object" && value !== null) {
        const f = value as Record<string, unknown>;
        if ('equals' in f && itemValue !== f.equals) return false;
        if ('not' in f && itemValue === f.not) return false;
        if ('in' in f && !(f.in as unknown[]).includes(itemValue)) return false;
        if ('notIn' in f && (f.notIn as unknown[]).includes(itemValue)) return false;
        if ('contains' in f && !String(itemValue).includes(f.contains as string)) return false;
        if ('startsWith' in f && !String(itemValue).startsWith(f.startsWith as string)) return false;
        if ('endsWith' in f && !String(itemValue).endsWith(f.endsWith as string)) return false;
        if ('gt' in f && (itemValue as number) <= (f.gt as number)) return false;
        if ('lt' in f && (itemValue as number) >= (f.lt as number)) return false;
        if ('gte' in f && (itemValue as number) < (f.gte as number)) return false;
        if ('lte' in f && (itemValue as number) > (f.lte as number)) return false;
        if ('isNull' in f && f.isNull && itemValue !== null && itemValue !== undefined) return false;
        if ('isNull' in f && !f.isNull && (itemValue === null || itemValue === undefined)) return false;
      } else {
        if (itemValue !== value) return false;
      }
    }
    return true;
  });
}

// Parse JSONB fields stored as strings by @mswjs/data
function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {
  const result = { ...row };
  for (const field of jsonFields) {
    if (result[field] && typeof result[field] === "string") {
      try {
        result[field] = JSON.parse(result[field] as string);
      } catch { /* keep as string */ }
    }
  }
  return result as T;
}

// API client type
export interface ApiClient {
  authUser: {
    list: (options?: Types.QueryOptions<Types.AuthuserFilter, Types.AuthuserInclude>) => Promise<Types.ListResponse<Types.Authuser>>;
    get: (id: string, options?: { include?: Types.AuthuserInclude[] }) => Promise<Types.ItemResponse<Types.Authuser>>;
    create: (input: Types.AuthuserCreate) => Promise<Types.ItemResponse<Types.Authuser>>;
    update: (id: string, input: Types.AuthuserUpdate) => Promise<Types.ItemResponse<Types.Authuser>>;
    delete: (id: string) => Promise<void>;
  };
  authSession: {
    list: (options?: Types.QueryOptions<Types.AuthsessionFilter, Types.AuthsessionInclude>) => Promise<Types.ListResponse<Types.Authsession>>;
    get: (id: string, options?: { include?: Types.AuthsessionInclude[] }) => Promise<Types.ItemResponse<Types.Authsession>>;
    create: (input: Types.AuthsessionCreate) => Promise<Types.ItemResponse<Types.Authsession>>;
    update: (id: string, input: Types.AuthsessionUpdate) => Promise<Types.ItemResponse<Types.Authsession>>;
    delete: (id: string) => Promise<void>;
  };
  profile: {
    list: (options?: Types.QueryOptions<Types.ProfileFilter, Types.ProfileInclude>) => Promise<Types.ListResponse<Types.Profile>>;
    get: (id: string, options?: { include?: Types.ProfileInclude[] }) => Promise<Types.ItemResponse<Types.Profile>>;
    create: (input: Types.ProfileCreate) => Promise<Types.ItemResponse<Types.Profile>>;
    update: (id: string, input: Types.ProfileUpdate) => Promise<Types.ItemResponse<Types.Profile>>;
    delete: (id: string) => Promise<void>;
  };
  organization: {
    list: (options?: Types.QueryOptions<Types.OrganizationFilter, Types.OrganizationInclude>) => Promise<Types.ListResponse<Types.Organization>>;
    get: (id: string, options?: { include?: Types.OrganizationInclude[] }) => Promise<Types.ItemResponse<Types.Organization>>;
    create: (input: Types.OrganizationCreate) => Promise<Types.ItemResponse<Types.Organization>>;
    update: (id: string, input: Types.OrganizationUpdate) => Promise<Types.ItemResponse<Types.Organization>>;
    delete: (id: string) => Promise<void>;
  };
  permission: {
    list: (options?: Types.QueryOptions<Types.PermissionFilter, Types.PermissionInclude>) => Promise<Types.ListResponse<Types.Permission>>;
    get: (id: string, options?: { include?: Types.PermissionInclude[] }) => Promise<Types.ItemResponse<Types.Permission>>;
    create: (input: Types.PermissionCreate) => Promise<Types.ItemResponse<Types.Permission>>;
    update: (id: string, input: Types.PermissionUpdate) => Promise<Types.ItemResponse<Types.Permission>>;
    delete: (id: string) => Promise<void>;
  };
  permissionTemplate: {
    list: (options?: Types.QueryOptions<Types.PermissiontemplateFilter, Types.PermissiontemplateInclude>) => Promise<Types.ListResponse<Types.Permissiontemplate>>;
    get: (id: string, options?: { include?: Types.PermissiontemplateInclude[] }) => Promise<Types.ItemResponse<Types.Permissiontemplate>>;
    create: (input: Types.PermissiontemplateCreate) => Promise<Types.ItemResponse<Types.Permissiontemplate>>;
    update: (id: string, input: Types.PermissiontemplateUpdate) => Promise<Types.ItemResponse<Types.Permissiontemplate>>;
    delete: (id: string) => Promise<void>;
  };
  project: {
    list: (options?: Types.QueryOptions<Types.ProjectFilter, Types.ProjectInclude>) => Promise<Types.ListResponse<Types.Project>>;
    get: (id: string, options?: { include?: Types.ProjectInclude[] }) => Promise<Types.ItemResponse<Types.Project>>;
    create: (input: Types.ProjectCreate) => Promise<Types.ItemResponse<Types.Project>>;
    update: (id: string, input: Types.ProjectUpdate) => Promise<Types.ItemResponse<Types.Project>>;
    delete: (id: string) => Promise<void>;
  };
  userPermissionMap: {
    list: (options?: Types.QueryOptions<Types.UserpermissionmapFilter, Types.UserpermissionmapInclude>) => Promise<Types.ListResponse<Types.Userpermissionmap>>;
    get: (id: string, options?: { include?: Types.UserpermissionmapInclude[] }) => Promise<Types.ItemResponse<Types.Userpermissionmap>>;
    create: (input: Types.UserpermissionmapCreate) => Promise<Types.ItemResponse<Types.Userpermissionmap>>;
    update: (id: string, input: Types.UserpermissionmapUpdate) => Promise<Types.ItemResponse<Types.Userpermissionmap>>;
    delete: (id: string) => Promise<void>;
  };
  environment: {
    list: (options?: Types.QueryOptions<Types.EnvironmentFilter, Types.EnvironmentInclude>) => Promise<Types.ListResponse<Types.Environment>>;
    get: (id: string, options?: { include?: Types.EnvironmentInclude[] }) => Promise<Types.ItemResponse<Types.Environment>>;
    create: (input: Types.EnvironmentCreate) => Promise<Types.ItemResponse<Types.Environment>>;
    update: (id: string, input: Types.EnvironmentUpdate) => Promise<Types.ItemResponse<Types.Environment>>;
    delete: (id: string) => Promise<void>;
  };
  deployment: {
    list: (options?: Types.QueryOptions<Types.DeploymentFilter, Types.DeploymentInclude>) => Promise<Types.ListResponse<Types.Deployment>>;
    get: (id: string, options?: { include?: Types.DeploymentInclude[] }) => Promise<Types.ItemResponse<Types.Deployment>>;
    create: (input: Types.DeploymentCreate) => Promise<Types.ItemResponse<Types.Deployment>>;
    update: (id: string, input: Types.DeploymentUpdate) => Promise<Types.ItemResponse<Types.Deployment>>;
    delete: (id: string) => Promise<void>;
  };
  securityScan: {
    list: (options?: Types.QueryOptions<Types.SecurityscanFilter, Types.SecurityscanInclude>) => Promise<Types.ListResponse<Types.Securityscan>>;
    get: (id: string, options?: { include?: Types.SecurityscanInclude[] }) => Promise<Types.ItemResponse<Types.Securityscan>>;
    create: (input: Types.SecurityscanCreate) => Promise<Types.ItemResponse<Types.Securityscan>>;
    update: (id: string, input: Types.SecurityscanUpdate) => Promise<Types.ItemResponse<Types.Securityscan>>;
    delete: (id: string) => Promise<void>;
  };
  teamInvitation: {
    list: (options?: Types.QueryOptions<Types.TeaminvitationFilter, Types.TeaminvitationInclude>) => Promise<Types.ListResponse<Types.Teaminvitation>>;
    get: (id: string, options?: { include?: Types.TeaminvitationInclude[] }) => Promise<Types.ItemResponse<Types.Teaminvitation>>;
    create: (input: Types.TeaminvitationCreate) => Promise<Types.ItemResponse<Types.Teaminvitation>>;
    update: (id: string, input: Types.TeaminvitationUpdate) => Promise<Types.ItemResponse<Types.Teaminvitation>>;
    delete: (id: string) => Promise<void>;
  };
  teamMember: {
    list: (options?: Types.QueryOptions<Types.TeammemberFilter, Types.TeammemberInclude>) => Promise<Types.ListResponse<Types.Teammember>>;
    get: (id: string, options?: { include?: Types.TeammemberInclude[] }) => Promise<Types.ItemResponse<Types.Teammember>>;
    create: (input: Types.TeammemberCreate) => Promise<Types.ItemResponse<Types.Teammember>>;
    update: (id: string, input: Types.TeammemberUpdate) => Promise<Types.ItemResponse<Types.Teammember>>;
    delete: (id: string) => Promise<void>;
  };
}

/**
 * Create a configured API client with interceptors.
 * 
 * Use this for production code to centralize auth and error handling.
 * 
 * @param config - Client configuration with interceptors
 * @returns Configured API client
 * 
 * @example
 * ```typescript
 * import { createClient } from './generated/client';
 * import { createMockJwt } from 'schemock/middleware';
 * 
 * const api = createClient({
 *   // Add auth headers to every request
 *   onRequest: (ctx) => {
 *     const token = localStorage.getItem("authToken");
 *     if (token) {
 *       ctx.headers.Authorization = `Bearer ${token}`;
 *     }
 *     return ctx;
 *   },
 * 
 *   // Centralized error handling
 *   onError: (error) => {
 *     if (error.status === 401) {
 *       // Token expired - redirect to login
 *       window.location.href = "/login";
 *     }
 *     if (error.status === 403) {
 *       // Access denied - show notification
 *       toast.error("Access denied");
 *     }
 *   }
 * });
 * 
 * // Now use the API - auth is automatic
 * const posts = await api.post.list();
 * ```
 */
export function createClient(config?: ClientConfig): ApiClient {
  const interceptors = config ?? {};

  // Internal helper to run request through interceptors
  async function executeRequest<T>(
    operation: string,
    fn: (ctx: RLSContext | null) => T | Promise<T>
  ): Promise<T> {
    // Build request context
    let requestCtx: RequestContext = { headers: {}, operation };

    // Run onRequest interceptor (user adds auth headers here)
    if (interceptors.onRequest) {
      requestCtx = await interceptors.onRequest(requestCtx);
    }

    // Extract RLS context from headers
    const rlsCtx = extractContextFromHeaders(requestCtx.headers);

    try {
      return await fn(rlsCtx);
    } catch (err) {
      // Enhance error if not already ApiError
      const error = err instanceof ApiError ? err : new ApiError(
        err instanceof Error ? err.message : String(err),
        500,
        "INTERNAL_ERROR",
        operation
      );

      // Run onError interceptor
      if (interceptors.onError) {
        await interceptors.onError(error);
      }

      throw error;
    }
  }

  // Build API client with all entity methods
  return {
    authUser: {
      list: (options?: Types.QueryOptions<Types.AuthuserFilter, Types.AuthuserInclude>) =>
        executeRequest('authUser.list', (ctx) => {
          let items = db.authUser.getAll() as unknown as Types.Authuser[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('sessions')) {
                result.sessions = db.authSession.findMany({
                  where: { user_id: { equals: item.id } }
                });
              }
              return result as Types.Authuser;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.AuthuserInclude[] }) =>
        executeRequest('authUser.get', (ctx) => {
          const rawItem = db.authUser.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Authuser', id);
          const item = rawItem as Types.Authuser;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('sessions')) {
              result.sessions = db.authSession.findMany({
                where: { user_id: { equals: item.id } }
              });
            }
          }

          return { data: result as Types.Authuser };
        }),

      create: (input: Types.AuthuserCreate) =>
        executeRequest('authUser.create', (ctx) => {
          const { sessions, ...data } = input;

          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.authUser.create(data as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Authuser;

          if (sessions) {
            for (const nested of sessions) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.authSession.create({ ...nested, user_id: item.id } as any);
            }
          }

          return { data: item };
        }),

      update: (id: string, input: Types.AuthuserUpdate) =>
        executeRequest('authUser.update', (ctx) => {
          const rawItem = db.authUser.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Authuser', id);
          return { data: rawItem as Types.Authuser };
        }),

      delete: (id: string) =>
        executeRequest('authUser.delete', (ctx) => {
          const item = db.authUser.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Authuser', id);
        }),
    },

    authSession: {
      list: (options?: Types.QueryOptions<Types.AuthsessionFilter, Types.AuthsessionInclude>) =>
        executeRequest('authSession.list', (ctx) => {
          let items = db.authSession.getAll() as unknown as Types.Authsession[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('user')) {
                result.user = db.authUser.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).user_id as string } }
                });
              }
              return result as Types.Authsession;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.AuthsessionInclude[] }) =>
        executeRequest('authSession.get', (ctx) => {
          const rawItem = db.authSession.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Authsession', id);
          const item = rawItem as Types.Authsession;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('user')) {
              result.user = db.authUser.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).user_id as string } }
              });
            }
          }

          return { data: result as Types.Authsession };
        }),

      create: (input: Types.AuthsessionCreate) =>
        executeRequest('authSession.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.authSession.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Authsession;

          return { data: item };
        }),

      update: (id: string, input: Types.AuthsessionUpdate) =>
        executeRequest('authSession.update', (ctx) => {
          const rawItem = db.authSession.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Authsession', id);
          return { data: rawItem as Types.Authsession };
        }),

      delete: (id: string) =>
        executeRequest('authSession.delete', (ctx) => {
          const item = db.authSession.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Authsession', id);
        }),
    },

    profile: {
      list: (options?: Types.QueryOptions<Types.ProfileFilter, Types.ProfileInclude>) =>
        executeRequest('profile.list', (ctx) => {
          let items = db.profile.getAll() as unknown as Types.Profile[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('projects')) {
                result.projects = db.project.findMany({
                  where: { owner_id: { equals: item.id } }
                });
              }
              if (options.include!.includes('permissionMaps')) {
                result.permissionMaps = db.userPermissionMap.findMany({
                  where: { user_id: { equals: item.id } }
                });
              }
              if (options.include!.includes('teamMemberships')) {
                result.teamMemberships = db.teamMember.findMany({
                  where: { user_id: { equals: item.id } }
                });
              }
              return result as Types.Profile;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.ProfileInclude[] }) =>
        executeRequest('profile.get', (ctx) => {
          const rawItem = db.profile.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Profile', id);
          const item = rawItem as Types.Profile;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('projects')) {
              result.projects = db.project.findMany({
                where: { owner_id: { equals: item.id } }
              });
            }
            if (options.include.includes('permissionMaps')) {
              result.permissionMaps = db.userPermissionMap.findMany({
                where: { user_id: { equals: item.id } }
              });
            }
            if (options.include.includes('teamMemberships')) {
              result.teamMemberships = db.teamMember.findMany({
                where: { user_id: { equals: item.id } }
              });
            }
          }

          return { data: result as Types.Profile };
        }),

      create: (input: Types.ProfileCreate) =>
        executeRequest('profile.create', (ctx) => {
          const { projects, permissionMaps, teamMemberships, ...data } = input;

          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.profile.create(data as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Profile;

          if (projects) {
            for (const nested of projects) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.project.create({ ...nested, owner_id: item.id } as any);
            }
          }
          if (permissionMaps) {
            for (const nested of permissionMaps) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.userPermissionMap.create({ ...nested, user_id: item.id } as any);
            }
          }
          if (teamMemberships) {
            for (const nested of teamMemberships) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.teamMember.create({ ...nested, user_id: item.id } as any);
            }
          }

          return { data: item };
        }),

      update: (id: string, input: Types.ProfileUpdate) =>
        executeRequest('profile.update', (ctx) => {
          const rawItem = db.profile.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Profile', id);
          return { data: rawItem as Types.Profile };
        }),

      delete: (id: string) =>
        executeRequest('profile.delete', (ctx) => {
          const item = db.profile.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Profile', id);
        }),
    },

    organization: {
      list: (options?: Types.QueryOptions<Types.OrganizationFilter, Types.OrganizationInclude>) =>
        executeRequest('organization.list', (ctx) => {
          let rawItems = db.organization.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.Organization>(row, ['settings']));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('owner')) {
                result.owner = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).owner_id as string } }
                });
              }
              if (options.include!.includes('members')) {
                result.members = db.teamMember.findMany({
                  where: { organization_id: { equals: item.id } }
                });
              }
              if (options.include!.includes('invitations')) {
                result.invitations = db.teamInvitation.findMany({
                  where: { organization_id: { equals: item.id } }
                });
              }
              if (options.include!.includes('permissionMaps')) {
                result.permissionMaps = db.userPermissionMap.findMany({
                  where: { organization_id: { equals: item.id } }
                });
              }
              return result as Types.Organization;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.OrganizationInclude[] }) =>
        executeRequest('organization.get', (ctx) => {
          const rawItem = db.organization.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Organization', id);
          const item = parseRow<Types.Organization>(rawItem, ['settings']);

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('owner')) {
              result.owner = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).owner_id as string } }
              });
            }
            if (options.include.includes('members')) {
              result.members = db.teamMember.findMany({
                where: { organization_id: { equals: item.id } }
              });
            }
            if (options.include.includes('invitations')) {
              result.invitations = db.teamInvitation.findMany({
                where: { organization_id: { equals: item.id } }
              });
            }
            if (options.include.includes('permissionMaps')) {
              result.permissionMaps = db.userPermissionMap.findMany({
                where: { organization_id: { equals: item.id } }
              });
            }
          }

          return { data: result as Types.Organization };
        }),

      create: (input: Types.OrganizationCreate) =>
        executeRequest('organization.create', (ctx) => {
          const { members, invitations, permissionMaps, ...data } = input;

          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.organization.create(data as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.Organization>(rawItem, ['settings']);

          if (members) {
            for (const nested of members) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.teamMember.create({ ...nested, organization_id: item.id } as any);
            }
          }
          if (invitations) {
            for (const nested of invitations) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.teamInvitation.create({ ...nested, organization_id: item.id } as any);
            }
          }
          if (permissionMaps) {
            for (const nested of permissionMaps) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.userPermissionMap.create({ ...nested, organization_id: item.id } as any);
            }
          }

          return { data: item };
        }),

      update: (id: string, input: Types.OrganizationUpdate) =>
        executeRequest('organization.update', (ctx) => {
          const rawItem = db.organization.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Organization', id);
          return { data: parseRow<Types.Organization>(rawItem!, ['settings']) };
        }),

      delete: (id: string) =>
        executeRequest('organization.delete', (ctx) => {
          const item = db.organization.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Organization', id);
        }),
    },

    permission: {
      list: (options?: Types.QueryOptions<Types.PermissionFilter, Types.PermissionInclude>) =>
        executeRequest('permission.list', (ctx) => {
          let items = db.permission.getAll() as unknown as Types.Permission[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('organization')) {
                result.organization = db.organization.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
                });
              }
              return result as Types.Permission;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.PermissionInclude[] }) =>
        executeRequest('permission.get', (ctx) => {
          const rawItem = db.permission.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Permission', id);
          const item = rawItem as Types.Permission;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('organization')) {
              result.organization = db.organization.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
              });
            }
          }

          return { data: result as Types.Permission };
        }),

      create: (input: Types.PermissionCreate) =>
        executeRequest('permission.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.permission.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Permission;

          return { data: item };
        }),

      update: (id: string, input: Types.PermissionUpdate) =>
        executeRequest('permission.update', (ctx) => {
          const rawItem = db.permission.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Permission', id);
          return { data: rawItem as Types.Permission };
        }),

      delete: (id: string) =>
        executeRequest('permission.delete', (ctx) => {
          const item = db.permission.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Permission', id);
        }),
    },

    permissionTemplate: {
      list: (options?: Types.QueryOptions<Types.PermissiontemplateFilter, Types.PermissiontemplateInclude>) =>
        executeRequest('permissionTemplate.list', (ctx) => {
          let rawItems = db.permissionTemplate.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.Permissiontemplate>(row, ['permissions']));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('organization')) {
                result.organization = db.organization.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
                });
              }
              return result as Types.Permissiontemplate;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.PermissiontemplateInclude[] }) =>
        executeRequest('permissionTemplate.get', (ctx) => {
          const rawItem = db.permissionTemplate.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Permissiontemplate', id);
          const item = parseRow<Types.Permissiontemplate>(rawItem, ['permissions']);

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('organization')) {
              result.organization = db.organization.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
              });
            }
          }

          return { data: result as Types.Permissiontemplate };
        }),

      create: (input: Types.PermissiontemplateCreate) =>
        executeRequest('permissionTemplate.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.permissionTemplate.create(input as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.Permissiontemplate>(rawItem, ['permissions']);

          return { data: item };
        }),

      update: (id: string, input: Types.PermissiontemplateUpdate) =>
        executeRequest('permissionTemplate.update', (ctx) => {
          const rawItem = db.permissionTemplate.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Permissiontemplate', id);
          return { data: parseRow<Types.Permissiontemplate>(rawItem!, ['permissions']) };
        }),

      delete: (id: string) =>
        executeRequest('permissionTemplate.delete', (ctx) => {
          const item = db.permissionTemplate.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Permissiontemplate', id);
        }),
    },

    project: {
      list: (options?: Types.QueryOptions<Types.ProjectFilter, Types.ProjectInclude>) =>
        executeRequest('project.list', (ctx) => {
          let rawItems = db.project.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.Project>(row, ['settings']));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('owner')) {
                result.owner = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).owner_id as string } }
                });
              }
              if (options.include!.includes('environments')) {
                result.environments = db.environment.findMany({
                  where: { project_id: { equals: item.id } }
                });
              }
              if (options.include!.includes('deployments')) {
                result.deployments = db.deployment.findMany({
                  where: { project_id: { equals: item.id } }
                });
              }
              if (options.include!.includes('securityScans')) {
                result.securityScans = db.securityScan.findMany({
                  where: { project_id: { equals: item.id } }
                });
              }
              return result as Types.Project;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.ProjectInclude[] }) =>
        executeRequest('project.get', (ctx) => {
          const rawItem = db.project.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Project', id);
          const item = parseRow<Types.Project>(rawItem, ['settings']);

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('owner')) {
              result.owner = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).owner_id as string } }
              });
            }
            if (options.include.includes('environments')) {
              result.environments = db.environment.findMany({
                where: { project_id: { equals: item.id } }
              });
            }
            if (options.include.includes('deployments')) {
              result.deployments = db.deployment.findMany({
                where: { project_id: { equals: item.id } }
              });
            }
            if (options.include.includes('securityScans')) {
              result.securityScans = db.securityScan.findMany({
                where: { project_id: { equals: item.id } }
              });
            }
          }

          return { data: result as Types.Project };
        }),

      create: (input: Types.ProjectCreate) =>
        executeRequest('project.create', (ctx) => {
          const { environments, deployments, securityScans, ...data } = input;

          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.project.create(data as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.Project>(rawItem, ['settings']);

          if (environments) {
            for (const nested of environments) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.environment.create({ ...nested, project_id: item.id } as any);
            }
          }
          if (deployments) {
            for (const nested of deployments) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.deployment.create({ ...nested, project_id: item.id } as any);
            }
          }
          if (securityScans) {
            for (const nested of securityScans) {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              db.securityScan.create({ ...nested, project_id: item.id } as any);
            }
          }

          return { data: item };
        }),

      update: (id: string, input: Types.ProjectUpdate) =>
        executeRequest('project.update', (ctx) => {
          const rawItem = db.project.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Project', id);
          return { data: parseRow<Types.Project>(rawItem!, ['settings']) };
        }),

      delete: (id: string) =>
        executeRequest('project.delete', (ctx) => {
          const item = db.project.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Project', id);
        }),
    },

    userPermissionMap: {
      list: (options?: Types.QueryOptions<Types.UserpermissionmapFilter, Types.UserpermissionmapInclude>) =>
        executeRequest('userPermissionMap.list', (ctx) => {
          let rawItems = db.userPermissionMap.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.Userpermissionmap>(row, ['permissions']));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('user')) {
                result.user = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).user_id as string } }
                });
              }
              if (options.include!.includes('organization')) {
                result.organization = db.organization.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
                });
              }
              if (options.include!.includes('project')) {
                result.project = db.project.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
                });
              }
              if (options.include!.includes('grantedByUser')) {
                result.grantedByUser = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).granted_by as string } }
                });
              }
              return result as Types.Userpermissionmap;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.UserpermissionmapInclude[] }) =>
        executeRequest('userPermissionMap.get', (ctx) => {
          const rawItem = db.userPermissionMap.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Userpermissionmap', id);
          const item = parseRow<Types.Userpermissionmap>(rawItem, ['permissions']);

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('user')) {
              result.user = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).user_id as string } }
              });
            }
            if (options.include.includes('organization')) {
              result.organization = db.organization.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
              });
            }
            if (options.include.includes('project')) {
              result.project = db.project.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
              });
            }
            if (options.include.includes('grantedByUser')) {
              result.grantedByUser = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).granted_by as string } }
              });
            }
          }

          return { data: result as Types.Userpermissionmap };
        }),

      create: (input: Types.UserpermissionmapCreate) =>
        executeRequest('userPermissionMap.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.userPermissionMap.create(input as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.Userpermissionmap>(rawItem, ['permissions']);

          return { data: item };
        }),

      update: (id: string, input: Types.UserpermissionmapUpdate) =>
        executeRequest('userPermissionMap.update', (ctx) => {
          const rawItem = db.userPermissionMap.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Userpermissionmap', id);
          return { data: parseRow<Types.Userpermissionmap>(rawItem!, ['permissions']) };
        }),

      delete: (id: string) =>
        executeRequest('userPermissionMap.delete', (ctx) => {
          const item = db.userPermissionMap.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Userpermissionmap', id);
        }),
    },

    environment: {
      list: (options?: Types.QueryOptions<Types.EnvironmentFilter, Types.EnvironmentInclude>) =>
        executeRequest('environment.list', (ctx) => {
          let rawItems = db.environment.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.Environment>(row, ['variables']));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('project')) {
                result.project = db.project.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
                });
              }
              return result as Types.Environment;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.EnvironmentInclude[] }) =>
        executeRequest('environment.get', (ctx) => {
          const rawItem = db.environment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Environment', id);
          const item = parseRow<Types.Environment>(rawItem, ['variables']);

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('project')) {
              result.project = db.project.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
              });
            }
          }

          return { data: result as Types.Environment };
        }),

      create: (input: Types.EnvironmentCreate) =>
        executeRequest('environment.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.environment.create(input as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.Environment>(rawItem, ['variables']);

          return { data: item };
        }),

      update: (id: string, input: Types.EnvironmentUpdate) =>
        executeRequest('environment.update', (ctx) => {
          const rawItem = db.environment.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Environment', id);
          return { data: parseRow<Types.Environment>(rawItem!, ['variables']) };
        }),

      delete: (id: string) =>
        executeRequest('environment.delete', (ctx) => {
          const item = db.environment.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Environment', id);
        }),
    },

    deployment: {
      list: (options?: Types.QueryOptions<Types.DeploymentFilter, Types.DeploymentInclude>) =>
        executeRequest('deployment.list', (ctx) => {
          let items = db.deployment.getAll() as unknown as Types.Deployment[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('project')) {
                result.project = db.project.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
                });
              }
              if (options.include!.includes('environment')) {
                result.environment = db.environment.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).environment_id as string } }
                });
              }
              if (options.include!.includes('deployedByUser')) {
                result.deployedByUser = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).deployed_by as string } }
                });
              }
              return result as Types.Deployment;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.DeploymentInclude[] }) =>
        executeRequest('deployment.get', (ctx) => {
          const rawItem = db.deployment.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Deployment', id);
          const item = rawItem as Types.Deployment;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('project')) {
              result.project = db.project.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
              });
            }
            if (options.include.includes('environment')) {
              result.environment = db.environment.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).environment_id as string } }
              });
            }
            if (options.include.includes('deployedByUser')) {
              result.deployedByUser = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).deployed_by as string } }
              });
            }
          }

          return { data: result as Types.Deployment };
        }),

      create: (input: Types.DeploymentCreate) =>
        executeRequest('deployment.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.deployment.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Deployment;

          return { data: item };
        }),

      update: (id: string, input: Types.DeploymentUpdate) =>
        executeRequest('deployment.update', (ctx) => {
          const rawItem = db.deployment.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Deployment', id);
          return { data: rawItem as Types.Deployment };
        }),

      delete: (id: string) =>
        executeRequest('deployment.delete', (ctx) => {
          const item = db.deployment.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Deployment', id);
        }),
    },

    securityScan: {
      list: (options?: Types.QueryOptions<Types.SecurityscanFilter, Types.SecurityscanInclude>) =>
        executeRequest('securityScan.list', (ctx) => {
          let rawItems = db.securityScan.getAll() as unknown as Record<string, unknown>[];
          let items = rawItems.map(row => parseRow<Types.Securityscan>(row, ['findings', 'summary']));

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('project')) {
                result.project = db.project.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
                });
              }
              return result as Types.Securityscan;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.SecurityscanInclude[] }) =>
        executeRequest('securityScan.get', (ctx) => {
          const rawItem = db.securityScan.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Securityscan', id);
          const item = parseRow<Types.Securityscan>(rawItem, ['findings', 'summary']);

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('project')) {
              result.project = db.project.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).project_id as string } }
              });
            }
          }

          return { data: result as Types.Securityscan };
        }),

      create: (input: Types.SecurityscanCreate) =>
        executeRequest('securityScan.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.securityScan.create(input as any) as unknown as Record<string, unknown>;
          const item = parseRow<Types.Securityscan>(rawItem, ['findings', 'summary']);

          return { data: item };
        }),

      update: (id: string, input: Types.SecurityscanUpdate) =>
        executeRequest('securityScan.update', (ctx) => {
          const rawItem = db.securityScan.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Securityscan', id);
          return { data: parseRow<Types.Securityscan>(rawItem!, ['findings', 'summary']) };
        }),

      delete: (id: string) =>
        executeRequest('securityScan.delete', (ctx) => {
          const item = db.securityScan.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Securityscan', id);
        }),
    },

    teamInvitation: {
      list: (options?: Types.QueryOptions<Types.TeaminvitationFilter, Types.TeaminvitationInclude>) =>
        executeRequest('teamInvitation.list', (ctx) => {
          let items = db.teamInvitation.getAll() as unknown as Types.Teaminvitation[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('organization')) {
                result.organization = db.organization.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
                });
              }
              if (options.include!.includes('inviter')) {
                result.inviter = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).invited_by as string } }
                });
              }
              return result as Types.Teaminvitation;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.TeaminvitationInclude[] }) =>
        executeRequest('teamInvitation.get', (ctx) => {
          const rawItem = db.teamInvitation.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Teaminvitation', id);
          const item = rawItem as Types.Teaminvitation;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('organization')) {
              result.organization = db.organization.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
              });
            }
            if (options.include.includes('inviter')) {
              result.inviter = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).invited_by as string } }
              });
            }
          }

          return { data: result as Types.Teaminvitation };
        }),

      create: (input: Types.TeaminvitationCreate) =>
        executeRequest('teamInvitation.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.teamInvitation.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Teaminvitation;

          return { data: item };
        }),

      update: (id: string, input: Types.TeaminvitationUpdate) =>
        executeRequest('teamInvitation.update', (ctx) => {
          const rawItem = db.teamInvitation.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Teaminvitation', id);
          return { data: rawItem as Types.Teaminvitation };
        }),

      delete: (id: string) =>
        executeRequest('teamInvitation.delete', (ctx) => {
          const item = db.teamInvitation.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Teaminvitation', id);
        }),
    },

    teamMember: {
      list: (options?: Types.QueryOptions<Types.TeammemberFilter, Types.TeammemberInclude>) =>
        executeRequest('teamMember.list', (ctx) => {
          let items = db.teamMember.getAll() as unknown as Types.Teammember[];

          if (options?.where) {
            items = applyFilter(items, options.where);
          }

          const total = items.length;

          if (options?.orderBy) {
            const [field, dir] = Object.entries(options.orderBy)[0];
            items = [...items].sort((a, b) => {
              const aVal = (a as Record<string, unknown>)[field] as string | number | Date;
              const bVal = (b as Record<string, unknown>)[field] as string | number | Date;
              if (aVal < bVal) return dir === 'asc' ? -1 : 1;
              if (aVal > bVal) return dir === 'asc' ? 1 : -1;
              return 0;
            });
          }

          const limit = options?.limit ?? 20;
          const offset = options?.offset ?? 0;
          items = items.slice(offset, offset + limit);

          if (options?.include?.length) {
            items = items.map(item => {
              const result = { ...item } as Record<string, unknown>;
              if (options.include!.includes('organization')) {
                result.organization = db.organization.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
                });
              }
              if (options.include!.includes('user')) {
                result.user = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).user_id as string } }
                });
              }
              if (options.include!.includes('inviter')) {
                result.inviter = db.profile.findFirst({
                  where: { id: { equals: (item as Record<string, unknown>).invited_by as string } }
                });
              }
              return result as Types.Teammember;
            });
          }

          return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };
        }),

      get: (id: string, options?: { include?: Types.TeammemberInclude[] }) =>
        executeRequest('teamMember.get', (ctx) => {
          const rawItem = db.teamMember.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Teammember', id);
          const item = rawItem as Types.Teammember;

          const result = { ...item } as Record<string, unknown>;

          if (options?.include?.length) {
            if (options.include.includes('organization')) {
              result.organization = db.organization.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).organization_id as string } }
              });
            }
            if (options.include.includes('user')) {
              result.user = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).user_id as string } }
              });
            }
            if (options.include.includes('inviter')) {
              result.inviter = db.profile.findFirst({
                where: { id: { equals: (item as Record<string, unknown>).invited_by as string } }
              });
            }
          }

          return { data: result as Types.Teammember };
        }),

      create: (input: Types.TeammemberCreate) =>
        executeRequest('teamMember.create', (ctx) => {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const rawItem = db.teamMember.create(input as any) as unknown as Record<string, unknown>;
          const item = rawItem as Types.Teammember;

          return { data: item };
        }),

      update: (id: string, input: Types.TeammemberUpdate) =>
        executeRequest('teamMember.update', (ctx) => {
          const rawItem = db.teamMember.update({
            where: { id: { equals: id } },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: { ...input, updatedAt: new Date() } as any,
          }) as unknown as Record<string, unknown> | null;
          if (!rawItem) throw createNotFoundError('Teammember', id);
          return { data: rawItem as Types.Teammember };
        }),

      delete: (id: string) =>
        executeRequest('teamMember.delete', (ctx) => {
          const item = db.teamMember.delete({ where: { id: { equals: id } } });
          if (!item) throw createNotFoundError('Teammember', id);
        }),
    },

  };
}

/**
 * Default API client (no interceptors configured).
 * For production, use createClient() with interceptors instead.
 * 
 * @example
 * ```typescript
 * // Simple usage (no auth)
 * const posts = await api.post.list();
 * 
 * // For production with auth, use createClient instead:
 * const api = createClient({
 *   onRequest: (ctx) => {
 *     ctx.headers.Authorization = `Bearer ${getToken()}`;
 *     return ctx;
 *   }
 * });
 * ```
 */
export const api = createClient();