// GENERATED BY SCHEMOCK - DO NOT EDIT
import { http, HttpResponse } from 'msw';
import { api } from './client';
import { routes } from './routes';
import type * as Types from './types';

export const handlers = [
  // Authuser handlers
  http.get(routes.authusers.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.authUser.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.authusers.get.path, async ({ params }) => {
    const response = await api.authUser.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Authuser not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.authusers.create.path, async ({ request }) => {
    const body = await request.json() as Types.AuthuserCreate;

    const response = await api.authUser.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.authusers.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.AuthuserUpdate;

    const response = await api.authUser.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.authusers.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.AuthuserUpdate;

    const response = await api.authUser.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.authusers.delete.path, async ({ params }) => {
    await api.authUser.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Authsession handlers
  http.get(routes.authsessions.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.authSession.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.authsessions.get.path, async ({ params }) => {
    const response = await api.authSession.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Authsession not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.authsessions.create.path, async ({ request }) => {
    const body = await request.json() as Types.AuthsessionCreate;

    const response = await api.authSession.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.authsessions.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.AuthsessionUpdate;

    const response = await api.authSession.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.authsessions.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.AuthsessionUpdate;

    const response = await api.authSession.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.authsessions.delete.path, async ({ params }) => {
    await api.authSession.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Profile handlers
  http.get(routes.profiles.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.profile.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.profiles.get.path, async ({ params }) => {
    const response = await api.profile.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Profile not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.profiles.create.path, async ({ request }) => {
    const body = await request.json() as Types.ProfileCreate;

    const response = await api.profile.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.profiles.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.ProfileUpdate;

    const response = await api.profile.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.profiles.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.ProfileUpdate;

    const response = await api.profile.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.profiles.delete.path, async ({ params }) => {
    await api.profile.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Organization handlers
  http.get(routes.organizations.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.organization.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.organizations.get.path, async ({ params }) => {
    const response = await api.organization.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Organization not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.organizations.create.path, async ({ request }) => {
    const body = await request.json() as Types.OrganizationCreate;

    const response = await api.organization.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.organizations.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.OrganizationUpdate;

    const response = await api.organization.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.organizations.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.OrganizationUpdate;

    const response = await api.organization.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.organizations.delete.path, async ({ params }) => {
    await api.organization.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Permission handlers
  http.get(routes.permissions.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.permission.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.permissions.get.path, async ({ params }) => {
    const response = await api.permission.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Permission not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.permissions.create.path, async ({ request }) => {
    const body = await request.json() as Types.PermissionCreate;

    const response = await api.permission.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.permissions.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.PermissionUpdate;

    const response = await api.permission.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.permissions.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.PermissionUpdate;

    const response = await api.permission.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.permissions.delete.path, async ({ params }) => {
    await api.permission.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Permissiontemplate handlers
  http.get(routes.permissiontemplates.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.permissionTemplate.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.permissiontemplates.get.path, async ({ params }) => {
    const response = await api.permissionTemplate.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Permissiontemplate not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.permissiontemplates.create.path, async ({ request }) => {
    const body = await request.json() as Types.PermissiontemplateCreate;

    const response = await api.permissionTemplate.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.permissiontemplates.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.PermissiontemplateUpdate;

    const response = await api.permissionTemplate.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.permissiontemplates.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.PermissiontemplateUpdate;

    const response = await api.permissionTemplate.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.permissiontemplates.delete.path, async ({ params }) => {
    await api.permissionTemplate.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Project handlers
  http.get(routes.projects.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.project.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.projects.get.path, async ({ params }) => {
    const response = await api.project.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Project not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.projects.create.path, async ({ request }) => {
    const body = await request.json() as Types.ProjectCreate;

    const response = await api.project.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.projects.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.ProjectUpdate;

    const response = await api.project.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.projects.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.ProjectUpdate;

    const response = await api.project.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.projects.delete.path, async ({ params }) => {
    await api.project.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Userpermissionmap handlers
  http.get(routes.userpermissionmaps.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.userPermissionMap.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.userpermissionmaps.get.path, async ({ params }) => {
    const response = await api.userPermissionMap.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Userpermissionmap not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.userpermissionmaps.create.path, async ({ request }) => {
    const body = await request.json() as Types.UserpermissionmapCreate;

    const response = await api.userPermissionMap.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.userpermissionmaps.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.UserpermissionmapUpdate;

    const response = await api.userPermissionMap.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.userpermissionmaps.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.UserpermissionmapUpdate;

    const response = await api.userPermissionMap.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.userpermissionmaps.delete.path, async ({ params }) => {
    await api.userPermissionMap.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Environment handlers
  http.get(routes.environments.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.environment.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.environments.get.path, async ({ params }) => {
    const response = await api.environment.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Environment not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.environments.create.path, async ({ request }) => {
    const body = await request.json() as Types.EnvironmentCreate;

    const response = await api.environment.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.environments.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.EnvironmentUpdate;

    const response = await api.environment.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.environments.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.EnvironmentUpdate;

    const response = await api.environment.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.environments.delete.path, async ({ params }) => {
    await api.environment.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Deployment handlers
  http.get(routes.deployments.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.deployment.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.deployments.get.path, async ({ params }) => {
    const response = await api.deployment.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Deployment not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.deployments.create.path, async ({ request }) => {
    const body = await request.json() as Types.DeploymentCreate;

    const response = await api.deployment.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.deployments.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.DeploymentUpdate;

    const response = await api.deployment.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.deployments.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.DeploymentUpdate;

    const response = await api.deployment.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.deployments.delete.path, async ({ params }) => {
    await api.deployment.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Securityscan handlers
  http.get(routes.securityscans.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.securityScan.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.securityscans.get.path, async ({ params }) => {
    const response = await api.securityScan.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Securityscan not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.securityscans.create.path, async ({ request }) => {
    const body = await request.json() as Types.SecurityscanCreate;

    const response = await api.securityScan.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.securityscans.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.SecurityscanUpdate;

    const response = await api.securityScan.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.securityscans.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.SecurityscanUpdate;

    const response = await api.securityScan.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.securityscans.delete.path, async ({ params }) => {
    await api.securityScan.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Teaminvitation handlers
  http.get(routes.teaminvitations.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.teamInvitation.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.teaminvitations.get.path, async ({ params }) => {
    const response = await api.teamInvitation.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Teaminvitation not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.teaminvitations.create.path, async ({ request }) => {
    const body = await request.json() as Types.TeaminvitationCreate;

    const response = await api.teamInvitation.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.teaminvitations.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.TeaminvitationUpdate;

    const response = await api.teamInvitation.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.teaminvitations.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.TeaminvitationUpdate;

    const response = await api.teamInvitation.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.teaminvitations.delete.path, async ({ params }) => {
    await api.teamInvitation.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

  // Teammember handlers
  http.get(routes.teammembers.list.path, async ({ request }) => {
    const url = new URL(request.url);
    const limit = parseInt(url.searchParams.get('limit') || '20');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const response = await api.teamMember.list({ limit, offset });
    return HttpResponse.json(response);
  }),

  http.get(routes.teammembers.get.path, async ({ params }) => {
    const response = await api.teamMember.get(params.id as string);
    if (!response.data) {
      return HttpResponse.json({ error: 'Teammember not found' }, { status: 404 });
    }
    return HttpResponse.json(response);
  }),

  http.post(routes.teammembers.create.path, async ({ request }) => {
    const body = await request.json() as Types.TeammemberCreate;

    const response = await api.teamMember.create(body);
    return HttpResponse.json(response, { status: 201 });
  }),

  http.put(routes.teammembers.update.path, async ({ params, request }) => {
    const body = await request.json() as Types.TeammemberUpdate;

    const response = await api.teamMember.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.patch(routes.teammembers.patch.path, async ({ params, request }) => {
    const body = await request.json() as Types.TeammemberUpdate;

    const response = await api.teamMember.update(params.id as string, body);
    return HttpResponse.json(response);
  }),

  http.delete(routes.teammembers.delete.path, async ({ params }) => {
    await api.teamMember.delete(params.id as string);
    return new HttpResponse(null, { status: 204 });
  }),

];