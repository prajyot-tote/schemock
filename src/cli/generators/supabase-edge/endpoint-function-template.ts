/**
 * Supabase Edge Endpoint Function Template
 *
 * Generates Deno-based Edge Function handlers for custom endpoints
 * defined via defineEndpoint().
 *
 * @module cli/generators/supabase-edge/endpoint-function-template
 * @category CLI
 */

import type { AnalyzedEndpoint, GenerationTarget, SchemockConfig } from '../../types';
import {
  generateParamParsingExpression,
  generateEndpointTodoBody,
  getQueryParams,
  deriveEdgeFunctionName,
} from '../shared/endpoint-helpers';

/**
 * Build a regex pattern for matching a path with params.
 * e.g., /api/users/:id/posts -> /api/users/([^/]+)/posts
 */
function buildPathRegex(path: string): string {
  // First replace :param with placeholder, then escape special chars, then restore
  const withPlaceholders = path.replace(/:(\w+)/g, '___CAPTURE___');
  const escaped = withPlaceholders
    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&');  // Escape regex special chars
  const withCaptures = escaped.replace(/___CAPTURE___/g, '([^/]+)');
  return `^${withCaptures}$`;
}

/**
 * Generate a standalone Deno Edge Function for a custom endpoint
 */
export function generateEndpointEdgeFunction(
  endpoint: AnalyzedEndpoint,
  _target: GenerationTarget,
  config: SchemockConfig
): string {
  const hasBody = endpoint.body.length > 0;
  const hasParams = endpoint.params.length > 0 || endpoint.pathParams.length > 0;
  const hasResponse = endpoint.response.length > 0;
  const queryParams = getQueryParams(endpoint);
  const hasPathParams = endpoint.pathParams.length > 0;
  const hasNewMiddlewareConfig = config.middleware !== undefined;

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    `// Custom endpoint: ${endpoint.method} ${endpoint.path}`,
    '',
    "import { corsHeaders } from '../_shared/cors.ts';",
    "import { supabase } from '../_shared/supabase.ts';",
  ];

  // Import endpoint types
  const typeImports: string[] = [];
  if (hasParams) typeImports.push(`${endpoint.pascalName}Params`);
  if (hasBody) typeImports.push(`${endpoint.pascalName}Body`);
  if (hasResponse) typeImports.push(`${endpoint.pascalName}Response`);

  if (typeImports.length > 0) {
    lines.push(`import type { ${typeImports.join(', ')} } from '../_shared/endpoint-types.ts';`);
  }

  // Import middleware chain if using new config
  if (hasNewMiddlewareConfig) {
    lines.push("import { runMiddlewareChain } from '../_shared/middleware/chain.ts';");
  }

  lines.push('');

  // Helper function
  lines.push('function jsonResponse(data: unknown, status = 200): Response {');
  lines.push('  return new Response(JSON.stringify(data), {');
  lines.push('    status,');
  lines.push("    headers: { ...corsHeaders(), 'Content-Type': 'application/json' },");
  lines.push('  });');
  lines.push('}');
  lines.push('');

  // Deno.serve
  lines.push('Deno.serve(async (req) => {');
  lines.push('  // Handle CORS preflight');
  lines.push("  if (req.method === 'OPTIONS') {");
  lines.push("    return new Response('ok', { headers: corsHeaders() });");
  lines.push('  }');
  lines.push('');

  // Method check
  lines.push(`  if (req.method !== '${endpoint.method}') {`);
  lines.push("    return jsonResponse({ error: 'Method not allowed' }, 405);");
  lines.push('  }');
  lines.push('');

  // Add middleware chain call if using new config
  if (hasNewMiddlewareConfig) {
    lines.push('  // Run middleware chain');
    lines.push("  const mwResult = await runMiddlewareChain(req, 'custom');");
    lines.push('  if (mwResult.error) {');
    lines.push('    return mwResult.response!;');
    lines.push('  }');
    lines.push('');
  }

  lines.push('  const url = new URL(req.url);');
  lines.push('');

  // Parse path params via regex
  if (hasPathParams) {
    const regex = buildPathRegex(endpoint.path);
    // Escape forward slashes for regex literal
    const regexBody = regex.slice(1, -1).replace(/\//g, '\\/');
    lines.push(`  const pathMatch = url.pathname.match(/${regexBody}/);`);
    lines.push('  if (!pathMatch) {');
    lines.push("    return jsonResponse({ error: 'Not found' }, 404);");
    lines.push('  }');
    // Destructure captures
    for (let i = 0; i < endpoint.pathParams.length; i++) {
      lines.push(`  const ${endpoint.pathParams[i]} = pathMatch[${i + 1}];`);
    }
    lines.push('');
  }

  lines.push('  try {');

  // Parse query params
  if (queryParams.length > 0) {
    for (const param of queryParams) {
      const accessPattern = `url.searchParams.get('${param.name}')`;
      const parsed = generateParamParsingExpression(param, accessPattern);
      lines.push(`    const ${param.name} = ${parsed};`);
    }
    lines.push('');
  }

  // Parse body
  if (hasBody) {
    lines.push(`    const body = await req.json() as ${endpoint.pascalName}Body;`);
    lines.push('');
  }

  // TODO body with DB-specific example
  const todoLines = generateEndpointTodoBody(endpoint, 'supabase');
  lines.push(...todoLines);
  lines.push('');

  // Default response
  lines.push("    return jsonResponse({ error: 'Not implemented' }, 501);");

  lines.push('  } catch (error) {');
  lines.push(`    console.error('${endpoint.method} ${endpoint.path} error:', error);`);
  lines.push("    return jsonResponse({ error: 'Internal server error' }, 500);");
  lines.push('  }');
  lines.push('});');

  return lines.join('\n');
}

/**
 * Generate endpoint route entries for inclusion in a fat function router
 */
export function generateEndpointFatFunctionRoutes(
  endpoints: AnalyzedEndpoint[]
): string[] {
  const lines: string[] = [];

  for (const endpoint of endpoints) {
    const method = endpoint.method;
    const queryParams = getQueryParams(endpoint);
    const hasBody = endpoint.body.length > 0;
    const hasPathParams = endpoint.pathParams.length > 0;

    lines.push('');
    lines.push(`    // Custom endpoint: ${method} ${endpoint.path}`);

    // Build matching condition
    if (hasPathParams) {
      // Use regex matching for paths with parameters
      const regexPattern = endpoint.path
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/\\:(\w+)/g, '([^/]+)');

      lines.push(`    const ${endpoint.name}Match = pathname.match(/^${regexPattern.replace(/\//g, '\\/')}$/);`);
      lines.push(`    if (method === '${method}' && ${endpoint.name}Match) {`);

      // Extract path params from match
      for (let i = 0; i < endpoint.pathParams.length; i++) {
        lines.push(`      const ${endpoint.pathParams[i]} = ${endpoint.name}Match[${i + 1}];`);
      }
    } else {
      lines.push(`    if (method === '${method}' && pathname === '${endpoint.path}') {`);
    }

    // Parse query params
    if (queryParams.length > 0) {
      for (const param of queryParams) {
        const accessPattern = `searchParams.get('${param.name}')`;
        const parsed = generateParamParsingExpression(param, accessPattern);
        lines.push(`      const ${param.name} = ${parsed};`);
      }
    }

    // Parse body
    if (hasBody) {
      lines.push(`      const body = await req.json();`);
    }

    // TODO body
    lines.push('      // TODO: Implement business logic');
    if (endpoint.description) {
      lines.push(`      // ${endpoint.description}`);
    }
    lines.push("      return jsonResponse({ error: 'Not implemented' }, 501);");
    lines.push('    }');
  }

  return lines;
}
