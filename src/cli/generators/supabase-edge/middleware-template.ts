/**
 * Supabase Edge Middleware Templates
 *
 * Generates Deno-compatible middleware for Supabase Edge Functions.
 * Uses Web Fetch API patterns for request/response handling.
 *
 * @module cli/generators/supabase-edge/middleware-template
 * @category CLI
 */

import type {
  AnalyzedSchema,
  AuthMiddlewareConfig,
  RateLimitMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
  AnalyzedMiddleware,
} from '../../types';

/**
 * Generate auth middleware for Supabase Edge
 */
export function generateAuthMiddlewareEdge(config: AuthMiddlewareConfig): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '// Auth middleware for Supabase Edge Functions',
    '',
    "import { createUserClient } from '../supabase.ts';",
    "import { corsHeaders } from '../cors.ts';",
    '',
    '/**',
    ' * Auth context extracted from request',
    ' */',
    'export interface AuthContext {',
    '  userId: string;',
    '  email?: string;',
    '  role?: string;',
    '  jwt?: string;',
    '  [key: string]: unknown;',
    '}',
    '',
    '/**',
    ' * Auth middleware result',
    ' */',
    'export interface AuthResult {',
    '  error: boolean;',
    '  response?: Response;',
    '  context?: AuthContext;',
    '}',
    '',
    '/**',
    ' * Create a JSON error response',
    ' */',
    'function errorResponse(message: string, status: number): Response {',
    '  return new Response(JSON.stringify({ error: message }), {',
    '    status,',
    "    headers: { 'Content-Type': 'application/json', ...corsHeaders() },",
    '  });',
    '}',
    '',
    '/**',
    ' * Auth middleware - validates request authentication',
    ' */',
    'export async function authMiddleware(req: Request): Promise<AuthResult> {',
  ];

  if (config.provider === 'supabase-auth') {
    lines.push("  const authHeader = req.headers.get('authorization');");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: errorResponse('Missing authorization header', 401),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  // Verify token with Supabase');
    lines.push('  const supabaseClient = createUserClient(token);');
    lines.push('  const { data: { user }, error } = await supabaseClient.auth.getUser(token);');
    lines.push('');
    lines.push('  if (error || !user) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: errorResponse('Invalid or expired token', 401),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  return {');
    lines.push('    error: false,');
    lines.push('    context: {');
    lines.push('      userId: user.id,');
    lines.push('      email: user.email,');
    lines.push('      role: user.user_metadata?.role,');
    lines.push('      jwt: token,');
    lines.push('    },');
    lines.push('  };');
  } else if (config.provider === 'jwt') {
    // Deno doesn't have a built-in JWT library, use manual decoding
    // In production, you'd want to use a proper JWT library
    lines.push("  const authHeader = req.headers.get('authorization');");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: errorResponse('Missing authorization header', 401),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push('    // Decode JWT payload (without full verification)');
    lines.push('    // For production, use a proper JWT library like jose');
    lines.push("    const parts = token.split('.');");
    lines.push('    if (parts.length !== 3) {');
    lines.push('      throw new Error("Invalid JWT format");');
    lines.push('    }');
    lines.push('');
    lines.push('    const payload = JSON.parse(atob(parts[1]));');
    lines.push('');
    lines.push('    // Check expiration');
    lines.push('    if (payload.exp && payload.exp < Date.now() / 1000) {');
    lines.push("      throw new Error('Token expired');");
    lines.push('    }');
    lines.push('');
    lines.push('    return {');
    lines.push('      error: false,');
    lines.push('      context: {');
    lines.push('        userId: payload.sub,');
    lines.push('        email: payload.email,');
    lines.push('        role: payload.role,');
    lines.push('        jwt: token,');
    lines.push('      },');
    lines.push('    };');
    lines.push('  } catch {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: errorResponse('Invalid or expired token', 401),");
    lines.push('    };');
    lines.push('  }');
  } else {
    // Custom or other providers
    lines.push("  const authHeader = req.headers.get('authorization');");
    lines.push('');
    lines.push('  if (!authHeader) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: errorResponse('Not authenticated', 401),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  // TODO: Implement custom auth logic');
    lines.push("  return { error: false, context: { userId: 'custom-user-id' } };");
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate rate limit middleware for Supabase Edge
 */
export function generateRateLimitMiddlewareEdge(config: RateLimitMiddlewareConfig): string {
  const max = config.max ?? 100;
  const windowMs = config.windowMs ?? 60000;
  const keyBy = config.keyBy || 'ip';

  return `// GENERATED BY SCHEMOCK - DO NOT EDIT
// Rate limit middleware for Supabase Edge Functions

import { corsHeaders } from '../cors.ts';

/**
 * Rate limit entry
 */
interface RateLimitEntry {
  count: number;
  resetTime: number;
}

// In-memory rate limit store
// Note: This is per-isolate and won't persist across invocations
// For production, use Supabase or Redis for distributed rate limiting
const rateLimitStore = new Map<string, RateLimitEntry>();

const RATE_LIMIT_MAX = ${max};
const RATE_LIMIT_WINDOW_MS = ${windowMs};

/**
 * Rate limit result
 */
export interface RateLimitResult {
  error: boolean;
  response?: Response;
  remaining?: number;
  resetTime?: number;
}

/**
 * Get rate limit key from request
 */
function getRateLimitKey(req: Request, userId?: string): string {
${keyBy === 'user' ? `  // Key by user ID
  if (userId) return \`user:\${userId}\`;
  // Fall back to IP if no user` : ''}
  const forwarded = req.headers.get('x-forwarded-for');
  const ip = forwarded?.split(',')[0] ?? 'unknown';
  return \`ip:\${ip}\`;
}

/**
 * Rate limit middleware
 */
export function rateLimitMiddleware(
  req: Request,
  userId?: string
): RateLimitResult {
  const key = getRateLimitKey(req, userId);
  const now = Date.now();

  let entry = rateLimitStore.get(key);

  // Clean up expired entry
  if (entry && entry.resetTime < now) {
    rateLimitStore.delete(key);
    entry = undefined;
  }

  if (!entry) {
    entry = {
      count: 1,
      resetTime: now + RATE_LIMIT_WINDOW_MS,
    };
    rateLimitStore.set(key, entry);
  } else {
    entry.count++;
  }

  const remaining = Math.max(0, RATE_LIMIT_MAX - entry.count);
  const resetTime = entry.resetTime;

  if (entry.count > RATE_LIMIT_MAX) {
    const retryAfter = Math.ceil((resetTime - now) / 1000);
    return {
      error: true,
      response: new Response(
        JSON.stringify({ error: 'Too many requests', retryAfter }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'X-RateLimit-Limit': RATE_LIMIT_MAX.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': Math.ceil(resetTime / 1000).toString(),
            'Retry-After': retryAfter.toString(),
            ...corsHeaders(),
          },
        }
      ),
      remaining: 0,
      resetTime,
    };
  }

  return { error: false, remaining, resetTime };
}

/**
 * Add rate limit headers to response
 */
export function addRateLimitHeaders(
  headers: Headers,
  remaining: number,
  resetTime: number
): void {
  headers.set('X-RateLimit-Limit', RATE_LIMIT_MAX.toString());
  headers.set('X-RateLimit-Remaining', remaining.toString());
  headers.set('X-RateLimit-Reset', Math.ceil(resetTime / 1000).toString());
}
`;
}

/**
 * Generate cache middleware for Supabase Edge
 */
export function generateCacheMiddlewareEdge(config: CacheMiddlewareConfig): string {
  const ttl = config.ttl ?? 300000;
  const operations = config.operations ?? ['findOne', 'findMany'];

  return `// GENERATED BY SCHEMOCK - DO NOT EDIT
// Cache middleware for Supabase Edge Functions

/**
 * Cache entry
 */
interface CacheEntry {
  data: unknown;
  expiresAt: number;
}

// In-memory cache store
// Note: This is per-isolate and won't persist across invocations
// For production, use Supabase or Redis for distributed caching
const cacheStore = new Map<string, CacheEntry>();

const CACHE_TTL_MS = ${ttl};
const CACHED_OPERATIONS = ${JSON.stringify(operations)};

/**
 * Cache result
 */
export interface CacheResult {
  hit: boolean;
  data?: unknown;
}

/**
 * Generate cache key from request
 */
function getCacheKey(req: Request, userId?: string): string {
  const url = new URL(req.url);
  const baseKey = \`\${req.method}:\${url.pathname}:\${url.searchParams.toString()}\`;
  return userId ? \`\${baseKey}:user:\${userId}\` : baseKey;
}

/**
 * Check if operation should be cached
 */
function shouldCache(req: Request, pathname: string): boolean {
  if (req.method !== 'GET') return false;

  // Determine operation type from pathname
  const hasId = /\\/[a-zA-Z0-9-]+$/.test(pathname) && !pathname.endsWith('s');
  const operation = hasId ? 'findOne' : 'findMany';

  return CACHED_OPERATIONS.includes(operation);
}

/**
 * Cache middleware - check cache for GET requests
 */
export function cacheMiddleware(
  req: Request,
  userId?: string
): CacheResult {
  const url = new URL(req.url);

  if (!shouldCache(req, url.pathname)) {
    return { hit: false };
  }

  const key = getCacheKey(req, userId);
  const entry = cacheStore.get(key);

  if (entry && entry.expiresAt > Date.now()) {
    return { hit: true, data: entry.data };
  }

  // Clean up expired entry
  if (entry) {
    cacheStore.delete(key);
  }

  return { hit: false };
}

/**
 * Store response in cache
 */
export function setCacheEntry(
  req: Request,
  data: unknown,
  userId?: string
): void {
  const url = new URL(req.url);

  if (!shouldCache(req, url.pathname)) return;

  const key = getCacheKey(req, userId);
  cacheStore.set(key, {
    data,
    expiresAt: Date.now() + CACHE_TTL_MS,
  });
}

/**
 * Invalidate cache entries matching a pattern
 */
export function invalidateCache(pattern?: string | RegExp): void {
  if (!pattern) {
    cacheStore.clear();
    return;
  }

  const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;
  for (const key of cacheStore.keys()) {
    if (regex.test(key)) {
      cacheStore.delete(key);
    }
  }
}
`;
}

/**
 * Generate logger middleware for Supabase Edge
 */
export function generateLoggerMiddlewareEdge(config: LoggerMiddlewareConfig): string {
  const level = config.level ?? 'info';
  const redactFields = config.redactFields ?? ['password', 'token', 'secret', 'authorization'];

  return `// GENERATED BY SCHEMOCK - DO NOT EDIT
// Logger middleware for Supabase Edge Functions

const LOG_LEVEL = '${level}';
const REDACT_FIELDS = ${JSON.stringify(redactFields)};

/**
 * Log levels
 */
const LOG_LEVELS = { debug: 0, info: 1, warn: 2, error: 3 } as const;

/**
 * Request log entry
 */
export interface RequestLog {
  timestamp: string;
  method: string;
  path: string;
  query?: Record<string, string>;
  userId?: string;
  duration?: number;
  status?: number;
}

/**
 * Redact sensitive fields from object
 */
function redactSensitive(obj: Record<string, unknown>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (REDACT_FIELDS.some((f) => key.toLowerCase().includes(f.toLowerCase()))) {
      result[key] = '[REDACTED]';
    } else if (typeof value === 'object' && value !== null) {
      result[key] = redactSensitive(value as Record<string, unknown>);
    } else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Log a message at the specified level
 */
function log(level: keyof typeof LOG_LEVELS, message: string, data?: Record<string, unknown>): void {
  if (LOG_LEVELS[level] < LOG_LEVELS[LOG_LEVEL as keyof typeof LOG_LEVELS]) return;

  const logEntry = {
    timestamp: new Date().toISOString(),
    level,
    message,
    ...redactSensitive(data || {}),
  };

  if (level === 'error') {
    console.error(JSON.stringify(logEntry));
  } else if (level === 'warn') {
    console.warn(JSON.stringify(logEntry));
  } else {
    console.log(JSON.stringify(logEntry));
  }
}

/**
 * Logger middleware - log request start
 * Returns a function to call when request completes
 */
export function loggerMiddleware(
  req: Request,
  userId?: string
): { finish: (status: number) => void } {
  const startTime = Date.now();
  const url = new URL(req.url);

  const logData: RequestLog = {
    timestamp: new Date().toISOString(),
    method: req.method,
    path: url.pathname,
    userId,
  };

  // Log query params (redacted)
  const queryParams: Record<string, string> = {};
  url.searchParams.forEach((value, key) => {
    queryParams[key] = value;
  });
  if (Object.keys(queryParams).length > 0) {
    logData.query = redactSensitive(queryParams) as Record<string, string>;
  }

  log('debug', 'Request started', logData as unknown as Record<string, unknown>);

  return {
    finish: (status: number) => {
      const duration = Date.now() - startTime;
      log('info', 'Request completed', {
        ...logData,
        status,
        duration,
      } as unknown as Record<string, unknown>);
    },
  };
}
`;
}

/**
 * Generate context extraction middleware for Supabase Edge
 */
export function generateContextMiddlewareEdge(): string {
  return `// GENERATED BY SCHEMOCK - DO NOT EDIT
// Context extraction middleware for Supabase Edge Functions

/**
 * Request context extracted from headers/JWT
 */
export interface RequestContext {
  userId?: string;
  email?: string;
  role?: string;
  tenantId?: string;
  [key: string]: unknown;
}

/**
 * Decode JWT payload (without verification - auth middleware handles that)
 */
function decodeJwtPayload(token: string): Record<string, unknown> | null {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = atob(parts[1]);
    return JSON.parse(payload);
  } catch {
    return null;
  }
}

/**
 * Context middleware - extracts context from request headers and JWT
 */
export function contextMiddleware(req: Request): RequestContext {
  const context: RequestContext = {};

  // Extract from Authorization header (JWT)
  const authHeader = req.headers.get('authorization');
  if (authHeader) {
    const token = authHeader.split(' ')[1];
    if (token) {
      const payload = decodeJwtPayload(token);
      if (payload) {
        context.userId = payload.sub as string;
        context.email = payload.email as string;
        context.role = payload.role as string;
      }
    }
  }

  // Extract from custom headers
  const tenantId = req.headers.get('x-tenant-id');
  if (tenantId) context.tenantId = tenantId;

  const userId = req.headers.get('x-user-id');
  if (userId && !context.userId) context.userId = userId;

  const role = req.headers.get('x-user-role');
  if (role && !context.role) context.role = role;

  return context;
}
`;
}

/**
 * Generate RLS middleware for Supabase Edge
 */
export function generateRlsMiddlewareEdge(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '// RLS middleware for Supabase Edge Functions',
    '',
    "import { corsHeaders } from '../cors.ts';",
    "import type { RequestContext } from './context.ts';",
    '',
    '/**',
    ' * RLS operation type',
    ' */',
    "export type RLSOperation = 'select' | 'insert' | 'update' | 'delete';",
    '',
    '/**',
    ' * RLS filter result',
    ' */',
    'export interface RLSFilter {',
    '  allowed: boolean;',
    '  filter?: Record<string, unknown>;',
    '  response?: Response;',
    '}',
    '',
    '/**',
    ' * Entity RLS policies',
    ' */',
    'interface EntityRLSPolicy {',
    '  scope?: Array<{ field: string; contextKey: string }>;',
    '  bypass?: Array<{ contextKey: string; values: string[] }>;',
    '}',
    '',
    '/**',
    ' * Create a JSON error response',
    ' */',
    'function errorResponse(message: string, status: number): Response {',
    '  return new Response(JSON.stringify({ error: message }), {',
    '    status,',
    "    headers: { 'Content-Type': 'application/json', ...corsHeaders() },",
    '  });',
    '}',
    '',
    '/**',
    ' * RLS policies by entity',
    ' */',
    'const rlsPolicies: Record<string, EntityRLSPolicy> = {',
  ];

  // Generate policies for each schema with RLS config
  for (const schema of schemas) {
    if (!schema.rlsConfig) continue;

    lines.push(`  '${schema.tableName}': {`);

    if (schema.rlsConfig.scope) {
      lines.push('    scope: [');
      for (const scopeItem of schema.rlsConfig.scope) {
        lines.push(`      { field: '${scopeItem.field}', contextKey: '${scopeItem.contextKey}' },`);
      }
      lines.push('    ],');
    }

    if (schema.rlsConfig.bypass) {
      lines.push('    bypass: [');
      for (const bypassItem of schema.rlsConfig.bypass) {
        lines.push(`      { contextKey: '${bypassItem.contextKey}', values: ${JSON.stringify(bypassItem.values)} },`);
      }
      lines.push('    ],');
    }

    lines.push('  },');
  }

  lines.push('};');
  lines.push('');
  lines.push('/**');
  lines.push(' * Check if context bypasses RLS');
  lines.push(' */');
  lines.push('function checkBypass(policy: EntityRLSPolicy, context: RequestContext): boolean {');
  lines.push('  if (!policy.bypass) return false;');
  lines.push('');
  lines.push('  for (const bypass of policy.bypass) {');
  lines.push('    const contextValue = context[bypass.contextKey] as string;');
  lines.push('    if (contextValue && bypass.values.includes(contextValue)) {');
  lines.push('      return true;');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  lines.push('  return false;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Apply RLS filter for an operation');
  lines.push(' */');
  lines.push('export function applyRLSFilter(');
  lines.push('  entity: string,');
  lines.push('  operation: RLSOperation,');
  lines.push('  context: RequestContext');
  lines.push('): RLSFilter {');
  lines.push('  const policy = rlsPolicies[entity];');
  lines.push('');
  lines.push('  // No RLS policy for this entity');
  lines.push('  if (!policy) {');
  lines.push('    return { allowed: true };');
  lines.push('  }');
  lines.push('');
  lines.push('  // Check bypass');
  lines.push('  if (checkBypass(policy, context)) {');
  lines.push('    return { allowed: true };');
  lines.push('  }');
  lines.push('');
  lines.push('  // Build filter from scope');
  lines.push('  if (policy.scope) {');
  lines.push('    const filter: Record<string, unknown> = {};');
  lines.push('');
  lines.push('    for (const scope of policy.scope) {');
  lines.push('      const contextValue = context[scope.contextKey];');
  lines.push('');
  lines.push('      if (contextValue === undefined) {');
  lines.push('        return {');
  lines.push('          allowed: false,');
  lines.push('          response: errorResponse(`Access denied: missing ${scope.contextKey}`, 403),');
  lines.push('        };');
  lines.push('      }');
  lines.push('');
  lines.push('      filter[scope.field] = contextValue;');
  lines.push('    }');
  lines.push('');
  lines.push('    return { allowed: true, filter };');
  lines.push('  }');
  lines.push('');
  lines.push('  return { allowed: true };');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate custom middleware for Supabase Edge
 */
export function generateCustomMiddlewareEdge(analyzed: AnalyzedMiddleware): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    `// Custom middleware: ${analyzed.name}`,
    '',
    "import { corsHeaders } from '../../cors.ts';",
    '',
  ];

  // Generate config type if middleware has config
  if (analyzed.configFields.length > 0) {
    lines.push('/**');
    lines.push(` * ${analyzed.name} middleware config`);
    lines.push(' */');
    lines.push(`export interface ${pascalCase(analyzed.name)}Config {`);
    for (const field of analyzed.configFields) {
      const optional = field.defaultValue !== undefined ? '?' : '';
      lines.push(`  ${field.name}${optional}: ${field.type};`);
    }
    lines.push('}');
    lines.push('');

    // Generate default config
    lines.push(`const defaultConfig: ${pascalCase(analyzed.name)}Config = {`);
    for (const field of analyzed.configFields) {
      if (field.defaultValue !== undefined) {
        lines.push(`  ${field.name}: ${JSON.stringify(field.defaultValue)},`);
      }
    }
    lines.push('};');
    lines.push('');
  }

  lines.push('/**');
  lines.push(` * ${analyzed.name} middleware context`);
  lines.push(' */');
  lines.push('export interface MiddlewareContext {');
  lines.push('  request: Request;');
  lines.push('  headers: Record<string, string | null>;');
  lines.push('  context: Record<string, unknown>;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(` * ${analyzed.name} middleware result`);
  lines.push(' */');
  lines.push(`export interface ${pascalCase(analyzed.name)}Result {`);
  lines.push('  error: boolean;');
  lines.push('  response?: Response;');
  lines.push('  context?: Record<string, unknown>;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Create a JSON error response');
  lines.push(' */');
  lines.push('function errorResponse(message: string, status: number): Response {');
  lines.push('  return new Response(JSON.stringify({ error: message }), {');
  lines.push('    status,');
  lines.push("    headers: { 'Content-Type': 'application/json', ...corsHeaders() },");
  lines.push('  });');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(` * ${analyzed.name} middleware`);
  if (analyzed.description) {
    lines.push(` * ${analyzed.description}`);
  }
  lines.push(' */');

  // Generate the middleware function
  const hasConfig = analyzed.configFields.length > 0;
  if (hasConfig) {
    lines.push(`export async function ${analyzed.name}Middleware(`);
    lines.push('  req: Request,');
    lines.push(`  userConfig?: Partial<${pascalCase(analyzed.name)}Config>,`);
    lines.push('  existingContext?: Record<string, unknown>');
    lines.push(`): Promise<${pascalCase(analyzed.name)}Result> {`);
    lines.push('  const config = { ...defaultConfig, ...userConfig };');
  } else {
    lines.push(`export async function ${analyzed.name}Middleware(`);
    lines.push('  req: Request,');
    lines.push('  existingContext?: Record<string, unknown>');
    lines.push(`): Promise<${pascalCase(analyzed.name)}Result> {`);
  }

  lines.push('');
  lines.push('  // Build middleware context');
  lines.push('  const headers: Record<string, string | null> = {};');
  lines.push('  req.headers.forEach((value, key) => {');
  lines.push('    headers[key.toLowerCase()] = value;');
  lines.push('  });');
  lines.push('');
  lines.push('  const ctx: MiddlewareContext = {');
  lines.push('    request: req,');
  lines.push('    headers,');
  lines.push('    context: existingContext || {},');
  lines.push('  };');
  lines.push('');

  // Inject the handler code
  if (analyzed.handlerCode) {
    lines.push('  // Custom handler (adapted from defineMiddleware)');
    lines.push('  try {');
    lines.push('    const handlerResult = await (async () => {');
    lines.push('      ' + analyzed.handlerCode.split('\n').join('\n      '));
    lines.push('    })();');
    lines.push('');
    lines.push("    if (typeof handlerResult === 'object' && handlerResult !== null) {");
    lines.push('      Object.assign(ctx.context, handlerResult);');
    lines.push('    }');
    lines.push('');
    lines.push('    return { error: false, context: ctx.context };');
    lines.push('  } catch (err) {');
    lines.push('    const error = err as { message?: string; status?: number };');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: errorResponse(error.message || 'Middleware error', error.status || 500),");
    lines.push('    };');
    lines.push('  }');
  } else {
    lines.push('  // No handler code - pass through');
    lines.push('  return { error: false, context: ctx.context };');
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate validation middleware for Supabase Edge
 */
export function generateValidationEdge(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '// Validation middleware for Supabase Edge Functions',
    '',
    '/**',
    ' * Validation error type',
    ' */',
    'export interface ValidationError {',
    '  field: string;',
    '  message: string;',
    '}',
    '',
    '/**',
    ' * Validation result type',
    ' */',
    'export interface ValidationResult<T = unknown> {',
    '  valid: boolean;',
    '  errors?: ValidationError[];',
    '  data?: T;',
    '}',
    '',
    '/**',
    ' * Email validation regex',
    ' */',
    'const EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
    '',
    '/**',
    ' * URL validation regex',
    ' */',
    'const URL_REGEX = /^https?:\\/\\/.+/;',
    '',
  ];

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} creation data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}(data: unknown): ValidationResult {`);
    lines.push("  const errors: ValidationError[] = [];");
    lines.push("");
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push("  }");
    lines.push("");
    lines.push("  const obj = data as Record<string, unknown>;");
    lines.push("");

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const isRequired = !field.nullable && !field.hasDefault;

      if (isRequired) {
        lines.push(`  if (obj.${field.name} === undefined || obj.${field.name} === null) {`);
        lines.push(`    errors.push({ field: '${field.name}', message: '${field.name} is required' });`);
        lines.push("  }");
      }

      lines.push(`  if (obj.${field.name} !== undefined && obj.${field.name} !== null) {`);

      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        lines.push(`    if (typeof obj.${field.name} !== 'string') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a string' });`);
        lines.push("    }");

        if (field.type === 'email') {
          lines.push(`    else if (!EMAIL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`      errors.push({ field: '${field.name}', message: 'Invalid email format' });`);
          lines.push("    }");
        }

        if (field.type === 'url') {
          lines.push(`    else if (!URL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`      errors.push({ field: '${field.name}', message: 'Invalid URL format' });`);
          lines.push("    }");
        }
      } else if (field.type === 'int' || field.type === 'float' || field.type === 'number') {
        lines.push(`    if (typeof obj.${field.name} !== 'number') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a number' });`);
        lines.push("    }");
      } else if (field.type === 'boolean') {
        lines.push(`    if (typeof obj.${field.name} !== 'boolean') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a boolean' });`);
        lines.push("    }");
      } else if (field.isEnum && field.enumValues) {
        const enumVals = field.enumValues.map((v) => `'${v}'`).join(', ');
        lines.push(`    if (![${enumVals}].includes(obj.${field.name} as string)) {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be one of: ${field.enumValues.join(', ')}' });`);
        lines.push("    }");
      }

      lines.push("  }");
      lines.push("");
    }

    lines.push("  return errors.length > 0 ? { valid: false, errors } : { valid: true, data: obj };");
    lines.push("}");
    lines.push("");

    // Update validation
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} update data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}Update(data: unknown): ValidationResult {`);
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push("  }");
    lines.push("");
    lines.push(`  const fullValidation = validate${schema.pascalName}(data);`);
    lines.push("  const updateErrors = fullValidation.errors?.filter(");
    lines.push("    (err) => !err.message.includes('is required')");
    lines.push("  ) || [];");
    lines.push("");
    lines.push("  return updateErrors.length > 0 ? { valid: false, errors: updateErrors } : { valid: true, data };");
    lines.push("}");
    lines.push("");
  }

  return lines.join('\n');
}

/**
 * Helper to convert string to PascalCase
 */
function pascalCase(str: string): string {
  return str
    .replace(/[-_](\w)/g, (_, c) => c.toUpperCase())
    .replace(/^(\w)/, (_, c) => c.toUpperCase());
}
