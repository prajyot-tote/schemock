/**
 * Supabase Edge Middleware Chain Template
 *
 * Generates middleware chain coordination for Supabase Edge Functions.
 *
 * @module cli/generators/supabase-edge/middleware-chain-template
 * @category CLI
 */

import type {
  SchemockConfig,
  MiddlewareConfig,
  AnalyzedMiddleware,
  AuthMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
} from '../../types';

/**
 * Default middleware execution order
 */
const DEFAULT_MIDDLEWARE_ORDER = [
  'auth',
  'rateLimit',
  'logger',
  'context',
  'rls',
  'cache',
  'validation',
];

/**
 * Generate the middleware chain file for Supabase Edge
 */
export function generateEdgeMiddlewareChain(
  config: SchemockConfig,
  customMiddleware: AnalyzedMiddleware[] = []
): string {
  const middleware = config.middleware ?? {};
  const enabledMiddleware = getEnabledMiddleware(middleware);
  const orderedMiddleware = orderMiddleware(enabledMiddleware, middleware.chain, customMiddleware);

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '// Middleware chain for Supabase Edge Functions',
    '',
    "import { corsHeaders } from '../cors.ts';",
    '',
  ];

  // Generate imports for each enabled middleware
  const imports = generateMiddlewareImports(orderedMiddleware, customMiddleware);
  lines.push(...imports);

  lines.push('');
  lines.push('/**');
  lines.push(' * Middleware context passed through the chain');
  lines.push(' */');
  lines.push('export interface MiddlewareChainContext {');
  lines.push('  userId?: string;');
  lines.push('  email?: string;');
  lines.push('  role?: string;');
  lines.push('  tenantId?: string;');
  lines.push('  jwt?: string;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Middleware chain result');
  lines.push(' */');
  lines.push('export interface MiddlewareChainResult {');
  lines.push('  error: boolean;');
  lines.push('  response?: Response;');
  lines.push('  context: MiddlewareChainContext;');
  lines.push('  /** Function to call after request completes (for logging, headers, etc) */');
  lines.push('  onComplete?: (status: number) => void;');
  lines.push('}');
  lines.push('');

  // Generate the runMiddlewareChain function
  lines.push('/**');
  lines.push(' * Run all configured middleware in order');
  lines.push(' *');
  lines.push(' * Middleware execution order:');
  for (const name of orderedMiddleware) {
    lines.push(` *   - ${name}`);
  }
  lines.push(' *');
  lines.push(' * @param req - Deno Request object');
  lines.push(' * @param entity - Entity name for RLS filtering (optional)');
  lines.push(' * @param operation - RLS operation type (optional)');
  lines.push(' * @returns Middleware chain result with context or error response');
  lines.push(' */');
  lines.push('export async function runMiddlewareChain(');
  lines.push('  req: Request,');
  lines.push('  entity?: string,');
  lines.push("  operation?: 'select' | 'insert' | 'update' | 'delete'");
  lines.push('): Promise<MiddlewareChainResult> {');
  lines.push('  const context: MiddlewareChainContext = {};');
  lines.push('  const completionHandlers: Array<(status: number) => void> = [];');
  lines.push('');

  if (orderedMiddleware.length === 0) {
    lines.push('  // No middleware configured');
    lines.push('  return { error: false, context };');
  } else {
    // Generate middleware calls in order
    for (const name of orderedMiddleware) {
      lines.push(`  // ${name} middleware`);

      if (name === 'auth') {
        lines.push('  const authResult = await authMiddleware(req);');
        lines.push('  if (authResult.error) {');
        lines.push('    return { error: true, response: authResult.response, context };');
        lines.push('  }');
        lines.push('  if (authResult.context) {');
        lines.push('    context.userId = authResult.context.userId;');
        lines.push('    context.email = authResult.context.email;');
        lines.push('    context.role = authResult.context.role;');
        lines.push('    context.jwt = authResult.context.jwt;');
        lines.push('    Object.assign(context, authResult.context);');
        lines.push('  }');
      } else if (name === 'rateLimit') {
        lines.push('  const rateLimitResult = rateLimitMiddleware(req, context.userId);');
        lines.push('  if (rateLimitResult.error) {');
        lines.push('    return { error: true, response: rateLimitResult.response, context };');
        lines.push('  }');
        lines.push('  // Store rate limit info for response headers');
        lines.push('  if (rateLimitResult.remaining !== undefined) {');
        lines.push("    context['_rateLimit'] = {");
        lines.push('      remaining: rateLimitResult.remaining,');
        lines.push('      resetTime: rateLimitResult.resetTime,');
        lines.push('    };');
        lines.push('  }');
      } else if (name === 'logger') {
        lines.push('  const logger = loggerMiddleware(req, context.userId);');
        lines.push('  completionHandlers.push((status) => {');
        lines.push('    logger.finish(status);');
        lines.push('  });');
      } else if (name === 'context') {
        lines.push('  const extractedContext = contextMiddleware(req);');
        lines.push('  Object.assign(context, extractedContext);');
      } else if (name === 'rls') {
        lines.push('  if (entity && operation) {');
        lines.push('    const rlsResult = applyRLSFilter(entity, operation, context);');
        lines.push('    if (!rlsResult.allowed) {');
        lines.push('      return { error: true, response: rlsResult.response, context };');
        lines.push('    }');
        lines.push('    if (rlsResult.filter) {');
        lines.push("      context['rlsFilter'] = rlsResult.filter;");
        lines.push('    }');
        lines.push('  }');
      } else if (name === 'cache') {
        lines.push('  const cacheResult = cacheMiddleware(req, context.userId);');
        lines.push('  if (cacheResult.hit) {');
        lines.push('    // Return cached response');
        lines.push('    const cachedResponse = new Response(JSON.stringify(cacheResult.data), {');
        lines.push('      status: 200,');
        lines.push('      headers: {');
        lines.push("        'Content-Type': 'application/json',");
        lines.push("        'X-Cache': 'HIT',");
        lines.push('        ...corsHeaders(),');
        lines.push('      },');
        lines.push('    });');
        lines.push('    return { error: false, context, response: cachedResponse };');
        lines.push('  }');
      } else {
        // Custom middleware
        const customMw = customMiddleware.find((m) => m.name === name);
        if (customMw) {
          const handlerName = `${name}Middleware`;
          lines.push(`  const ${name}Result = await ${handlerName}(req, context);`);
          lines.push(`  if (${name}Result.error) {`);
          lines.push(`    return { error: true, response: ${name}Result.response, context };`);
          lines.push('  }');
          lines.push(`  if (${name}Result.context) {`);
          lines.push(`    Object.assign(context, ${name}Result.context);`);
          lines.push('  }');
        }
      }

      lines.push('');
    }

    // Generate the onComplete function
    lines.push('  // Build onComplete handler from completion handlers');
    lines.push('  const onComplete = completionHandlers.length > 0');
    lines.push('    ? (status: number) => {');
    lines.push('        for (const handler of completionHandlers) {');
    lines.push('          handler(status);');
    lines.push('        }');
    lines.push('      }');
    lines.push('    : undefined;');
    lines.push('');
    lines.push('  return { error: false, context, onComplete };');
  }

  lines.push('}');
  lines.push('');

  // Export individual middleware for selective use
  lines.push('/**');
  lines.push(' * Individual middleware exports for selective use');
  lines.push(' */');
  lines.push('export const middleware = {');
  for (const name of orderedMiddleware) {
    const handlerName = getMiddlewareHandlerName(name);
    lines.push(`  ${name}: ${handlerName},`);
  }
  lines.push('} as const;');
  lines.push('');

  // Export the ordered list
  lines.push('/**');
  lines.push(' * Middleware execution order');
  lines.push(' */');
  lines.push(`export const middlewareOrder = ${JSON.stringify(orderedMiddleware)} as const;`);
  lines.push('');

  return lines.join('\n');
}

/**
 * Get list of enabled middleware from config
 */
function getEnabledMiddleware(config: MiddlewareConfig): string[] {
  const enabled: string[] = [];

  if (config.auth) enabled.push('auth');
  if (config.rateLimit) enabled.push('rateLimit');
  if (config.logger) enabled.push('logger');
  if (config.context) enabled.push('context');
  if (config.rls) enabled.push('rls');
  if (config.cache) enabled.push('cache');
  if (config.validation) enabled.push('validation');

  return enabled;
}

/**
 * Order middleware based on config.chain or default order
 */
function orderMiddleware(
  enabled: string[],
  customOrder?: string[],
  customMiddleware: AnalyzedMiddleware[] = []
): string[] {
  const earlyCustom = customMiddleware.filter((m) => m.order === 'early').map((m) => m.name);
  const normalCustom = customMiddleware.filter((m) => m.order === 'normal').map((m) => m.name);
  const lateCustom = customMiddleware.filter((m) => m.order === 'late').map((m) => m.name);

  if (customOrder && customOrder.length > 0) {
    const allEnabled = new Set([...enabled, ...customMiddleware.map((m) => m.name)]);
    return customOrder.filter((name) => allEnabled.has(name));
  }

  const ordered: string[] = [];

  ordered.push(...earlyCustom.filter((n) => !enabled.includes(n)));

  for (const name of DEFAULT_MIDDLEWARE_ORDER) {
    if (enabled.includes(name)) {
      ordered.push(name);
    }
  }

  ordered.push(...normalCustom.filter((n) => !enabled.includes(n)));
  ordered.push(...lateCustom.filter((n) => !enabled.includes(n)));

  return ordered;
}

/**
 * Generate import statements for middleware
 */
function generateMiddlewareImports(
  orderedMiddleware: string[],
  customMiddleware: AnalyzedMiddleware[]
): string[] {
  const lines: string[] = [];
  const customNames = new Set(customMiddleware.map((m) => m.name));

  // Track what we need to import from each file
  const authImports: string[] = [];
  const rateLimitImports: string[] = [];
  const cacheImports: string[] = [];
  const loggerImports: string[] = [];
  const contextImports: string[] = [];
  const rlsImports: string[] = [];

  for (const name of orderedMiddleware) {
    if (customNames.has(name)) continue;

    switch (name) {
      case 'auth':
        authImports.push('authMiddleware');
        break;
      case 'rateLimit':
        rateLimitImports.push('rateLimitMiddleware');
        break;
      case 'cache':
        cacheImports.push('cacheMiddleware', 'setCacheEntry');
        break;
      case 'logger':
        loggerImports.push('loggerMiddleware');
        break;
      case 'context':
        contextImports.push('contextMiddleware');
        break;
      case 'rls':
        rlsImports.push('applyRLSFilter');
        break;
    }
  }

  // Generate import statements with .ts extension for Deno
  if (authImports.length > 0) {
    lines.push(`import { ${authImports.join(', ')} } from './auth.ts';`);
  }
  if (rateLimitImports.length > 0) {
    lines.push(`import { ${rateLimitImports.join(', ')} } from './rate-limit.ts';`);
  }
  if (cacheImports.length > 0) {
    lines.push(`import { ${cacheImports.join(', ')} } from './cache.ts';`);
  }
  if (loggerImports.length > 0) {
    lines.push(`import { ${loggerImports.join(', ')} } from './logger.ts';`);
  }
  if (contextImports.length > 0) {
    lines.push(`import { ${contextImports.join(', ')} } from './context.ts';`);
  }
  if (rlsImports.length > 0) {
    lines.push(`import { ${rlsImports.join(', ')} } from './rls.ts';`);
  }

  // Custom middleware imports
  for (const mw of customMiddleware) {
    if (orderedMiddleware.includes(mw.name)) {
      const handlerName = `${mw.name}Middleware`;
      lines.push(`import { ${handlerName} } from './custom/${mw.name}.ts';`);
    }
  }

  return lines;
}

/**
 * Get the handler function name for a middleware
 */
function getMiddlewareHandlerName(name: string): string {
  const camelCase = name.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
  return `${camelCase}Middleware`;
}

/**
 * Normalize middleware config helpers
 */
export function normalizeAuthConfig(
  config: AuthMiddlewareConfig | boolean | undefined
): AuthMiddlewareConfig | undefined {
  if (!config) return undefined;
  if (config === true) {
    return { provider: 'supabase-auth', required: true };
  }
  return config;
}

export function normalizeLoggerConfig(
  config: LoggerMiddlewareConfig | boolean | undefined
): LoggerMiddlewareConfig | undefined {
  if (!config) return undefined;
  if (config === true) {
    return { level: 'info' };
  }
  return config;
}

export function normalizeCacheConfig(
  config: CacheMiddlewareConfig | boolean | undefined
): CacheMiddlewareConfig | undefined {
  if (!config) return undefined;
  if (config === true) {
    return { ttl: 300000, operations: ['findOne', 'findMany'] };
  }
  return config;
}
