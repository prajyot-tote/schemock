/**
 * Neon Library Templates
 *
 * Generates the Neon Serverless database client and utilities.
 *
 * @module cli/generators/neon/lib-template
 * @category CLI
 */

import type { GenerationTarget, SchemockConfig } from '../../types';

/**
 * Generate all library files for the Neon target
 */
export function generateNeonLibFiles(
  target: GenerationTarget,
  _config: SchemockConfig
): Record<string, string> {
  const files: Record<string, string> = {};

  // Generate main database client
  files['db.ts'] = generateNeonDb(target);

  return files;
}

/**
 * Generate Neon database client
 *
 * Neon provides two connection methods:
 * 1. HTTP (neon function) - Best for serverless, one query per request
 * 2. WebSocket (Pool) - Best for long-running connections with multiple queries
 *
 * This generator defaults to HTTP for optimal serverless performance.
 */
function generateNeonDb(target: GenerationTarget): string {
  const envVar = (target.options?.connectionEnvVar as string) || 'DATABASE_URL';
  const usePool = target.options?.usePool === true;

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '/**',
    ' * Neon Serverless PostgreSQL Client',
    ' *',
    ' * Uses @neondatabase/serverless for optimal edge/serverless performance.',
    ' * Two connection methods are available:',
    ' * - `sql` (HTTP): One query per request, best for serverless',
    ' * - `getPool()` (WebSocket): Connection pool for multiple queries',
    ' */',
    '',
    "import { neon, neonConfig, Pool } from '@neondatabase/serverless';",
    '',
    '// Configure Neon for optimal serverless performance',
    'neonConfig.fetchConnectionCache = true;',
    '',
    `const connectionString = process.env.${envVar};`,
    '',
    'if (!connectionString) {',
    `  throw new Error('Missing ${envVar} environment variable');`,
    '}',
    '',
    '/**',
    ' * SQL tagged template function for database queries',
    ' *',
    ' * Uses Neon HTTP driver - best for serverless/edge environments.',
    ' * Each query is a single HTTP request with automatic connection management.',
    ' *',
    ' * @example',
    " * const users = await sql`SELECT * FROM users WHERE active = ${true}`;",
    ' * const user = await sql`SELECT * FROM users WHERE id = ${userId}`;',
    ' */',
    'export const sql = neon(connectionString);',
    '',
    '/**',
    ' * Re-export neon function for dynamic queries',
    ' *',
    ' * Use this when you need to build queries dynamically',
    ' * (e.g., dynamic column names in UPDATE statements)',
    ' */',
    'export { neon };',
    '',
  ];

  if (usePool) {
    lines.push('/**');
    lines.push(' * Connection pool for WebSocket connections');
    lines.push(' *');
    lines.push(' * Use this when you need multiple queries in a single request');
    lines.push(' * or when using transactions.');
    lines.push(' *');
    lines.push(' * @example');
    lines.push(' * const pool = getPool();');
    lines.push(' * const client = await pool.connect();');
    lines.push(' * try {');
    lines.push("  *   await client.query('BEGIN');");
    lines.push("  *   await client.query('INSERT INTO ...');");
    lines.push("  *   await client.query('COMMIT');");
    lines.push(' * } finally {');
    lines.push(' *   client.release();');
    lines.push(' * }');
    lines.push(' */');
    lines.push('let pool: Pool | null = null;');
    lines.push('');
    lines.push('export function getPool(): Pool {');
    lines.push('  if (!pool) {');
    lines.push('    pool = new Pool({ connectionString });');
    lines.push('  }');
    lines.push('  return pool;');
    lines.push('}');
  } else {
    lines.push('/**');
    lines.push(' * Get a connection pool for WebSocket connections');
    lines.push(' *');
    lines.push(' * Creates a new Pool instance on demand. For serverless environments,');
    lines.push(' * prefer using `sql` (HTTP) unless you need transactions.');
    lines.push(' *');
    lines.push(' * Note: Pool connections use WebSockets, which may not be available');
    lines.push(' * in all edge environments (e.g., Cloudflare Workers).');
    lines.push(' *');
    lines.push(' * @example');
    lines.push(' * const pool = getPool();');
    lines.push(' * const client = await pool.connect();');
    lines.push(' * try {');
    lines.push("  *   await client.query('BEGIN');");
    lines.push("  *   // ... multiple queries");
    lines.push("  *   await client.query('COMMIT');");
    lines.push(' * } finally {');
    lines.push(' *   client.release();');
    lines.push(' * }');
    lines.push(' */');
    lines.push('export function getPool(): Pool {');
    lines.push('  return new Pool({ connectionString });');
    lines.push('}');
  }

  lines.push('');
  lines.push('/**');
  lines.push(' * Execute multiple queries in a transaction');
  lines.push(' *');
  lines.push(' * @example');
  lines.push(' * await withTransaction(async (client) => {');
  lines.push("  *   await client.query('INSERT INTO orders ...');");
  lines.push("  *   await client.query('UPDATE inventory ...');");
  lines.push(' * });');
  lines.push(' */');
  lines.push('export async function withTransaction<T>(');
  lines.push('  fn: (client: { query: (sql: string, params?: unknown[]) => Promise<{ rows: unknown[] }> }) => Promise<T>');
  lines.push('): Promise<T> {');
  lines.push('  const pool = getPool();');
  lines.push('  const client = await pool.connect();');
  lines.push('');
  lines.push('  try {');
  lines.push("    await client.query('BEGIN');");
  lines.push('    const result = await fn(client);');
  lines.push("    await client.query('COMMIT');");
  lines.push('    return result;');
  lines.push('  } catch (error) {');
  lines.push("    await client.query('ROLLBACK');");
  lines.push('    throw error;');
  lines.push('  } finally {');
  lines.push('    client.release();');
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}
