/**
 * Neon Middleware Chain Template
 *
 * Generates the middleware chain coordinator for Neon Serverless backend.
 *
 * @module cli/generators/neon/middleware-chain-template
 * @category CLI
 */

import type {
  SchemockConfig,
  AnalyzedMiddleware,
  AuthMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
  AuthProviderConfig,
} from '../../types';

/**
 * Normalize auth config from various formats
 */
export function normalizeAuthConfig(
  auth: AuthMiddlewareConfig | boolean | AuthProviderConfig | undefined
): AuthMiddlewareConfig | null {
  if (!auth) return null;

  if (auth === true) {
    return { provider: 'jwt', required: true };
  }

  if (typeof auth === 'object') {
    // Already AuthMiddlewareConfig or AuthProviderConfig
    return {
      provider: auth.provider || 'jwt',
      required: (auth as AuthMiddlewareConfig).required ?? true,
      secretEnvVar: auth.secretEnvVar,
      customHandler: auth.customHandler,
      skip: (auth as AuthMiddlewareConfig).skip,
    };
  }

  return null;
}

/**
 * Normalize cache config from various formats
 */
export function normalizeCacheConfig(
  cache: CacheMiddlewareConfig | boolean | undefined
): CacheMiddlewareConfig | null {
  if (!cache) return null;

  if (cache === true) {
    return { ttl: 300000, operations: ['findOne', 'findMany'] };
  }

  return cache;
}

/**
 * Normalize logger config from various formats
 */
export function normalizeLoggerConfig(
  logger: LoggerMiddlewareConfig | boolean | undefined
): LoggerMiddlewareConfig | null {
  if (!logger) return null;

  if (logger === true) {
    return { level: 'info', includeBody: false, includeResponse: false };
  }

  return logger;
}

/**
 * Generate the middleware chain coordinator
 */
export function generateNeonMiddlewareChain(
  config: SchemockConfig,
  customMiddleware: AnalyzedMiddleware[] = []
): string {
  const mwConfig = config.middleware;
  if (!mwConfig) {
    return `// GENERATED BY SCHEMOCK - DO NOT EDIT

import type { Router, Request, Response, NextFunction } from 'express';

export const middlewareOrder: string[] = [];
export const middleware: Record<string, (req: Request, res: Response, next: NextFunction) => void> = {};

export function applyMiddleware(_router: Router, _skipAuth?: string[]): void {
  // No middleware configured
}
`;
  }

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Router, Request, Response, NextFunction } from 'express';",
    '',
  ];

  // Import individual middleware
  if (mwConfig.auth) {
    lines.push("import { authMiddleware } from './auth';");
  }
  if (mwConfig.rateLimit) {
    lines.push("import { rateLimitMiddleware } from './rate-limit';");
  }
  if (mwConfig.cache) {
    lines.push("import { cacheMiddleware } from './cache';");
  }
  if (mwConfig.logger) {
    lines.push("import { loggerMiddleware } from './logger';");
  }
  if (mwConfig.context) {
    lines.push("import { contextMiddleware } from './context';");
  }
  if (mwConfig.rls) {
    lines.push("import { rlsMiddleware } from './rls';");
  }

  // Import custom middleware
  for (const mw of customMiddleware) {
    lines.push(`import { ${mw.name}Middleware } from './custom/${mw.name}';`);
  }

  lines.push('');

  // Determine middleware order
  const defaultOrder = ['logger', 'rateLimit', 'auth', 'context', 'rls', 'cache'];
  const order = mwConfig.chain || defaultOrder;

  // Filter to only enabled middleware
  const enabledMiddleware = order.filter((name) => {
    if (name === 'auth') return !!mwConfig.auth;
    if (name === 'rateLimit') return !!mwConfig.rateLimit;
    if (name === 'cache') return !!mwConfig.cache;
    if (name === 'logger') return !!mwConfig.logger;
    if (name === 'context') return !!mwConfig.context;
    if (name === 'rls') return !!mwConfig.rls;
    // Check custom middleware
    return customMiddleware.some((mw) => mw.name === name);
  });

  lines.push('/**');
  lines.push(' * Middleware execution order');
  lines.push(' */');
  lines.push(`export const middlewareOrder = ${JSON.stringify(enabledMiddleware)};`);
  lines.push('');

  // Map middleware names to functions
  lines.push('/**');
  lines.push(' * Available middleware functions');
  lines.push(' */');
  lines.push('export const middleware: Record<string, (req: Request, res: Response, next: NextFunction) => void> = {');

  if (mwConfig.auth) {
    lines.push('  auth: authMiddleware as (req: Request, res: Response, next: NextFunction) => void,');
  }
  if (mwConfig.rateLimit) {
    lines.push('  rateLimit: rateLimitMiddleware,');
  }
  if (mwConfig.cache) {
    lines.push('  cache: cacheMiddleware,');
  }
  if (mwConfig.logger) {
    lines.push('  logger: loggerMiddleware,');
  }
  if (mwConfig.context) {
    lines.push('  context: contextMiddleware,');
  }
  if (mwConfig.rls) {
    lines.push('  rls: rlsMiddleware,');
  }

  // Add custom middleware
  for (const mw of customMiddleware) {
    const hasConfig = mw.configFields.length > 0;
    if (hasConfig) {
      lines.push(`  ${mw.name}: ${mw.name}Middleware(),`);
    } else {
      lines.push(`  ${mw.name}: ${mw.name}Middleware,`);
    }
  }

  lines.push('};');
  lines.push('');

  // Generate path matching helper for skip patterns
  if (mwConfig.auth && normalizeAuthConfig(mwConfig.auth)?.skip?.length) {
    lines.push('/**');
    lines.push(' * Check if path matches skip patterns');
    lines.push(' */');
    lines.push('function shouldSkipAuth(path: string, skipPatterns: string[]): boolean {');
    lines.push('  return skipPatterns.some(pattern => {');
    lines.push("    if (pattern.endsWith('*')) {");
    lines.push('      return path.startsWith(pattern.slice(0, -1));');
    lines.push('    }');
    lines.push('    return path === pattern;');
    lines.push('  });');
    lines.push('}');
    lines.push('');
  }

  // Generate applyMiddleware function
  lines.push('/**');
  lines.push(' * Apply middleware chain to router');
  lines.push(' * @param router - Express router to apply middleware to');
  lines.push(' * @param skipAuth - Additional paths to skip auth for');
  lines.push(' */');
  lines.push('export function applyMiddleware(router: Router, skipAuth?: string[]): void {');

  const authConfig = mwConfig.auth ? normalizeAuthConfig(mwConfig.auth) : null;
  const configSkipPaths = authConfig?.skip || [];

  lines.push(`  const skipPaths = [...${JSON.stringify(configSkipPaths)}, ...(skipAuth || [])];`);
  lines.push('');

  // Apply middleware in order
  for (const name of enabledMiddleware) {
    if (name === 'auth' && authConfig) {
      // Auth with skip paths
      lines.push('  // Auth middleware with skip paths');
      lines.push('  router.use((req, res, next) => {');
      lines.push('    if (shouldSkipAuth(req.path, skipPaths)) {');
      lines.push('      return next();');
      lines.push('    }');
      lines.push('    return middleware.auth(req, res, next);');
      lines.push('  });');
    } else {
      lines.push(`  router.use(middleware.${name});`);
    }
  }

  lines.push('}');

  // Add shouldSkipAuth helper if needed
  if (!mwConfig.auth || !normalizeAuthConfig(mwConfig.auth)?.skip?.length) {
    // Add the helper anyway for runtime skip paths
    lines.push('');
    lines.push('/**');
    lines.push(' * Check if path matches skip patterns');
    lines.push(' */');
    lines.push('function shouldSkipAuth(path: string, skipPatterns: string[]): boolean {');
    lines.push('  return skipPatterns.some(pattern => {');
    lines.push("    if (pattern.endsWith('*')) {");
    lines.push('      return path.startsWith(pattern.slice(0, -1));');
    lines.push('    }');
    lines.push('    return path === pattern;');
    lines.push('  });');
    lines.push('}');
  }

  return lines.join('\n');
}
