/**
 * Neon Handler Templates
 *
 * Generates handler files for Neon Serverless PostgreSQL.
 * Uses @neondatabase/serverless for optimal edge/serverless performance.
 *
 * @module cli/generators/neon/handler-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget, SchemockConfig } from '../../types';

/**
 * Generate handler file for an entity using Neon Serverless
 */
export function generateHandlerFile(
  schema: AnalyzedSchema,
  target: GenerationTarget,
  _config: SchemockConfig
): string {
  const hasValidation = target.middleware?.validation === true;

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    "import { sql } from '../db';",
  ];

  // Import types (using the naming convention from types generator: UserCreate, UserUpdate)
  lines.push(`import type { ${schema.pascalName}, ${schema.pascalName}Create, ${schema.pascalName}Update } from '../types';`);

  // Import validation if enabled
  if (hasValidation) {
    lines.push(`import { validate${schema.pascalName}, validate${schema.pascalName}Update } from '../middleware/validate';`);
  }

  lines.push('');

  // Helper for PostgreSQL error handling
  lines.push('/**');
  lines.push(' * Map PostgreSQL error codes to HTTP status');
  lines.push(' */');
  lines.push('function mapPgError(error: unknown): { status: number; message: string } {');
  lines.push('  const pgError = error as { code?: string; message?: string };');
  lines.push('  const code = pgError.code;');
  lines.push('');
  lines.push('  switch (code) {');
  lines.push("    case '23505': return { status: 409, message: 'Duplicate entry' };");
  lines.push("    case '23503': return { status: 400, message: 'Foreign key violation' };");
  lines.push("    case '23502': return { status: 400, message: 'Not null violation' };");
  lines.push("    case '23514': return { status: 400, message: 'Check constraint violation' };");
  lines.push("    case '42501': return { status: 403, message: 'Permission denied' };");
  lines.push("    case '42P01': return { status: 404, message: 'Table not found' };");
  lines.push("    default: return { status: 500, message: pgError.message || 'Database error' };");
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // List handler
  lines.push('/**');
  lines.push(` * GET /${schema.pluralName}`);
  lines.push(` * List all ${schema.pluralName}`);
  lines.push(' */');
  lines.push('export async function list(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push("    const limit = parseInt(req.query.limit as string || '20', 10);");
  lines.push("    const offset = parseInt(req.query.offset as string || '0', 10);");
  lines.push('');
  lines.push('    // Get total count');
  lines.push(`    const countResult = await sql\`SELECT COUNT(*) as total FROM ${schema.tableName}\`;`);
  lines.push("    const total = parseInt(String(countResult[0]?.total ?? '0'), 10);");
  lines.push('');
  lines.push('    // Get paginated data');
  lines.push(`    const data = await sql<${schema.pascalName}[]>\``);
  lines.push(`      SELECT * FROM ${schema.tableName}`);
  lines.push('      ORDER BY created_at DESC');
  lines.push('      LIMIT ${limit}');
  lines.push('      OFFSET ${offset}');
  lines.push('    `;');
  lines.push('');
  lines.push('    res.json({');
  lines.push('      data,');
  lines.push('      meta: { total, limit, offset }');
  lines.push('    });');
  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Get one handler
  lines.push('/**');
  lines.push(` * GET /${schema.pluralName}/:id`);
  lines.push(` * Get a single ${schema.singularName} by ID`);
  lines.push(' */');
  lines.push('export async function getOne(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push('');
  lines.push(`    const result = await sql<${schema.pascalName}[]>\``);
  lines.push(`      SELECT * FROM ${schema.tableName} WHERE id = \${id}`);
  lines.push('    `;');
  lines.push('');
  lines.push('    if (result.length === 0) {');
  lines.push("      res.status(404).json({ error: 'Not found' });");
  lines.push('      return;');
  lines.push('    }');
  lines.push('');
  lines.push('    res.json(result[0]);');
  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Create handler
  const insertFields = schema.fields
    .filter((f) => !f.readOnly && f.name !== 'id' && !f.isComputed)
    .map((f) => f.name);

  lines.push('/**');
  lines.push(` * POST /${schema.pluralName}`);
  lines.push(` * Create a new ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function create(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push(`    const body = req.body as ${schema.pascalName}Create;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      res.status(400).json({ errors: validation.errors });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
  }

  // Generate dynamic INSERT with Neon's sql template
  lines.push('    // Extract values from body');
  lines.push('    const {');
  for (const field of insertFields) {
    lines.push(`      ${field},`);
  }
  lines.push('    } = body;');
  lines.push('');
  lines.push(`    const result = await sql<${schema.pascalName}[]>\``);
  lines.push(`      INSERT INTO ${schema.tableName} (`);
  lines.push(`        ${insertFields.join(', ')}`);
  lines.push('      ) VALUES (');
  lines.push(`        ${insertFields.map(f => `\${${f}}`).join(', ')}`);
  lines.push('      )');
  lines.push('      RETURNING *');
  lines.push('    `;');
  lines.push('');
  lines.push('    res.status(201).json(result[0]);');
  lines.push('  } catch (error) {');
  lines.push('    const pgErr = mapPgError(error);');
  lines.push('    if (pgErr.status !== 500) {');
  lines.push('      res.status(pgErr.status).json({ error: pgErr.message });');
  lines.push('      return;');
  lines.push('    }');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Update handler
  lines.push('/**');
  lines.push(` * PUT /${schema.pluralName}/:id`);
  lines.push(` * Update a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function update(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push(`    const body = req.body as ${schema.pascalName}Update;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}Update(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      res.status(400).json({ errors: validation.errors });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
  }

  // Generate dynamic UPDATE with Neon's sql template
  lines.push('    const entries = Object.entries(body).filter(([, v]) => v !== undefined);');
  lines.push('    if (entries.length === 0) {');
  lines.push("      res.status(400).json({ error: 'No fields to update' });");
  lines.push('      return;');
  lines.push('    }');
  lines.push('');
  lines.push('    // Build SET clause dynamically');
  lines.push('    // Note: Using raw SQL here because Neon sql template doesnt support dynamic columns');
  lines.push('    const setClauses = entries.map(([key], i) => `${key} = $${i + 1}`).join(", ");');
  lines.push('    const values = entries.map(([, val]) => val);');
  lines.push('');
  lines.push('    // Import neon for dynamic queries');
  lines.push("    const { neon } = await import('@neondatabase/serverless');");
  lines.push("    const dynamicSql = neon(process.env.DATABASE_URL!);");
  lines.push('');
  lines.push(`    const result = await dynamicSql(`);
  lines.push(`      \`UPDATE ${schema.tableName} SET \${setClauses}, updated_at = NOW() WHERE id = $\${values.length + 1} RETURNING *\`,`);
  lines.push('      [...values, id]');
  lines.push(`    ) as ${schema.pascalName}[];`);
  lines.push('');
  lines.push('    if (result.length === 0) {');
  lines.push("      res.status(404).json({ error: 'Not found' });");
  lines.push('      return;');
  lines.push('    }');
  lines.push('');
  lines.push('    res.json(result[0]);');
  lines.push('  } catch (error) {');
  lines.push('    const pgErr = mapPgError(error);');
  lines.push('    if (pgErr.status !== 500) {');
  lines.push('      res.status(pgErr.status).json({ error: pgErr.message });');
  lines.push('      return;');
  lines.push('    }');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Delete handler
  lines.push('/**');
  lines.push(` * DELETE /${schema.pluralName}/:id`);
  lines.push(` * Delete a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function remove(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push('');
  lines.push(`    const result = await sql\``);
  lines.push(`      DELETE FROM ${schema.tableName} WHERE id = \${id} RETURNING id`);
  lines.push('    `;');
  lines.push('');
  lines.push('    if (result.length === 0) {');
  lines.push("      res.status(404).json({ error: 'Not found' });");
  lines.push('      return;');
  lines.push('    }');
  lines.push('');
  lines.push('    res.status(204).send();');
  lines.push('  } catch (error) {');
  lines.push('    const pgErr = mapPgError(error);');
  lines.push('    if (pgErr.status !== 500) {');
  lines.push('      res.status(pgErr.status).json({ error: pgErr.message });');
  lines.push('      return;');
  lines.push('    }');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}
