/**
 * Neon Seed Handler Template
 *
 * Generates the `handlers/_seed.ts` file for production seeding via HTTP endpoint.
 * Uses @neondatabase/serverless for optimal edge/serverless performance.
 *
 * @module cli/generators/neon/seed-handler-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget, SchemockConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import {
  emitSeedRefHelpers,
  emitEntityOrderAndTableMap,
  emitSeedTypes,
  emitEscapeSQL,
  emitNeonKillSwitchHelpers,
  emitNeonInsertLogic,
} from '../shared/seed-handler-helpers';

/**
 * Generate the seed handler file for Neon Serverless targets
 *
 * @param schemas - Analyzed schemas (topologically sorted)
 * @param target - Target configuration
 * @param config - Schemock config
 * @returns Generated TypeScript code
 */
export function generateSeedHandlerFile(
  schemas: AnalyzedSchema[],
  target: GenerationTarget,
  config: SchemockConfig
): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  code.line("import type { Request, Response, NextFunction } from 'express';");
  code.line("import { sql } from '../db';");
  code.line();

  // Emit types
  emitSeedTypes(code);

  // Emit entity order and table name mapping
  emitEntityOrderAndTableMap(code, schemas);

  // Emit seed reference helpers
  emitSeedRefHelpers(code);

  // Emit escapeSQL helper for raw SQL
  emitEscapeSQL(code);

  // Emit kill switch helpers for Neon (raw SQL)
  emitNeonKillSwitchHelpers(code);

  // Generate the handler function
  generateHandlerFunction(code, config);

  return code.toString();
}

/**
 * Generate the main handler function
 */
function generateHandlerFunction(code: CodeBuilder, config: SchemockConfig): void {
  code.multiDocComment([
    'POST /_seed',
    '',
    'Production seed endpoint with secret validation and kill switch.',
    '',
    'Request body: { secret: string }',
    '',
    'This endpoint:',
    '1. Validates the secret from request body against seedConfig.secret',
    '2. Checks the kill switch (prevents re-seeding)',
    '3. Dynamically imports seed data from configured path',
    '4. Inserts data in topological order, resolving ref()/lookup() markers',
    '5. Sets kill switch on success',
    '',
    'Response codes:',
    '- 200: Seed successful',
    '- 400: Missing secret in request body',
    '- 401: Invalid secret',
    '- 409: Already seeded (kill switch active)',
    '- 500: Server error during seeding',
  ]);

  code.block(
    'export async function handler(req: Request, res: Response, next: NextFunction): Promise<void> {',
    () => {
      code.block('try {', () => {
        code.line('const { secret } = req.body || {};');
        code.line();

        // Validate secret is present
        code.block("if (!secret || typeof secret !== 'string') {", () => {
          code.line("res.status(400).json({ success: false, error: 'MISSING_SECRET' } as SeedResult);");
          code.line('return;');
        });
        code.line();

        // Dynamic import of seed data
        code.comment('Dynamic import of seed data');
        const seedDataPath = config.productionSeed?.dataPath || './src/seed-data';
        const cleanPath = seedDataPath.replace(/^\.\//, '').replace(/\.ts$/, '');
        code.line(`const seedModule = await import('../../${cleanPath}');`);
        code.line('const seedConfig: ProductionSeedData = seedModule.seedConfig ?? seedModule.default;');
        code.line();

        // Validate secret
        code.comment('1. Validate secret');
        code.block('if (secret !== seedConfig.secret) {', () => {
          code.line("res.status(401).json({ success: false, error: 'INVALID_SECRET' } as SeedResult);");
          code.line('return;');
        });
        code.line();

        // Check kill switch
        code.comment('2. Check kill switch');
        code.block('if (await isSeeded()) {', () => {
          code.line('const seededAt = await getSeededAt();');
          code.line('res.status(409).json({');
          code.line('  success: false,');
          code.line("  error: 'ALREADY_SEEDED',");
          code.line('  seededAt: seededAt ?? undefined,');
          code.line('} as SeedResult);');
          code.line('return;');
        });
        code.line();

        // Insert data in order
        code.comment('3. Insert data for each entity (ordered by dependencies)');
        code.line('const createdRecords = new Map<string, Record<string, unknown>[]>();');
        code.line();

        code.comment('Determine insertion order: entityOrder first, then any remaining keys');
        code.line('const orderedEntities = [');
        code.line('  ...entityOrder.filter((e) => e in seedConfig.data),');
        code.line('  ...Object.keys(seedConfig.data).filter((e) => !entityOrder.includes(e)),');
        code.line('];');
        code.line();

        // Emit Neon-specific INSERT logic
        emitNeonInsertLogic(code);
        code.line();

        // Set kill switch
        code.comment('4. Set kill switch');
        code.line('await setSeeded();');
        code.line('const seededAt = new Date();');
        code.line();

        code.line("console.log('\\u2713 Production data seeded via API');");
        code.line('res.json({ success: true, seededAt } as SeedResult);');
      }, '} catch (error) {');
      code.indent();
      code.line('next(error);');
      code.dedent();
      code.line('}');
    }
  );
}
