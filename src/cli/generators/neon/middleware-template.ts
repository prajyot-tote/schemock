/**
 * Neon Middleware Templates
 *
 * Generates Express-compatible middleware for Neon Serverless backend.
 *
 * @module cli/generators/neon/middleware-template
 * @category CLI
 */

import type {
  AnalyzedSchema,
  AnalyzedMiddleware,
  AuthMiddlewareConfig,
  RateLimitMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
} from '../../types';

/**
 * Generate auth middleware for Neon backend
 */
export function generateNeonAuthMiddleware(config: AuthMiddlewareConfig): string {
  const provider = config.provider;
  const secretEnvVar = config.secretEnvVar || 'JWT_SECRET';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
  ];

  if (provider === 'jwt') {
    lines.push("import { jwtVerify, importSPKI, importPKCS8 } from 'jose';");
    lines.push('');
    lines.push('/**');
    lines.push(' * JWT payload type');
    lines.push(' */');
    lines.push('export interface JWTPayload {');
    lines.push('  sub: string;');
    lines.push('  userId?: string;');
    lines.push('  email?: string;');
    lines.push('  role?: string;');
    lines.push('  iat?: number;');
    lines.push('  exp?: number;');
    lines.push('  [key: string]: unknown;');
    lines.push('}');
    lines.push('');
    lines.push('// Extend Express Request to include user');
    lines.push("declare module 'express' {");
    lines.push('  interface Request {');
    lines.push('    user?: JWTPayload;');
    lines.push('  }');
    lines.push('}');
    lines.push('');
    lines.push(`const JWT_SECRET = process.env.${secretEnvVar};`);
    lines.push('');
    lines.push('if (!JWT_SECRET) {');
    lines.push(`  throw new Error('Missing ${secretEnvVar} environment variable');`);
    lines.push('}');
    lines.push('');
    lines.push('/**');
    lines.push(' * JWT authentication middleware');
    lines.push(' */');
    lines.push('export async function authMiddleware(');
    lines.push('  req: Request,');
    lines.push('  res: Response,');
    lines.push('  next: NextFunction');
    lines.push('): Promise<void> {');
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push('');
    lines.push("  if (!authHeader?.startsWith('Bearer ')) {");
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push("  const token = authHeader.substring(7);");
    lines.push('');
    lines.push('  try {');
    lines.push('    const secret = new TextEncoder().encode(JWT_SECRET);');
    lines.push('    const { payload } = await jwtVerify(token, secret);');
    lines.push('    req.user = payload as JWTPayload;');
    lines.push('    next();');
    lines.push('  } catch (error) {');
    lines.push("    res.status(401).json({ error: 'Invalid or expired token' });");
    lines.push('  }');
    lines.push('}');
  } else if (provider === 'supabase-auth') {
    lines.push("import { createClient } from '@supabase/supabase-js';");
    lines.push('');
    lines.push('const supabaseUrl = process.env.SUPABASE_URL;');
    lines.push('const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;');
    lines.push('');
    lines.push('if (!supabaseUrl || !supabaseAnonKey) {');
    lines.push("  throw new Error('Missing Supabase environment variables');");
    lines.push('}');
    lines.push('');
    lines.push('const supabase = createClient(supabaseUrl, supabaseAnonKey);');
    lines.push('');
    lines.push('/**');
    lines.push(' * Supabase Auth middleware');
    lines.push(' */');
    lines.push('export async function authMiddleware(');
    lines.push('  req: Request,');
    lines.push('  res: Response,');
    lines.push('  next: NextFunction');
    lines.push('): Promise<void> {');
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push('');
    lines.push("  if (!authHeader?.startsWith('Bearer ')) {");
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push("  const token = authHeader.substring(7);");
    lines.push('');
    lines.push('  try {');
    lines.push('    const { data: { user }, error } = await supabase.auth.getUser(token);');
    lines.push('');
    lines.push('    if (error || !user) {');
    lines.push("      res.status(401).json({ error: 'Invalid or expired token' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    (req as any).user = { sub: user.id, email: user.email, ...user.user_metadata };');
    lines.push('    next();');
    lines.push('  } catch (error) {');
    lines.push("    res.status(401).json({ error: 'Authentication failed' });");
    lines.push('  }');
    lines.push('}');
  } else if (provider === 'clerk') {
    lines.push("import { ClerkExpressRequireAuth } from '@clerk/clerk-sdk-node';");
    lines.push('');
    lines.push('/**');
    lines.push(' * Clerk authentication middleware');
    lines.push(' */');
    lines.push('export const authMiddleware = ClerkExpressRequireAuth();');
  } else {
    lines.push('/**');
    lines.push(' * Custom authentication middleware');
    lines.push(' * Implement your own authentication logic');
    lines.push(' */');
    lines.push('export async function authMiddleware(');
    lines.push('  req: Request,');
    lines.push('  res: Response,');
    lines.push('  next: NextFunction');
    lines.push('): Promise<void> {');
    lines.push('  // TODO: Implement custom authentication');
    lines.push("  throw new Error('Custom auth not implemented');");
    lines.push('}');
  }

  return lines.join('\n');
}

/**
 * Generate rate limit middleware for Neon backend
 */
export function generateNeonRateLimitMiddleware(config: RateLimitMiddlewareConfig): string {
  const { max, windowMs } = config;

  return `// GENERATED BY SCHEMOCK - DO NOT EDIT

import type { Request, Response, NextFunction } from 'express';

/**
 * Simple in-memory rate limiter
 * For production, consider using Redis-based rate limiting
 */
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

const MAX_REQUESTS = ${max};
const WINDOW_MS = ${windowMs};

/**
 * Rate limiting middleware
 */
export function rateLimitMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const key = req.ip || req.headers['x-forwarded-for'] as string || 'unknown';
  const now = Date.now();

  let entry = rateLimitStore.get(key);

  if (!entry || now > entry.resetTime) {
    entry = { count: 1, resetTime: now + WINDOW_MS };
    rateLimitStore.set(key, entry);
  } else {
    entry.count++;
  }

  // Set rate limit headers
  res.setHeader('X-RateLimit-Limit', MAX_REQUESTS);
  res.setHeader('X-RateLimit-Remaining', Math.max(0, MAX_REQUESTS - entry.count));
  res.setHeader('X-RateLimit-Reset', Math.ceil(entry.resetTime / 1000));

  if (entry.count > MAX_REQUESTS) {
    res.status(429).json({ error: 'Too many requests' });
    return;
  }

  next();
}

// Cleanup old entries periodically
setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of rateLimitStore.entries()) {
    if (now > entry.resetTime) {
      rateLimitStore.delete(key);
    }
  }
}, WINDOW_MS);
`;
}

/**
 * Generate cache middleware for Neon backend
 */
export function generateNeonCacheMiddleware(config: CacheMiddlewareConfig): string {
  const { ttl, operations = ['findOne', 'findMany'] } = config;

  return `// GENERATED BY SCHEMOCK - DO NOT EDIT

import type { Request, Response, NextFunction } from 'express';

/**
 * Simple in-memory cache
 * For production, consider using Redis
 */
const cache = new Map<string, { data: unknown; expires: number }>();

const TTL = ${ttl};
const CACHED_OPERATIONS = ${JSON.stringify(operations)};

/**
 * Generate cache key from request
 */
function getCacheKey(req: Request): string {
  return \`\${req.method}:\${req.originalUrl}\`;
}

/**
 * Check if request method should be cached
 */
function shouldCache(req: Request): boolean {
  if (req.method !== 'GET') return false;

  // Check if this is a list or get operation
  const path = req.path;
  const isListOrGet = path.endsWith('s') || path.match(/\\/[^/]+$/);

  return isListOrGet;
}

/**
 * Caching middleware
 */
export function cacheMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  if (!shouldCache(req)) {
    next();
    return;
  }

  const key = getCacheKey(req);
  const cached = cache.get(key);

  if (cached && cached.expires > Date.now()) {
    res.setHeader('X-Cache', 'HIT');
    res.json(cached.data);
    return;
  }

  // Override res.json to cache the response
  const originalJson = res.json.bind(res);
  res.json = (data: unknown) => {
    cache.set(key, { data, expires: Date.now() + TTL });
    res.setHeader('X-Cache', 'MISS');
    return originalJson(data);
  };

  next();
}

/**
 * Invalidate cache entries matching a pattern
 */
export function invalidateCache(pattern?: string | RegExp): void {
  if (!pattern) {
    cache.clear();
    return;
  }

  const regex = typeof pattern === 'string' ? new RegExp(pattern) : pattern;
  for (const key of cache.keys()) {
    if (regex.test(key)) {
      cache.delete(key);
    }
  }
}

// Cleanup expired entries periodically
setInterval(() => {
  const now = Date.now();
  for (const [key, entry] of cache.entries()) {
    if (now > entry.expires) {
      cache.delete(key);
    }
  }
}, TTL);
`;
}

/**
 * Generate logger middleware for Neon backend
 */
export function generateNeonLoggerMiddleware(config: LoggerMiddlewareConfig): string {
  const { level = 'info', includeBody = false, includeResponse = false, redactFields = ['password', 'token', 'secret'] } = config;

  return `// GENERATED BY SCHEMOCK - DO NOT EDIT

import type { Request, Response, NextFunction } from 'express';

const LOG_LEVEL = '${level}';
const INCLUDE_BODY = ${includeBody};
const INCLUDE_RESPONSE = ${includeResponse};
const REDACT_FIELDS = ${JSON.stringify(redactFields)};

/**
 * Redact sensitive fields from an object
 */
function redact(obj: unknown): unknown {
  if (typeof obj !== 'object' || obj === null) return obj;

  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (REDACT_FIELDS.some(f => key.toLowerCase().includes(f.toLowerCase()))) {
      result[key] = '[REDACTED]';
    } else if (typeof value === 'object') {
      result[key] = redact(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Logging middleware
 */
export function loggerMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
): void {
  const start = Date.now();

  const logData: Record<string, unknown> = {
    method: req.method,
    path: req.path,
    query: req.query,
  };

  if (INCLUDE_BODY && req.body && Object.keys(req.body).length > 0) {
    logData.body = redact(req.body);
  }

  // Override res.json to log response
  if (INCLUDE_RESPONSE) {
    const originalJson = res.json.bind(res);
    res.json = (data: unknown) => {
      logData.response = redact(data);
      return originalJson(data);
    };
  }

  res.on('finish', () => {
    const duration = Date.now() - start;
    logData.status = res.statusCode;
    logData.duration = \`\${duration}ms\`;

    const logFn = res.statusCode >= 500 ? console.error :
                  res.statusCode >= 400 ? console.warn : console.log;

    logFn(JSON.stringify(logData));
  });

  next();
}
`;
}

/**
 * Generate context middleware for Neon backend
 */
export function generateNeonContextMiddleware(): string {
  return `// GENERATED BY SCHEMOCK - DO NOT EDIT

import type { Request, Response, NextFunction } from 'express';

/**
 * Request context type
 */
export interface RequestContext {
  userId?: string;
  role?: string;
  tenantId?: string;
  [key: string]: unknown;
}

// Extend Express Request to include context
declare module 'express' {
  interface Request {
    context?: RequestContext;
  }
}

/**
 * Context extraction middleware
 * Extracts context from JWT claims and request headers
 */
export function contextMiddleware(
  req: Request,
  _res: Response,
  next: NextFunction
): void {
  const context: RequestContext = {};

  // Extract from JWT payload (if auth middleware ran first)
  if ((req as any).user) {
    const user = (req as any).user;
    context.userId = user.sub || user.userId;
    context.role = user.role;
    context.email = user.email;
  }

  // Extract from headers
  const tenantId = req.headers['x-tenant-id'];
  if (tenantId && typeof tenantId === 'string') {
    context.tenantId = tenantId;
  }

  req.context = context;
  next();
}
`;
}

/**
 * Generate RLS middleware for Neon backend
 */
export function generateNeonRlsMiddleware(schemas: AnalyzedSchema[]): string {
  const schemasWithRLS = schemas.filter(s => s.rls.enabled);

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
    '/**',
    ' * RLS context type',
    ' */',
    'export interface RLSContext {',
    '  userId?: string;',
    '  role?: string;',
    '  tenantId?: string;',
    '  [key: string]: unknown;',
    '}',
    '',
    '/**',
    ' * Entity RLS configurations',
    ' */',
    'const rlsConfigs: Record<string, {',
    '  scope?: Array<{ field: string; contextKey: string }>;',
    '  bypass?: Array<{ contextKey: string; values: string[] }>;',
    '}> = {',
  ];

  for (const schema of schemasWithRLS) {
    lines.push(`  '${schema.tableName}': {`);
    if (schema.rls.scope.length > 0) {
      lines.push(`    scope: ${JSON.stringify(schema.rls.scope)},`);
    }
    if (schema.rls.bypass.length > 0) {
      lines.push(`    bypass: ${JSON.stringify(schema.rls.bypass)},`);
    }
    lines.push('  },');
  }

  lines.push('};');
  lines.push('');
  lines.push('/**');
  lines.push(' * Check if context bypasses RLS');
  lines.push(' */');
  lines.push('function checkBypass(tableName: string, context: RLSContext): boolean {');
  lines.push('  const config = rlsConfigs[tableName];');
  lines.push('  if (!config?.bypass) return false;');
  lines.push('');
  lines.push('  return config.bypass.some(rule => {');
  lines.push('    const value = context[rule.contextKey];');
  lines.push('    return typeof value === "string" && rule.values.includes(value);');
  lines.push('  });');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Apply RLS filter to a WHERE clause');
  lines.push(' */');
  lines.push('export function applyRLSFilter(');
  lines.push('  tableName: string,');
  lines.push('  context: RLSContext,');
  lines.push('  existingWhere?: string');
  lines.push('): string {');
  lines.push('  if (checkBypass(tableName, context)) {');
  lines.push("    return existingWhere || '1=1';");
  lines.push('  }');
  lines.push('');
  lines.push('  const config = rlsConfigs[tableName];');
  lines.push('  if (!config?.scope) {');
  lines.push("    return existingWhere || '1=1';");
  lines.push('  }');
  lines.push('');
  lines.push('  const conditions = config.scope.map(rule => {');
  lines.push('    const value = context[rule.contextKey];');
  lines.push("    if (value === undefined) return '1=0'; // No access if context key missing");
  lines.push('    return `${rule.field} = \'${value}\'`;');
  lines.push('  });');
  lines.push('');
  lines.push("  const rlsWhere = conditions.join(' AND ');");
  lines.push("  return existingWhere ? `(${existingWhere}) AND (${rlsWhere})` : rlsWhere;");
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Check RLS permission for a specific operation');
  lines.push(' */');
  lines.push('export function checkRLSPermission(');
  lines.push('  tableName: string,');
  lines.push('  operation: "select" | "insert" | "update" | "delete",');
  lines.push('  context: RLSContext,');
  lines.push('  row?: Record<string, unknown>');
  lines.push('): boolean {');
  lines.push('  if (checkBypass(tableName, context)) return true;');
  lines.push('');
  lines.push('  const config = rlsConfigs[tableName];');
  lines.push('  if (!config?.scope) return true;');
  lines.push('');
  lines.push('  if (!row) {');
  lines.push("    // For insert, check if context has required keys");
  lines.push("    return config.scope.every(rule => context[rule.contextKey] !== undefined);");
  lines.push('  }');
  lines.push('');
  lines.push('  // Check if row matches context');
  lines.push('  return config.scope.every(rule => {');
  lines.push('    const rowValue = row[rule.field];');
  lines.push('    const contextValue = context[rule.contextKey];');
  lines.push('    return rowValue === contextValue;');
  lines.push('  });');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * RLS middleware - attaches RLS helpers to request');
  lines.push(' */');
  lines.push('export function rlsMiddleware(');
  lines.push('  req: Request,');
  lines.push('  _res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): void {');
  lines.push('  // Context should be set by contextMiddleware');
  lines.push('  const context: RLSContext = (req as any).context || {};');
  lines.push('');
  lines.push('  // Attach RLS helpers to request');
  lines.push('  (req as any).rls = {');
  lines.push('    applyFilter: (table: string, where?: string) => applyRLSFilter(table, context, where),');
  lines.push('    checkPermission: (table: string, op: "select" | "insert" | "update" | "delete", row?: Record<string, unknown>) =>');
  lines.push('      checkRLSPermission(table, op, context, row),');
  lines.push('  };');
  lines.push('');
  lines.push('  next();');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate validation middleware for Neon backend
 */
export function generateNeonValidation(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '/**',
    ' * Validation result type',
    ' */',
    'export interface ValidationResult {',
    '  valid: boolean;',
    '  errors: Array<{ field: string; message: string }>;',
    '}',
    '',
    '/**',
    ' * Validate a value against constraints',
    ' */',
    'function validateField(',
    '  value: unknown,',
    '  field: string,',
    '  constraints: {',
    '    required?: boolean;',
    '    type?: string;',
    '    min?: number;',
    '    max?: number;',
    '    pattern?: string;',
    '    enum?: string[];',
    '  }',
    '): string | null {',
    '  if (constraints.required && (value === undefined || value === null)) {',
    '    return `${field} is required`;',
    '  }',
    '',
    '  if (value === undefined || value === null) return null;',
    '',
    "  if (constraints.type === 'string' && typeof value !== 'string') {",
    '    return `${field} must be a string`;',
    '  }',
    '',
    "  if (constraints.type === 'number' && typeof value !== 'number') {",
    '    return `${field} must be a number`;',
    '  }',
    '',
    "  if (constraints.type === 'boolean' && typeof value !== 'boolean') {",
    '    return `${field} must be a boolean`;',
    '  }',
    '',
    '  if (constraints.min !== undefined && typeof value === "number" && value < constraints.min) {',
    '    return `${field} must be at least ${constraints.min}`;',
    '  }',
    '',
    '  if (constraints.max !== undefined && typeof value === "number" && value > constraints.max) {',
    '    return `${field} must be at most ${constraints.max}`;',
    '  }',
    '',
    "  if (constraints.pattern && typeof value === 'string') {",
    '    const regex = new RegExp(constraints.pattern);',
    '    if (!regex.test(value)) {',
    '      return `${field} has invalid format`;',
    '    }',
    '  }',
    '',
    '  if (constraints.enum && !constraints.enum.includes(String(value))) {',
    '    return `${field} must be one of: ${constraints.enum.join(", ")}`;',
    '  }',
    '',
    '  return null;',
    '}',
    '',
  ];

  // Generate validators for each schema
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    // Create validator
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} create data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}(data: Record<string, unknown>): ValidationResult {`);
    lines.push('  const errors: Array<{ field: string; message: string }> = [];');
    lines.push('');

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const constraints: string[] = [];
      if (!field.nullable && !field.hasDefault) {
        constraints.push('required: true');
      }

      // Map field types
      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        constraints.push("type: 'string'");
      } else if (field.type === 'number' || field.type === 'integer' || field.type === 'float') {
        constraints.push("type: 'number'");
      } else if (field.type === 'boolean') {
        constraints.push("type: 'boolean'");
      }

      if (field.min !== undefined) constraints.push(`min: ${field.min}`);
      if (field.max !== undefined) constraints.push(`max: ${field.max}`);
      if (field.pattern) constraints.push(`pattern: '${field.pattern}'`);
      if (field.enumValues) constraints.push(`enum: ${JSON.stringify(field.enumValues)}`);

      if (constraints.length > 0) {
        lines.push(`  const ${field.name}Error = validateField(data.${field.name}, '${field.name}', { ${constraints.join(', ')} });`);
        lines.push(`  if (${field.name}Error) errors.push({ field: '${field.name}', message: ${field.name}Error });`);
        lines.push('');
      }
    }

    lines.push('  return { valid: errors.length === 0, errors };');
    lines.push('}');
    lines.push('');

    // Update validator (all fields optional)
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} update data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}Update(data: Record<string, unknown>): ValidationResult {`);
    lines.push('  const errors: Array<{ field: string; message: string }> = [];');
    lines.push('');

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const constraints: string[] = [];
      // Map field types (no required for update)
      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        constraints.push("type: 'string'");
      } else if (field.type === 'number' || field.type === 'integer' || field.type === 'float') {
        constraints.push("type: 'number'");
      } else if (field.type === 'boolean') {
        constraints.push("type: 'boolean'");
      }

      if (field.min !== undefined) constraints.push(`min: ${field.min}`);
      if (field.max !== undefined) constraints.push(`max: ${field.max}`);
      if (field.pattern) constraints.push(`pattern: '${field.pattern}'`);
      if (field.enumValues) constraints.push(`enum: ${JSON.stringify(field.enumValues)}`);

      if (constraints.length > 0) {
        lines.push(`  if (data.${field.name} !== undefined) {`);
        lines.push(`    const ${field.name}Error = validateField(data.${field.name}, '${field.name}', { ${constraints.join(', ')} });`);
        lines.push(`    if (${field.name}Error) errors.push({ field: '${field.name}', message: ${field.name}Error });`);
        lines.push('  }');
        lines.push('');
      }
    }

    lines.push('  return { valid: errors.length === 0, errors };');
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate custom middleware for Neon backend
 */
export function generateNeonCustomMiddleware(middleware: AnalyzedMiddleware): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
  ];

  // Generate config type if there are config fields
  if (middleware.configFields.length > 0) {
    lines.push(`/**`);
    lines.push(` * ${middleware.pascalName} middleware configuration`);
    lines.push(` */`);
    lines.push(`export interface ${middleware.pascalName}Config {`);
    for (const field of middleware.configFields) {
      const optional = field.nullable || field.hasDefault ? '?' : '';
      lines.push(`  ${field.name}${optional}: ${field.tsType};`);
    }
    lines.push('}');
    lines.push('');

    // Generate default config
    lines.push(`const defaultConfig: ${middleware.pascalName}Config = {`);
    for (const field of middleware.configFields) {
      if (field.hasDefault) {
        const defaultVal = typeof field.default === 'string' ? `'${field.default}'` : field.default;
        lines.push(`  ${field.name}: ${defaultVal},`);
      }
    }
    lines.push('};');
    lines.push('');
  }

  // Generate middleware function
  lines.push(`/**`);
  lines.push(` * ${middleware.pascalName} middleware`);
  if (middleware.description) {
    lines.push(` * ${middleware.description}`);
  }
  lines.push(` */`);

  if (middleware.configFields.length > 0) {
    lines.push(`export function ${middleware.name}Middleware(config: Partial<${middleware.pascalName}Config> = {}) {`);
    lines.push(`  const finalConfig = { ...defaultConfig, ...config };`);
    lines.push('');
    lines.push('  return async function(');
    lines.push('    req: Request,');
    lines.push('    res: Response,');
    lines.push('    next: NextFunction');
    lines.push('  ): Promise<void> {');
    lines.push('    // Custom middleware implementation');
    lines.push('    // TODO: Implement based on handler source');
    lines.push('    console.log(`${middleware.name} middleware running with config:`, finalConfig);');
    lines.push('    next();');
    lines.push('  };');
    lines.push('}');
  } else {
    lines.push(`export async function ${middleware.name}Middleware(`);
    lines.push('  req: Request,');
    lines.push('  res: Response,');
    lines.push('  next: NextFunction');
    lines.push('): Promise<void> {');
    lines.push('  // Custom middleware implementation');
    lines.push('  // TODO: Implement based on handler source');
    lines.push('  next();');
    lines.push('}');
  }

  return lines.join('\n');
}
