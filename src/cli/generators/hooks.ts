/**
 * React Query hooks generator
 *
 * @module cli/generators/hooks
 * @category CLI
 */

import type { AnalyzedSchema } from '../types';
import { CodeBuilder } from '../utils/code-builder';
import { toPascalCase } from '../utils/pluralize';

/**
 * Generate React Query hooks for all entities
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateHooks(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';");
  code.line("import { useMemo } from 'react';");
  code.line("import { useSchemockClient } from './provider';");
  code.line("import type * as Types from './types';");
  code.line();

  // Add stable query key helper to prevent unnecessary refetches
  generateStableKeyHelper(code);

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityHooks(code, schema);
  }

  return code.toString();
}

/**
 * Generate helper function for creating stable query keys
 *
 * This prevents unnecessary refetches when options objects have the same
 * values but different references (common with inline objects in React).
 */
function generateStableKeyHelper(code: CodeBuilder): void {
  code.comment('=============================================================================');
  code.comment('Stable Query Key Helper');
  code.comment('');
  code.comment('Creates stable query keys from options objects to prevent unnecessary');
  code.comment('refetches when object references change but values are the same.');
  code.comment('=============================================================================');
  code.line();

  code.multiDocComment([
    'Create a stable serialized key from an options object.',
    'Uses JSON.stringify with sorted keys for consistent ordering.',
    '',
    '@param options - The options object to serialize',
    '@returns A stable string representation of the options',
  ]);
  code.block('function stableKey(options: unknown): string {', () => {
    code.line('if (options === undefined || options === null) return "";');
    code.block('try {', () => {
      code.comment('Sort object keys for consistent serialization');
      code.line('return JSON.stringify(options, (_, value) => {');
      code.line('  if (value && typeof value === "object" && !Array.isArray(value)) {');
      code.line('    return Object.keys(value).sort().reduce((sorted, key) => {');
      code.line('      sorted[key] = value[key];');
      code.line('      return sorted;');
      code.line('    }, {} as Record<string, unknown>);');
      code.line('  }');
      code.line('  return value;');
      code.line('});');
    }, '} catch {');
    code.indent();
    code.comment('Fallback for non-serializable values');
    code.line('return String(options);');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.multiDocComment([
    'React hook that memoizes a stable query key from options.',
    'Only recomputes when the serialized value changes.',
    '',
    '@param baseKey - The base query key (e.g., "users")',
    '@param options - Optional options to include in the key',
    '@returns A stable query key array',
  ]);
  code.block('function useStableQueryKey(baseKey: string, ...parts: unknown[]): unknown[] {', () => {
    code.line('const serialized = parts.map(p => stableKey(p)).join("|");');
    code.line('return useMemo(() => [baseKey, ...parts], [baseKey, serialized]);');
  });
  code.line();
}

/**
 * Generate hooks for a single entity
 */
function generateEntityHooks(code: CodeBuilder, schema: AnalyzedSchema): void {
  const { name, pascalName, pluralName, pascalPluralName, relations } = schema;
  const hasRelations = relations.length > 0;

  code.comment(`==================== ${pascalName} Hooks ====================`);
  code.line();

  // useEntities (list)
  code.docComment(`Fetch list of ${pluralName}`);
  code.block(`export function use${pascalPluralName}(options?: {`, () => {
    code.line(`where?: Types.${pascalName}Filter;`);
    if (hasRelations) {
      code.line(`include?: Types.${pascalName}Include[];`);
    }
    code.line("orderBy?: Record<string, 'asc' | 'desc'>;");
    code.line('limit?: number;');
    code.line('offset?: number;');
    code.line('enabled?: boolean;');
  }, '}) {');
  code.indent();
  code.line('const api = useSchemockClient();');
  code.comment('Use stable query key to prevent unnecessary refetches');
  code.line(`const queryKey = useStableQueryKey('${pluralName}', options);`);
  code.block('return useQuery({', () => {
    code.line('queryKey,');
    code.line(`queryFn: () => api.${name}.list(options),`);
    code.line('enabled: options?.enabled ?? true,');
  }, '});');
  code.dedent();
  code.line('}');
  code.line();

  // useEntity (single)
  code.docComment(`Fetch single ${pascalName} by ID`);
  code.block(`export function use${pascalName}(id: string | undefined, options?: {`, () => {
    if (hasRelations) {
      code.line(`include?: Types.${pascalName}Include[];`);
    }
    code.line('enabled?: boolean;');
  }, '}) {');
  code.indent();
  code.line('const api = useSchemockClient();');
  if (hasRelations) {
    code.comment('Use stable query key for includes array');
    code.line(`const queryKey = useStableQueryKey('${pluralName}', id, options?.include);`);
  }
  code.block('return useQuery({', () => {
    if (hasRelations) {
      code.line('queryKey,');
      code.line(`queryFn: () => api.${name}.get(id!, { include: options?.include }),`);
    } else {
      code.line(`queryKey: ['${pluralName}', id],`);
      code.line(`queryFn: () => api.${name}.get(id!),`);
    }
    code.line('enabled: (options?.enabled ?? true) && !!id,');
  }, '});');
  code.dedent();
  code.line('}');
  code.line();

  // Convenience hooks for common includes
  for (const rel of relations) {
    const hookName = `use${pascalName}With${toPascalCase(rel.name)}`;
    code.docComment(`Fetch ${pascalName} with ${rel.name} included`);
    code.block(`export function ${hookName}(id: string | undefined) {`, () => {
      code.line(`return use${pascalName}(id, { include: ['${rel.name}'] });`);
    });
    code.line();
  }

  // useCreateEntity
  code.docComment(`Create a new ${pascalName}`);
  code.block(`export function useCreate${pascalName}() {`, () => {
    code.line('const api = useSchemockClient();');
    code.line('const queryClient = useQueryClient();');
    code.block('return useMutation({', () => {
      code.line(`mutationFn: (data: Types.${pascalName}Create) => api.${name}.create(data),`);
      code.block('onSuccess: () => {', () => {
        code.line(`queryClient.invalidateQueries({ queryKey: ['${pluralName}'] });`);
      }, '},');
    }, '});');
  });
  code.line();

  // useUpdateEntity
  code.docComment(`Update an existing ${pascalName}`);
  code.block(`export function useUpdate${pascalName}() {`, () => {
    code.line('const api = useSchemockClient();');
    code.line('const queryClient = useQueryClient();');
    code.block('return useMutation({', () => {
      code.line(`mutationFn: ({ id, data }: { id: string; data: Types.${pascalName}Update }) =>`);
      code.line(`  api.${name}.update(id, data),`);
      code.block('onSuccess: (_, { id }) => {', () => {
        code.line(`queryClient.invalidateQueries({ queryKey: ['${pluralName}'] });`);
        code.line(`queryClient.invalidateQueries({ queryKey: ['${pluralName}', id] });`);
      }, '},');
    }, '});');
  });
  code.line();

  // useDeleteEntity
  code.docComment(`Delete a ${pascalName}`);
  code.block(`export function useDelete${pascalName}() {`, () => {
    code.line('const api = useSchemockClient();');
    code.line('const queryClient = useQueryClient();');
    code.block('return useMutation({', () => {
      code.line(`mutationFn: (id: string) => api.${name}.delete(id),`);
      code.block('onSuccess: () => {', () => {
        code.line(`queryClient.invalidateQueries({ queryKey: ['${pluralName}'] });`);
      }, '},');
    }, '});');
  });
  code.line();
}
