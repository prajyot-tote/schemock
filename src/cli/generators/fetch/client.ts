/**
 * Fetch client generator
 *
 * @module cli/generators/fetch/client
 * @category CLI
 */

import type { AnalyzedSchema, FetchAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Fetch API client
 *
 * @param schemas - Analyzed schemas
 * @param config - Fetch adapter configuration
 * @returns Generated TypeScript code
 */
export function generateFetchClient(schemas: AnalyzedSchema[], config: FetchAdapterConfig): string {
  const code = new CodeBuilder();
  const baseUrl = config.baseUrl ?? '';

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import type * as Types from './types';");
  code.line();

  code.line(`const BASE_URL = '${baseUrl}';`);
  code.line();

  // Fetch helper
  code.block('async function request<T>(path: string, options?: RequestInit): Promise<T> {', () => {
    code.line('const response = await fetch(`${BASE_URL}${path}`, {');
    code.line("  headers: { 'Content-Type': 'application/json', ...options?.headers },");
    code.line('  ...options,');
    code.line('});');
    code.line('if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);');
    code.line('if (response.status === 204) return undefined as T;');
    code.line('return response.json();');
  });
  code.line();

  // Build query string helper
  code.block('function buildQuery(options?: Record<string, unknown>): string {', () => {
    code.line("if (!options) return '';");
    code.line('const params = new URLSearchParams();');
    code.block('for (const [key, value] of Object.entries(options)) {', () => {
      code.line('if (value !== undefined) {');
      code.line("  params.set(key, typeof value === 'object' ? JSON.stringify(value) : String(value));");
      code.line('}');
    });
    code.line('const str = params.toString();');
    code.line("return str ? `?${str}` : '';");
  });
  code.line();

  // Generate API
  code.block('export const api = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateFetchEntityApi(code, schema);
    }
  }, '};');

  return code.toString();
}

/**
 * Generate Fetch API methods for a single entity
 */
function generateFetchEntityApi(code: CodeBuilder, schema: AnalyzedSchema): void {
  const { name, pascalName, endpoint, relations } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  code.block(`${name}: {`, () => {
    // LIST
    code.block(
      `list: async (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>): Promise<Types.ListResponse<Types.${pascalName}>> => {`,
      () => {
        code.line(`return request('${endpoint}' + buildQuery(options));`);
      },
      '},'
    );
    code.line();

    // GET
    code.block(`get: async (id: string, options?: { include?: ${includeType}[] }): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`return request(\`${endpoint}/\${id}\` + buildQuery(options));`);
    }, '},');
    code.line();

    // CREATE
    code.block(`create: async (input: Types.${pascalName}Create): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`return request('${endpoint}', {`);
      code.line("  method: 'POST',");
      code.line('  body: JSON.stringify(input),');
      code.line('});');
    }, '},');
    code.line();

    // UPDATE
    code.block(`update: async (id: string, input: Types.${pascalName}Update): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`return request(\`${endpoint}/\${id}\`, {`);
      code.line("  method: 'PUT',");
      code.line('  body: JSON.stringify(input),');
      code.line('});');
    }, '},');
    code.line();

    // PATCH
    code.block(`patch: async (id: string, input: Types.${pascalName}Update): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`return request(\`${endpoint}/\${id}\`, {`);
      code.line("  method: 'PATCH',");
      code.line('  body: JSON.stringify(input),');
      code.line('});');
    }, '},');
    code.line();

    // DELETE
    code.block('delete: async (id: string): Promise<void> => {', () => {
      code.line(`await request(\`${endpoint}/\${id}\`, { method: 'DELETE' });`);
    }, '},');
  }, '},');
  code.line();
}
