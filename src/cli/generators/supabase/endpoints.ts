/**
 * Supabase endpoint generator for custom RPC endpoints
 *
 * Generates client code that calls Supabase RPC functions for custom endpoints.
 *
 * @module cli/generators/supabase/endpoints
 * @category CLI
 */

import type { AnalyzedEndpoint, SupabaseAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Supabase client methods for custom endpoints
 *
 * @param endpoints - Analyzed endpoints
 * @param config - Supabase adapter configuration
 * @returns Generated TypeScript code for endpoint client
 */
export function generateSupabaseEndpoints(
  endpoints: AnalyzedEndpoint[],
  config: SupabaseAdapterConfig
): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Supabase RPC client for custom endpoints');
  code.line();

  code.line("import { supabase, ApiError, type ClientConfig, type RequestContext } from './client';");
  code.line("import type * as Types from './types';");
  code.line();

  // Helper for extracting access token
  code.comment('Extract access token from Authorization header');
  code.block('function extractAccessToken(headers: Record<string, string>): string | undefined {', () => {
    code.line("const auth = headers['Authorization'] || headers['authorization'];");
    code.line("if (auth?.startsWith('Bearer ')) {");
    code.line('  return auth.slice(7);');
    code.line('}');
    code.line('return undefined;');
  });
  code.line();

  // Error wrapper
  code.comment('Wrap Supabase RPC errors');
  code.block('function wrapRpcError(error: unknown, operation: string): ApiError {', () => {
    code.line('const err = error as { code?: string; message?: string; details?: unknown };');
    code.line('const errorCode = err.code || "RPC_ERROR";');
    code.line('const message = err.message || "RPC call failed";');
    code.line();
    code.comment('Map error codes to HTTP status');
    code.line('let status = 500;');
    code.block('switch (errorCode) {', () => {
      code.line("case 'PGRST202': status = 404; break; // Function not found");
      code.line("case 'PGRST204': status = 400; break; // Required parameter missing");
      code.line("case '42501': status = 403; break; // Permission denied");
      code.line("case 'P0001': status = 400; break; // raise_exception");
    });
    code.line();
    code.line('return new ApiError(message, status, errorCode, operation, err.details);');
  });
  code.line();

  // Endpoints type
  code.comment('Endpoints client type');
  code.block('export interface EndpointsClient {', () => {
    for (const endpoint of endpoints) {
      const { name, pascalName, params, body } = endpoint;
      const hasParams = params.length > 0;
      const hasBody = body.length > 0;

      const args: string[] = [];
      if (hasParams) args.push(`params: Types.${pascalName}Params`);
      if (hasBody) args.push(`body: Types.${pascalName}Body`);

      code.line(`${name}: (${args.join(', ')}) => Promise<Types.${pascalName}Response>;`);
    }
  }, '}');
  code.line();

  // Create endpoints factory
  code.multiDocComment([
    'Create a configured endpoints client with interceptors.',
    '',
    '@param config - Client configuration with interceptors',
    '@returns Configured endpoints client',
    '',
    '@example',
    '```typescript',
    "import { createEndpoints } from './generated/endpoints';",
    '',
    'const endpoints = createEndpoints({',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${getToken()}`;',
    '    return ctx;',
    '  }',
    '});',
    '',
    'const result = await endpoints.searchUsers({ query: "john" });',
    '```',
  ]);
  code.block('export function createEndpoints(config?: ClientConfig): EndpointsClient {', () => {
    code.line('const interceptors = config ?? {};');
    code.line();

    code.comment('Execute RPC call with interceptors');
    code.block('async function executeRpc<T>(', () => {
      code.line('operation: string,');
      code.line('rpcName: string,');
      code.line('rpcParams: Record<string, unknown>');
    }, '): Promise<T> {');
    code.indent();

    code.line('let requestCtx: RequestContext = { headers: {}, operation };');
    code.block('if (interceptors.onRequest) {', () => {
      code.line('requestCtx = await interceptors.onRequest(requestCtx);');
    });
    code.line();

    code.comment('Get access token and create authenticated client if provided');
    code.line('const accessToken = extractAccessToken(requestCtx.headers);');
    code.line('let client = supabase;');
    code.line();
    code.block('if (accessToken) {', () => {
      code.comment('Create a new client with the auth token');
      code.line("const { createClient } = await import('@supabase/supabase-js');");
      code.line("const url = process.env.NEXT_PUBLIC_SUPABASE_URL!;");
      code.line("const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;");
      code.line('client = createClient(url, key, {');
      code.line('  global: { headers: { Authorization: `Bearer ${accessToken}` } }');
      code.line('});');
    });
    code.line();

    code.block('try {', () => {
      code.line('const { data, error } = await client.rpc(rpcName, rpcParams);');
      code.block('if (error) {', () => {
        code.line('throw wrapRpcError(error, operation);');
      });
      code.line('return data as T;');
    }, '} catch (err) {');
    code.indent();
    code.line('const error = err instanceof ApiError ? err : wrapRpcError(err, operation);');
    code.block('if (interceptors.onError) {', () => {
      code.line('await interceptors.onError(error);');
    });
    code.line('throw error;');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();

    code.block('return {', () => {
      for (const endpoint of endpoints) {
        generateEndpointMethod(code, endpoint);
      }
    }, '};');
  });
  code.line();

  // Default export
  code.multiDocComment([
    'Default endpoints client (no interceptors configured).',
    'For production, use createEndpoints() with interceptors instead.',
  ]);
  code.line('export const endpoints = createEndpoints();');

  return code.toString();
}

/**
 * Generate a single endpoint method
 */
function generateEndpointMethod(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { name, pascalName, params, body } = endpoint;
  const hasParams = params.length > 0;
  const hasBody = body.length > 0;

  // Convert endpoint name to snake_case for PostgreSQL function name
  const rpcName = toSnakeCase(name);

  const args: string[] = [];
  if (hasParams) args.push(`params: Types.${pascalName}Params`);
  if (hasBody) args.push(`body: Types.${pascalName}Body`);

  code.block(`${name}: async (${args.join(', ')}): Promise<Types.${pascalName}Response> => {`, () => {
    // Build RPC parameters
    code.block('const rpcParams = {', () => {
      if (hasParams) {
        code.line('...params,');
      }
      if (hasBody) {
        code.line('...body,');
      }
    }, '};');
    code.line();

    code.line(`return executeRpc<Types.${pascalName}Response>('endpoints.${name}', '${rpcName}', rpcParams);`);
  }, '},');
  code.line();
}

/**
 * Convert camelCase to snake_case for PostgreSQL function names
 */
function toSnakeCase(str: string): string {
  return str
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '');
}

/**
 * Generate PostgreSQL function definitions for custom endpoints
 *
 * @param endpoints - Analyzed endpoints
 * @param config - Supabase adapter configuration
 * @returns Generated SQL for RPC functions
 */
export function generateSupabaseEndpointFunctions(
  endpoints: AnalyzedEndpoint[],
  _config: SupabaseAdapterConfig
): string {
  const code = new CodeBuilder();

  code.raw('-- GENERATED BY SCHEMOCK');
  code.raw('-- PostgreSQL functions for custom endpoints');
  code.raw('-- NOTE: These are placeholder stubs - implement actual logic based on your needs');
  code.raw('');

  for (const endpoint of endpoints) {
    generateRpcFunction(code, endpoint);
  }

  return code.toString();
}

/**
 * Generate a single PostgreSQL RPC function stub
 */
function generateRpcFunction(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { pascalName, params, body, response, description } = endpoint;
  const funcName = toSnakeCase(endpoint.name);

  // Build function parameters
  const allParams = [...params, ...body];
  const paramDefs = allParams.map(p => {
    const pgType = tsPgTypeMap(p.tsType);
    const defaultVal = p.hasDefault ? ` DEFAULT ${formatPgDefault(p.default)}` : '';
    return `p_${toSnakeCase(p.name)} ${pgType}${defaultVal}`;
  });

  // Build return type from response
  const returnDef = response.length === 1
    ? tsPgTypeMap(response[0].tsType)
    : `jsonb`;

  code.raw(`-- ${endpoint.method} ${endpoint.path}`);
  if (description) {
    code.raw(`-- ${description}`);
  }
  code.raw(`CREATE OR REPLACE FUNCTION ${funcName}(`);
  if (paramDefs.length > 0) {
    code.raw(`  ${paramDefs.join(',\n  ')}`);
  }
  code.raw(`)`);
  code.raw(`RETURNS ${returnDef}`);
  code.raw(`LANGUAGE plpgsql`);
  code.raw(`SECURITY INVOKER`);
  code.raw(`AS $$`);
  code.raw(`BEGIN`);
  code.raw(`  -- TODO: Implement ${pascalName} logic`);
  code.raw(`  -- This is a placeholder - replace with actual implementation`);

  if (returnDef === 'jsonb') {
    const responseObj = response.map(f => `'${f.name}', null`).join(', ');
    code.raw(`  RETURN jsonb_build_object(${responseObj});`);
  } else if (returnDef === 'void') {
    code.raw(`  RETURN;`);
  } else {
    code.raw(`  RETURN NULL;`);
  }

  code.raw(`END;`);
  code.raw(`$$;`);
  code.raw('');
}

/**
 * Map TypeScript types to PostgreSQL types
 */
function tsPgTypeMap(tsType: string): string {
  const normalizedType = tsType.replace(/\s/g, '').toLowerCase();

  if (normalizedType === 'string') return 'text';
  if (normalizedType === 'number') return 'numeric';
  if (normalizedType === 'boolean') return 'boolean';
  if (normalizedType === 'date') return 'timestamptz';
  if (normalizedType.includes('[]')) return 'jsonb';
  if (normalizedType.startsWith('{') || normalizedType === 'object') return 'jsonb';
  if (normalizedType === 'void' || normalizedType === 'undefined') return 'void';

  // Default to text for unknown types
  return 'text';
}

/**
 * Format default value for PostgreSQL
 */
function formatPgDefault(value: unknown): string {
  if (value === null || value === undefined) return 'NULL';
  if (typeof value === 'string') return `'${value.replace(/'/g, "''")}'`;
  if (typeof value === 'number') return String(value);
  if (typeof value === 'boolean') return value ? 'TRUE' : 'FALSE';
  return `'${JSON.stringify(value)}'::jsonb`;
}
