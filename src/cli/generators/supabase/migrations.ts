/**
 * Supabase migration generator with RLS policies
 *
 * @module cli/generators/supabase/migrations
 * @category CLI
 */

import type { AnalyzedSchema, SupabaseAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Supabase migration SQL file with RLS policies
 *
 * @param schemas - Analyzed schemas
 * @param config - Supabase adapter configuration
 * @returns Generated SQL migration content
 */
export function generateSupabaseMigration(
  schemas: AnalyzedSchema[],
  config: SupabaseAdapterConfig
): string {
  const code = new CodeBuilder();

  code.raw('-- Generated by Schemock');
  code.raw('-- Supabase Migration with RLS Policies');
  code.raw('');

  // Generate table creation
  for (const schema of schemas) {
    generateTableSchema(code, schema, config);
    code.raw('');
  }

  // Generate foreign keys
  code.raw('-- Foreign Key Constraints');
  for (const schema of schemas) {
    generateForeignKeys(code, schema, schemas, config);
  }
  code.raw('');

  // Generate RLS policies
  const hasRLS = schemas.some((s) => s.rls.enabled);
  if (hasRLS) {
    code.raw('-- Row-Level Security Policies');
    for (const schema of schemas) {
      generateRLSPolicies(code, schema, config);
    }
  }

  return code.toString();
}

/**
 * Generate table creation SQL
 */
function generateTableSchema(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: SupabaseAdapterConfig
): void {
  const tableName = config.tableMap?.[schema.name] ?? schema.tableName;

  code.raw(`-- Table: ${tableName}`);
  code.raw(`CREATE TABLE IF NOT EXISTS "${tableName}" (`);

  const columns: string[] = [];
  for (const field of schema.fields) {
    const pgType = mapFieldToPostgres(field);
    columns.push(`  "${field.name}" ${pgType}`);
  }

  code.raw(columns.join(',\n'));
  code.raw(');');
}

/**
 * Map field to PostgreSQL type
 */
function mapFieldToPostgres(field: { name: string; type: string; nullable: boolean; unique: boolean; isRef: boolean; isEnum: boolean; isArray: boolean; isObject: boolean; enumValues?: string[] }): string {
  if (field.name === 'id') return 'UUID PRIMARY KEY DEFAULT gen_random_uuid()';

  if (field.isEnum && field.enumValues?.length) {
    const vals = field.enumValues.map((v) => `'${v}'`).join(', ');
    return `TEXT CHECK ("${field.name}" IN (${vals}))${field.nullable ? '' : ' NOT NULL'}`;
  }

  if (field.isArray || field.isObject) {
    return `JSONB${field.nullable ? '' : ' NOT NULL'}`;
  }

  if (field.isRef) {
    return `UUID${field.nullable ? '' : ' NOT NULL'}`;
  }

  let pgType: string;
  switch (field.type) {
    case 'uuid': pgType = 'UUID'; break;
    case 'string':
    case 'email':
    case 'url':
    case 'text': pgType = 'TEXT'; break;
    case 'number':
    case 'float': pgType = 'DOUBLE PRECISION'; break;
    case 'int':
    case 'integer': pgType = 'INTEGER'; break;
    case 'boolean': pgType = 'BOOLEAN'; break;
    case 'date':
    case 'datetime': pgType = 'TIMESTAMPTZ'; break;
    default: pgType = 'TEXT';
  }

  const constraints: string[] = [];
  if (!field.nullable && field.name !== 'id') constraints.push('NOT NULL');
  if (field.unique) constraints.push('UNIQUE');

  return constraints.length > 0 ? `${pgType} ${constraints.join(' ')}` : pgType;
}

/**
 * Generate foreign key constraints
 */
function generateForeignKeys(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  config: SupabaseAdapterConfig
): void {
  const tableName = config.tableMap?.[schema.name] ?? schema.tableName;

  for (const field of schema.fields) {
    if (field.isRef && field.refTarget) {
      const targetSchema = allSchemas.find((s) => s.name === field.refTarget);
      if (targetSchema) {
        const targetTable = config.tableMap?.[targetSchema.name] ?? targetSchema.tableName;
        code.raw(
          `ALTER TABLE "${tableName}" ADD CONSTRAINT "fk_${tableName}_${field.name}" ` +
          `FOREIGN KEY ("${field.name}") REFERENCES "${targetTable}"("id") ON DELETE CASCADE;`
        );
      }
    }
  }
}

/**
 * Generate RLS policies for Supabase (generic context-based)
 */
function generateRLSPolicies(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: SupabaseAdapterConfig
): void {
  const { rls } = schema;
  const tableName = config.tableMap?.[schema.name] ?? schema.tableName;

  if (!rls.enabled) return;

  code.raw('');
  code.raw(`-- RLS for ${tableName}`);
  code.raw(`ALTER TABLE "${tableName}" ENABLE ROW LEVEL SECURITY;`);

  const operations = [
    { name: 'SELECT', has: rls.hasSelect, action: 'select' },
    { name: 'INSERT', has: rls.hasInsert, action: 'insert' },
    { name: 'UPDATE', has: rls.hasUpdate, action: 'update' },
    { name: 'DELETE', has: rls.hasDelete, action: 'delete' },
  ] as const;

  for (const { name, has, action } of operations) {
    if (!has) continue;

    // Check for custom SQL first
    const customSql = rls.sql?.[action];

    if (customSql) {
      code.raw(`CREATE POLICY "${tableName}_${action}_policy" ON "${tableName}"`);
      code.raw(`  FOR ${name}`);
      code.raw(`  USING (${customSql});`);
    } else if (rls.scope.length > 0) {
      // Generate from scope mappings
      const conditions: string[] = [];

      // Bypass conditions using JWT claims
      for (const bypass of rls.bypass) {
        const valuesCheck = bypass.values
          .map((v) => `auth.jwt()->>'${bypass.contextKey}' = '${v}'`)
          .join(' OR ');
        conditions.push(`(${valuesCheck})`);
      }

      // Scope mappings: row.field = auth context
      for (const mapping of rls.scope) {
        // For userId, use auth.uid(); for others, use JWT claims
        if (mapping.contextKey === 'userId') {
          conditions.push(`"${mapping.field}" = auth.uid()`);
        } else {
          conditions.push(`"${mapping.field}" = (auth.jwt()->>'${mapping.contextKey}')::uuid`);
        }
      }

      const condition = conditions.length > 0
        ? conditions.join(' OR ')
        : 'true';

      code.raw(`CREATE POLICY "${tableName}_${action}_policy" ON "${tableName}"`);
      code.raw(`  FOR ${name}`);
      if (action === 'insert') {
        code.raw(`  WITH CHECK (${condition});`);
      } else {
        code.raw(`  USING (${condition});`);
      }
    }
  }
}

/**
 * Generate TypeScript helper for generating migrations
 */
export function generateSupabaseMigrationHelper(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Supabase RLS Migration Helper');
  code.line();

  code.comment('Run this to apply RLS policies to your Supabase project');
  code.comment("Use: npx supabase migration new rls_policies");
  code.comment("Then copy the SQL from getMigrationSQL() into the migration file");
  code.line();

  // Export function to get migration SQL
  code.block('export function getMigrationSQL(): string {', () => {
    code.line('return `');
    // The actual SQL will be generated at runtime
    code.line('-- RLS Policies for Schemock entities');
    code.line('-- Copy this SQL to your Supabase migration');

    for (const schema of schemas) {
      if (!schema.rls.enabled) continue;

      code.line('');
      code.line(`-- ${schema.pascalName}`);
      code.line(`ALTER TABLE "${schema.tableName}" ENABLE ROW LEVEL SECURITY;`);

      // Generate policies from scope mappings
      for (const mapping of schema.rls.scope) {
        code.line(`-- Scope: ${mapping.field} must match context.${mapping.contextKey}`);
        if (mapping.contextKey === 'userId') {
          code.line(`CREATE POLICY "${schema.tableName}_${mapping.field}_policy" ON "${schema.tableName}"`);
          code.line(`  USING ("${mapping.field}" = auth.uid());`);
        } else {
          code.line(`CREATE POLICY "${schema.tableName}_${mapping.field}_policy" ON "${schema.tableName}"`);
          code.line(`  USING ("${mapping.field}" = (auth.jwt()->>'${mapping.contextKey}')::uuid);`);
        }
      }
    }

    code.line('`;');
  });

  return code.toString();
}
