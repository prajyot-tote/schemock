/**
 * Supabase client generator
 *
 * @module cli/generators/supabase/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation, SupabaseAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Supabase API client
 *
 * @param schemas - Analyzed schemas
 * @param config - Supabase adapter configuration
 * @returns Generated TypeScript code
 */
export function generateSupabaseClient(schemas: AnalyzedSchema[], config: SupabaseAdapterConfig): string {
  const code = new CodeBuilder();
  const envPrefix = config.envPrefix ?? 'NEXT_PUBLIC_SUPABASE';

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { createClient } from '@supabase/supabase-js';");
  code.line("import type * as Types from './types';");
  code.line();

  code.line(`const supabaseUrl = process.env.${envPrefix}_URL!;`);
  code.line(`const supabaseKey = process.env.${envPrefix}_ANON_KEY!;`);
  code.line();

  code.line('export const supabase = createClient(supabaseUrl, supabaseKey);');
  code.line();

  // Helper for building select with relations
  code.block('function buildSelect(include?: string[]): string {', () => {
    code.line("if (!include?.length) return '*';");
    code.line("return `*, ${include.map(rel => `${rel}(*)`).join(', ')}`;");
  });
  code.line();

  // Build schema map for looking up target schemas
  const schemaMap = new Map(schemas.map((s) => [s.name, s]));

  // Generate API
  code.block('export const api = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateSupabaseEntityApi(code, schema, config, schemaMap);
    }
  }, '};');

  return code.toString();
}

/**
 * Generate Supabase API methods for a single entity
 */
function generateSupabaseEntityApi(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: SupabaseAdapterConfig,
  schemaMap: Map<string, AnalyzedSchema>
): void {
  const { name, pascalName, tableName, relations } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  code.block(`${name}: {`, () => {
    // LIST
    code.block(
      `list: async (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>): Promise<Types.ListResponse<Types.${pascalName}>> => {`,
      () => {
        code.line('const select = buildSelect(options?.include);');
        code.line(`let query = supabase.from('${tableName}').select(select, { count: 'exact' });`);
        code.line();

        // Filters
        code.block('if (options?.where) {', () => {
          code.block('for (const [key, value] of Object.entries(options.where)) {', () => {
            code.block('if (typeof value === "object" && value !== null) {', () => {
              code.line('const f = value as Record<string, unknown>;');
              code.line("if ('equals' in f) query = query.eq(key, f.equals);");
              code.line("if ('not' in f) query = query.neq(key, f.not);");
              code.line("if ('in' in f) query = query.in(key, f.in as unknown[]);");
              code.line("if ('notIn' in f) query = query.not(key, 'in', `(${(f.notIn as unknown[]).join(',')})`);");
              code.line("if ('contains' in f) query = query.ilike(key, `%${f.contains}%`);");
              code.line("if ('startsWith' in f) query = query.ilike(key, `${f.startsWith}%`);");
              code.line("if ('endsWith' in f) query = query.ilike(key, `%${f.endsWith}`);");
              code.line("if ('gt' in f) query = query.gt(key, f.gt);");
              code.line("if ('gte' in f) query = query.gte(key, f.gte);");
              code.line("if ('lt' in f) query = query.lt(key, f.lt);");
              code.line("if ('lte' in f) query = query.lte(key, f.lte);");
              code.line("if ('isNull' in f) f.isNull ? query = query.is(key, null) : query = query.not(key, 'is', null);");
            }, '} else {');
            code.indent();
            code.line('query = query.eq(key, value);');
            code.dedent();
            code.line('}');
          });
        });
        code.line();

        // Ordering
        code.block('if (options?.orderBy) {', () => {
          code.block('for (const [field, dir] of Object.entries(options.orderBy)) {', () => {
            code.line("query = query.order(field, { ascending: dir === 'asc' });");
          });
        });
        code.line();

        // Pagination
        code.line('const limit = options?.limit ?? 20;');
        code.line('const offset = options?.offset ?? 0;');
        code.line('query = query.range(offset, offset + limit - 1);');
        code.line();

        code.line('const { data, error, count } = await query;');
        code.line('if (error) throw error;');
        code.line();
        code.line('return {');
        code.line(`  data: (data || []) as Types.${pascalName}[],`);
        code.line('  meta: { total: count || 0, limit, offset, hasMore: offset + limit < (count || 0) },');
        code.line('};');
      },
      '},'
    );
    code.line();

    // GET
    code.block(`get: async (id: string, options?: { include?: ${includeType}[] }): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line('const select = buildSelect(options?.include);');
      code.line(`const { data, error } = await supabase.from('${tableName}').select(select).eq('id', id).single();`);
      code.line('if (error) throw error;');
      code.line(`return { data: data as Types.${pascalName} };`);
    }, '},');
    code.line();

    // CREATE (with nested relation support)
    generateSupabaseCreateMethod(code, schema, config, schemaMap);
    code.line();

    // UPDATE
    code.block(`update: async (id: string, input: Types.${pascalName}Update): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`const { data, error } = await supabase.from('${tableName}').update(input).eq('id', id).select().single();`);
      code.line('if (error) throw error;');
      code.line(`return { data: data as Types.${pascalName} };`);
    }, '},');
    code.line();

    // DELETE
    code.block('delete: async (id: string): Promise<void> => {', () => {
      code.line(`const { error } = await supabase.from('${tableName}').delete().eq('id', id);`);
      code.line('if (error) throw error;');
    }, '},');
  }, '},');
  code.line();
}

/**
 * Generate Supabase create method with nested relation support
 */
function generateSupabaseCreateMethod(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: SupabaseAdapterConfig,
  schemaMap: Map<string, AnalyzedSchema>
): void {
  const { pascalName, tableName, relations } = schema;
  const nestedRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');

  code.block(`create: async (input: Types.${pascalName}Create): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
    if (nestedRels.length > 0) {
      const relNames = nestedRels.map((r) => r.name).join(', ');
      code.line(`const { ${relNames}, ...data } = input;`);
      code.line();
      code.line(`const { data: item, error } = await supabase.from('${tableName}').insert(data).select().single();`);
      code.line('if (error) throw error;');
      code.line();

      for (const rel of nestedRels) {
        // Use target schema's tableName for proper pluralization, fall back to config or simple pluralization
        const targetSchema = schemaMap.get(rel.target);
        const targetTable = config.tableMap?.[rel.target] ?? targetSchema?.tableName ?? rel.target + 's';
        code.block(`if (${rel.name}) {`, () => {
          if (rel.type === 'hasMany') {
            code.line(`const nestedData = ${rel.name}.map(nested => ({ ...nested, ${rel.foreignKey}: item.id }));`);
            code.line(`const { error: nestedError } = await supabase.from('${targetTable}').insert(nestedData);`);
            code.line('if (nestedError) throw nestedError;');
          } else {
            code.line(`const { error: nestedError } = await supabase.from('${targetTable}').insert({ ...${rel.name}, ${rel.foreignKey}: item.id });`);
            code.line('if (nestedError) throw nestedError;');
          }
        });
      }

      code.line();
      code.line(`return { data: item as Types.${pascalName} };`);
    } else {
      code.line(`const { data, error } = await supabase.from('${tableName}').insert(input).select().single();`);
      code.line('if (error) throw error;');
      code.line(`return { data: data as Types.${pascalName} };`);
    }
  }, '},');
}
