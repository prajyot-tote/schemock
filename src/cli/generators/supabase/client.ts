/**
 * Supabase client generator
 *
 * @module cli/generators/supabase/client
 * @category CLI
 */

import type { AnalyzedSchema, SupabaseAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Supabase API client
 *
 * @param schemas - Analyzed schemas
 * @param config - Supabase adapter configuration
 * @returns Generated TypeScript code
 */
export function generateSupabaseClient(schemas: AnalyzedSchema[], config: SupabaseAdapterConfig): string {
  const code = new CodeBuilder();
  const envPrefix = config.envPrefix ?? 'NEXT_PUBLIC_SUPABASE';

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { createClient as createSupabaseClient } from '@supabase/supabase-js';");
  code.line("import type * as Types from './types';");
  code.line();

  code.line(`const supabaseUrl = process.env.${envPrefix}_URL!;`);
  code.line(`const supabaseKey = process.env.${envPrefix}_ANON_KEY!;`);
  code.line();

  // Generate interceptor infrastructure
  generateInterceptorInfrastructure(code);

  // Generate Supabase instance factory
  code.comment('Create Supabase client with optional custom auth token');
  code.block('function getSupabaseClient(accessToken?: string) {', () => {
    code.block('if (accessToken) {', () => {
      code.line('return createSupabaseClient(supabaseUrl, supabaseKey, {');
      code.line('  global: {');
      code.line('    headers: {');
      code.line('      Authorization: `Bearer ${accessToken}`,');
      code.line('    },');
      code.line('  },');
      code.line('});');
    });
    code.line('return createSupabaseClient(supabaseUrl, supabaseKey);');
  });
  code.line();

  code.comment('Default Supabase client (for direct access if needed)');
  code.line('export const supabase = createSupabaseClient(supabaseUrl, supabaseKey);');
  code.line();

  // Build schema map for looking up target schemas (needed for relation metadata)
  const schemaMap = new Map(schemas.map((s) => [s.name, s]));

  // Relation metadata for building proper Supabase selects
  // belongsTo relations need explicit target table: "author:users(*)"
  // hasMany/hasOne can use simple syntax: "posts(*)"
  code.block('const relationMeta: Record<string, Record<string, { type: string; target: string }>> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      if (schema.relations.length === 0) continue;
      code.block(`${schema.name}: {`, () => {
        for (const rel of schema.relations) {
          const targetSchema = schemaMap.get(rel.resolvedTarget);
          const targetTable = config.tableMap?.[rel.resolvedTarget] ?? targetSchema?.tableName ?? rel.resolvedTarget + 's';
          code.line(`${rel.name}: { type: '${rel.type}', target: '${targetTable}' },`);
        }
      }, '},');
    }
  }, '};');
  code.line();

  // Helper for building select with relations (now schema-aware)
  code.block('function buildSelect(entityName: string, include?: string[]): string {', () => {
    code.line("if (!include?.length) return '*';");
    code.line('const meta = relationMeta[entityName] || {};');
    code.line('const selectParts = include.map(rel => {');
    code.line('  const relInfo = meta[rel];');
    code.line("  if (relInfo?.type === 'belongsTo') {");
    code.line("    // belongsTo needs explicit target: 'author:users(*)'");
    code.line('    return `${rel}:${relInfo.target}(*)`;');
    code.line('  }');
    code.line("  // hasMany/hasOne can use simple syntax: 'posts(*)'");
    code.line('  return `${rel}(*)`;');
    code.line('});');
    code.line("return `*, ${selectParts.join(', ')}`;");
  });
  code.line();

  // Generate the ApiClient type
  generateApiType(code, schemas);
  code.line();

  // Generate createClient factory
  generateCreateClientFactory(code, schemas, config, schemaMap);
  code.line();

  // Export default unconfigured client
  code.multiDocComment([
    'Default API client (no interceptors configured).',
    'For production, use createClient() with interceptors instead.',
    '',
    '@example',
    '```typescript',
    "// Simple usage (no auth)",
    'const posts = await api.post.list();',
    '',
    '// For production with auth, use createClient instead:',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${getToken()}`;',
    '    return ctx;',
    '  }',
    '});',
    '```',
  ]);
  code.line('export const api = createClient();');

  return code.toString();
}

/**
 * Generate interceptor infrastructure (types and helpers)
 */
function generateInterceptorInfrastructure(code: CodeBuilder): void {
  code.comment('=============================================================================');
  code.comment('Client Configuration & Interceptor Pattern');
  code.comment('');
  code.comment('Production-ready interceptor pattern for centralized auth and error handling.');
  code.comment('Configure once at app startup, auth headers are added to every request.');
  code.comment('=============================================================================');
  code.line();

  code.comment('Request context passed to onRequest interceptor');
  code.block('export interface RequestContext {', () => {
    code.line('headers: Record<string, string>;');
    code.line('operation: string;  // e.g., "post.list", "user.create"');
  }, '}');
  code.line();

  code.comment('API Error with HTTP-like status codes');
  code.block('export class ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line('readonly operation: string;');
    code.line('readonly details?: unknown;');
    code.line();
    code.block('constructor(message: string, status: number, code: string, operation: string, details?: unknown) {', () => {
      code.line('super(message);');
      code.line('this.name = "ApiError";');
      code.line('this.status = status;');
      code.line('this.code = code;');
      code.line('this.operation = operation;');
      code.line('this.details = details;');
    });
  }, '}');
  code.line();

  code.multiDocComment([
    'Client configuration for interceptors.',
    '',
    '@example',
    '```typescript',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("token");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      window.location.href = "/login";',
    '    }',
    '  }',
    '});',
    '```',
  ]);
  code.block('export interface ClientConfig {', () => {
    code.multiDocComment([
      'Called before each API operation.',
      'Use this to add auth headers, logging, etc.',
    ]);
    code.line('onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;');
    code.line();
    code.multiDocComment([
      'Called when an error occurs.',
      'Use this for centralized error handling (401 redirect, toast notifications, etc.)',
    ]);
    code.line('onError?: (error: ApiError) => void | Promise<void>;');
  }, '}');
  code.line();

  // Supabase error mapping
  code.comment('Map Supabase/Postgres error codes to HTTP status codes');
  code.block('function wrapSupabaseError(error: unknown, operation: string): ApiError {', () => {
    code.line('const err = error as { code?: string; message?: string; details?: unknown; hint?: string };');
    code.line('const code = err.code || "UNKNOWN_ERROR";');
    code.line('const message = err.message || "An unknown error occurred";');
    code.line('const details = err.details || err.hint;');
    code.line();
    code.comment('Map Postgres/Supabase error codes to HTTP status');
    code.line('let status = 500;');
    code.block('switch (code) {', () => {
      code.comment('Not found');
      code.line("case 'PGRST116': status = 404; break;");
      code.comment('Unique violation');
      code.line("case '23505': status = 409; break;");
      code.comment('Foreign key violation');
      code.line("case '23503': status = 400; break;");
      code.comment('Not null violation');
      code.line("case '23502': status = 400; break;");
      code.comment('Check constraint violation');
      code.line("case '23514': status = 400; break;");
      code.comment('RLS violation / insufficient privilege');
      code.line("case '42501': status = 403; break;");
      code.line("case 'PGRST301': status = 403; break;");
      code.comment('JWT expired');
      code.line("case 'PGRST302': status = 401; break;");
      code.comment('Invalid JWT');
      code.line("case 'PGRST303': status = 401; break;");
      code.comment('No rows returned (for .single())');
      code.line("case 'PGRST104': status = 404; break;");
    });
    code.line();
    code.line('return new ApiError(message, status, code, operation, details);');
  });
  code.line();

  code.comment('Extract access token from Authorization header');
  code.block('function extractAccessToken(headers: Record<string, string>): string | undefined {', () => {
    code.line("const auth = headers['Authorization'] || headers['authorization'];");
    code.line("if (auth?.startsWith('Bearer ')) {");
    code.line('  return auth.slice(7);');
    code.line('}');
    code.line('return undefined;');
  });
  code.line();
}

/**
 * Generate the ApiClient type
 */
function generateApiType(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.comment('API client type');
  code.block('export interface ApiClient {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const { name, pascalName, relations } = schema;
      const hasRelations = relations.length > 0;
      const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

      code.block(`${name}: {`, () => {
        code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) => Promise<Types.ListResponse<Types.${pascalName}>>;`);
        code.line(`get: (id: string, options?: { include?: ${includeType}[] }) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`create: (input: Types.${pascalName}Create) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`update: (id: string, input: Types.${pascalName}Update) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line('delete: (id: string) => Promise<void>;');
      }, '};');
    }
  }, '}');
}

/**
 * Generate the createClient factory function
 */
function generateCreateClientFactory(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  config: SupabaseAdapterConfig,
  schemaMap: Map<string, AnalyzedSchema>
): void {
  code.multiDocComment([
    'Create a configured API client with interceptors.',
    '',
    'Use this for production code to centralize auth and error handling.',
    '',
    '@param config - Client configuration with interceptors',
    '@returns Configured API client',
    '',
    '@example',
    '```typescript',
    "import { createClient } from './generated/client';",
    '',
    'const api = createClient({',
    '  // Add auth headers to every request',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("authToken");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '',
    '  // Centralized error handling',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      // Token expired - redirect to login',
    '      window.location.href = "/login";',
    '    }',
    '    if (error.status === 403) {',
    '      // Access denied - show notification',
    '      toast.error("Access denied");',
    '    }',
    '  }',
    '});',
    '',
    '// Now use the API - auth is automatic',
    'const posts = await api.post.list();',
    '```',
  ]);
  code.block('export function createClient(config?: ClientConfig): ApiClient {', () => {
    code.line('const interceptors = config ?? {};');
    code.line();

    code.comment('Internal helper to run request through interceptors');
    code.comment('Using any for Supabase response to avoid PostgrestResponse type complexity');
    code.block('async function executeRequest<T>(', () => {
      code.line('operation: string,');
      code.line('// eslint-disable-next-line @typescript-eslint/no-explicit-any');
      code.line('fn: (client: ReturnType<typeof getSupabaseClient>) => Promise<any>');
    }, '): Promise<T> {');
    code.indent();

    code.comment('Build request context');
    code.line('let requestCtx: RequestContext = { headers: {}, operation };');
    code.line();

    code.comment('Run onRequest interceptor (user adds auth headers here)');
    code.block('if (interceptors.onRequest) {', () => {
      code.line('requestCtx = await interceptors.onRequest(requestCtx);');
    });
    code.line();

    code.comment('Get Supabase client with auth token if provided');
    code.line('const accessToken = extractAccessToken(requestCtx.headers);');
    code.line('const client = getSupabaseClient(accessToken);');
    code.line();

    code.block('try {', () => {
      code.line('const { data, error } = await fn(client);');
      code.block('if (error) {', () => {
        code.line('throw wrapSupabaseError(error, operation);');
      });
      code.line('return data as T;');
    }, '} catch (err) {');
    code.indent();
    code.comment('Enhance error if not already ApiError');
    code.line('const error = err instanceof ApiError ? err : wrapSupabaseError(err, operation);');
    code.line();
    code.comment('Run onError interceptor');
    code.block('if (interceptors.onError) {', () => {
      code.line('await interceptors.onError(error);');
    });
    code.line();
    code.line('throw error;');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();

    code.comment('Helper for list requests that return data + count');
    code.comment('Using any for Supabase response to avoid PostgrestResponse type complexity');
    code.block('async function executeListRequest<T>(', () => {
      code.line('operation: string,');
      code.line('// eslint-disable-next-line @typescript-eslint/no-explicit-any');
      code.line('fn: (client: ReturnType<typeof getSupabaseClient>) => Promise<any>');
    }, '): Promise<{ data: T[]; count: number | null }> {');
    code.indent();

    code.line('let requestCtx: RequestContext = { headers: {}, operation };');
    code.block('if (interceptors.onRequest) {', () => {
      code.line('requestCtx = await interceptors.onRequest(requestCtx);');
    });
    code.line();
    code.line('const accessToken = extractAccessToken(requestCtx.headers);');
    code.line('const client = getSupabaseClient(accessToken);');
    code.line();

    code.block('try {', () => {
      code.line('const { data, error, count } = await fn(client);');
      code.block('if (error) {', () => {
        code.line('throw wrapSupabaseError(error, operation);');
      });
      code.line('return { data: (data || []) as T[], count };');
    }, '} catch (err) {');
    code.indent();
    code.line('const error = err instanceof ApiError ? err : wrapSupabaseError(err, operation);');
    code.block('if (interceptors.onError) {', () => {
      code.line('await interceptors.onError(error);');
    });
    code.line('throw error;');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();

    code.comment('Build API client with all entity methods');
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        generateSupabaseEntityApiFactory(code, schema, config, schemaMap);
      }
    }, '};');
  });
}

/**
 * Generate Supabase API methods for a single entity (factory version with interceptors)
 */
function generateSupabaseEntityApiFactory(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: SupabaseAdapterConfig,
  schemaMap: Map<string, AnalyzedSchema>
): void {
  const { name, pascalName, tableName, relations } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  code.block(`${name}: {`, () => {
    // LIST
    code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) =>`);
    code.indent();
    code.line(`executeListRequest<Types.${pascalName}>('${name}.list', async (client) => {`);
    code.indent();
    code.line(`const select = buildSelect('${name}', options?.include);`);
    code.line(`let query = client.from('${tableName}').select(select, { count: 'exact' });`);
    code.line();

    // Filters
    code.block('if (options?.where) {', () => {
      code.block('for (const [key, value] of Object.entries(options.where)) {', () => {
        code.block('if (typeof value === "object" && value !== null) {', () => {
          code.line('const f = value as Record<string, unknown>;');
          code.line("if ('equals' in f) query = query.eq(key, f.equals);");
          code.line("if ('not' in f) query = query.neq(key, f.not);");
          code.line("if ('in' in f) query = query.in(key, f.in as unknown[]);");
          code.line("if ('notIn' in f) query = query.not(key, 'in', `(${(f.notIn as unknown[]).join(',')})`);");
          code.line("if ('contains' in f) query = query.ilike(key, `%${f.contains}%`);");
          code.line("if ('startsWith' in f) query = query.ilike(key, `${f.startsWith}%`);");
          code.line("if ('endsWith' in f) query = query.ilike(key, `%${f.endsWith}`);");
          code.line("if ('gt' in f) query = query.gt(key, f.gt);");
          code.line("if ('gte' in f) query = query.gte(key, f.gte);");
          code.line("if ('lt' in f) query = query.lt(key, f.lt);");
          code.line("if ('lte' in f) query = query.lte(key, f.lte);");
          code.line("if ('isNull' in f) f.isNull ? query = query.is(key, null) : query = query.not(key, 'is', null);");
        }, '} else {');
        code.indent();
        code.line('query = query.eq(key, value);');
        code.dedent();
        code.line('}');
      });
    });
    code.line();

    // Ordering
    code.block('if (options?.orderBy) {', () => {
      code.block('for (const [field, dir] of Object.entries(options.orderBy)) {', () => {
        code.line("query = query.order(field, { ascending: dir === 'asc' });");
      });
    });
    code.line();

    // Pagination
    code.line('const limit = options?.limit ?? 20;');
    code.line('const offset = options?.offset ?? 0;');
    code.line('query = query.range(offset, offset + limit - 1);');
    code.line();

    code.line('return await query;');
    code.dedent();
    code.line('}).then(({ data, count }) => ({');
    code.line(`  data: data as Types.${pascalName}[],`);
    code.line('  meta: {');
    code.line('    total: count || 0,');
    code.line('    limit: options?.limit ?? 20,');
    code.line('    offset: options?.offset ?? 0,');
    code.line('    hasMore: (options?.offset ?? 0) + (options?.limit ?? 20) < (count || 0),');
    code.line('  },');
    code.line('})),');
    code.dedent();
    code.line();

    // GET
    code.line(`get: (id: string, options?: { include?: ${includeType}[] }) =>`);
    code.indent();
    code.line(`executeRequest<Types.${pascalName}>('${name}.get', async (client) => {`);
    code.indent();
    code.line(`const select = buildSelect('${name}', options?.include);`);
    code.line(`return await client.from('${tableName}').select(select).eq('id', id).single();`);
    code.dedent();
    code.line(`}).then(data => ({ data: data as Types.${pascalName} })),`);
    code.dedent();
    code.line();

    // CREATE (with nested relation support)
    generateSupabaseCreateMethodFactory(code, schema, config, schemaMap);
    code.line();

    // UPDATE
    code.line(`update: (id: string, input: Types.${pascalName}Update) =>`);
    code.indent();
    code.line(`executeRequest<Types.${pascalName}>('${name}.update', async (client) => {`);
    code.indent();
    code.line(`return await client.from('${tableName}').update(input).eq('id', id).select().single();`);
    code.dedent();
    code.line(`}).then(data => ({ data: data as Types.${pascalName} })),`);
    code.dedent();
    code.line();

    // DELETE
    code.line('delete: (id: string) =>');
    code.indent();
    code.line(`executeRequest<null>('${name}.delete', async (client) => {`);
    code.indent();
    code.line(`return await client.from('${tableName}').delete().eq('id', id);`);
    code.dedent();
    code.line('}).then(() => undefined),');
    code.dedent();
  }, '},');
  code.line();
}

/**
 * Generate Supabase create method with nested relation support (factory version)
 *
 * Supports:
 * - hasMany: Create parent first, then children with FK pointing to parent
 * - hasOne: Create parent first, then child with FK pointing to parent
 * - belongsTo: Create target first, then parent with FK pointing to target
 */
function generateSupabaseCreateMethodFactory(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: SupabaseAdapterConfig,
  schemaMap: Map<string, AnalyzedSchema>
): void {
  const { name, pascalName, tableName, relations } = schema;
  const childRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');
  const parentRels = relations.filter((r) => r.type === 'belongsTo');
  const hasNestedRels = childRels.length > 0 || parentRels.length > 0;

  code.line(`create: (input: Types.${pascalName}Create) =>`);
  code.indent();
  code.line(`executeRequest<Types.${pascalName}>('${name}.create', async (client) => {`);
  code.indent();

  if (hasNestedRels) {
    const allRelNames = [...childRels, ...parentRels].map((r) => r.name).join(', ');
    code.line(`const { ${allRelNames}, ...data } = input;`);
    code.line('// eslint-disable-next-line @typescript-eslint/no-explicit-any');
    code.line('const insertData: Record<string, any> = { ...data };');
    code.line();

    // Handle belongsTo relations first - create parent, then use its ID
    if (parentRels.length > 0) {
      code.comment('Handle belongsTo relations - create parent first');
      for (const rel of parentRels) {
        const targetSchema = schemaMap.get(rel.resolvedTarget);
        const targetTable = config.tableMap?.[rel.resolvedTarget] ?? targetSchema?.tableName ?? rel.resolvedTarget + 's';
        const fkField = rel.localField || rel.foreignKey;

        code.block(`if (${rel.name}) {`, () => {
          code.line(`const parentResult = await client.from('${targetTable}').insert(${rel.name}).select().single();`);
          code.line('if (parentResult.error) return parentResult as { data: null; error: unknown };');
          code.line(`insertData.${fkField} = parentResult.data.id;`);
        });
      }
      code.line();
    }

    // Now create the main entity
    code.line(`const result = await client.from('${tableName}').insert(insertData).select().single();`);
    code.line('if (result.error) return result;');
    code.line('const item = result.data;');
    code.line();

    // Handle hasMany/hasOne relations - create children after parent
    if (childRels.length > 0) {
      code.comment('Handle hasMany/hasOne relations - create children after parent');
      for (const rel of childRels) {
        const targetSchema = schemaMap.get(rel.resolvedTarget);
        const targetTable = config.tableMap?.[rel.resolvedTarget] ?? targetSchema?.tableName ?? rel.resolvedTarget + 's';
        code.block(`if (${rel.name}) {`, () => {
          if (rel.type === 'hasMany') {
            code.line(`const nestedData = ${rel.name}.map(nested => ({ ...nested, ${rel.foreignKey}: item.id }));`);
            code.line(`const nestedResult = await client.from('${targetTable}').insert(nestedData);`);
            code.line('if (nestedResult.error) return nestedResult as { data: null; error: unknown };');
          } else {
            code.line(`const nestedResult = await client.from('${targetTable}').insert({ ...${rel.name}, ${rel.foreignKey}: item.id });`);
            code.line('if (nestedResult.error) return nestedResult as { data: null; error: unknown };');
          }
        });
      }
    }

    code.line();
    code.line('return { data: item, error: null };');
  } else {
    code.line(`return await client.from('${tableName}').insert(input).select().single();`);
  }

  code.dedent();
  code.line(`}).then(data => ({ data: data as Types.${pascalName} })),`);
  code.dedent();
}
