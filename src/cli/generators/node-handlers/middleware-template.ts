/**
 * Node.js Middleware Templates
 *
 * Generates Express-compatible middleware for auth and validation.
 *
 * @module cli/generators/node-handlers/middleware-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget } from '../../types';

/**
 * Generate auth middleware for Node.js
 */
export function generateNodeMiddleware(target: GenerationTarget): string {
  const authConfig = target.middleware?.auth;
  if (!authConfig) return '';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
  ];

  // Provider-specific imports
  if (authConfig.provider === 'supabase-auth') {
    lines.push("import { supabase } from '../db';");
  } else if (authConfig.provider === 'jwt') {
    lines.push("import jwt from 'jsonwebtoken';");
  }

  lines.push('');
  lines.push('/**');
  lines.push(' * Authenticated user attached to request');
  lines.push(' */');
  lines.push('export interface AuthUser {');
  lines.push('  id: string;');
  lines.push('  email?: string;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Extend Express Request with user');
  lines.push(' */');
  lines.push("declare module 'express' {");
  lines.push('  interface Request {');
  lines.push('    user?: AuthUser;');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Auth middleware - validates request authentication');
  lines.push(' */');
  lines.push('export async function authMiddleware(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');

  if (authConfig.provider === 'supabase-auth') {
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push('    const { data: { user }, error } = await supabase.auth.getUser(token);');
    lines.push('');
    lines.push('    if (error || !user) {');
    lines.push("      res.status(401).json({ error: 'Invalid or expired token' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    req.user = { id: user.id, email: user.email };');
    lines.push('    next();');
    lines.push('  } catch (error) {');
    lines.push("    res.status(401).json({ error: 'Authentication failed' });");
    lines.push('  }');
  } else if (authConfig.provider === 'jwt') {
    const secretEnvVar = authConfig.secretEnvVar || 'JWT_SECRET';
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push(`    const secret = process.env.${secretEnvVar};`);
    lines.push('    if (!secret) {');
    lines.push(`      throw new Error('${secretEnvVar} environment variable not set');`);
    lines.push('    }');
    lines.push('');
    lines.push('    const decoded = jwt.verify(token, secret) as { sub: string; email?: string };');
    lines.push('    req.user = { id: decoded.sub, email: decoded.email };');
    lines.push('    next();');
    lines.push('  } catch (error) {');
    lines.push("    res.status(401).json({ error: 'Invalid or expired token' });");
    lines.push('  }');
  } else if (authConfig.provider === 'custom') {
    lines.push('  // Custom auth implementation');
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push('');
    lines.push('  if (!authHeader) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  // TODO: Implement your custom auth logic here');
    lines.push('  // Example:');
    lines.push('  // const user = await validateCustomToken(authHeader);');
    lines.push('  // if (!user) {');
    lines.push("  //   res.status(401).json({ error: 'Invalid token' });");
    lines.push('  //   return;');
    lines.push('  // }');
    lines.push('  // req.user = user;');
    lines.push('');
    lines.push("  req.user = { id: 'custom-user-id' };");
    lines.push('  next();');
  } else {
    // Fallback for unsupported providers
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push('');
    lines.push('  if (!authHeader) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  // TODO: Implement auth for provider: ' + authConfig.provider);
    lines.push("  req.user = { id: 'unknown' };");
    lines.push('  next();');
  }

  lines.push('}');
  lines.push('');

  // Optional: Add requireAuth wrapper
  lines.push('/**');
  lines.push(' * Higher-order function to require auth for specific routes');
  lines.push(' */');
  lines.push('export function requireAuth(');
  lines.push('  handler: (req: Request, res: Response, next: NextFunction) => Promise<void>');
  lines.push(') {');
  lines.push('  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {');
  lines.push('    if (!req.user) {');
  lines.push("      res.status(401).json({ error: 'Authentication required' });");
  lines.push('      return;');
  lines.push('    }');
  lines.push('    await handler(req, res, next);');
  lines.push('  };');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate validation middleware for Node.js
 */
export function generateNodeValidation(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '/**',
    ' * Validation error type',
    ' */',
    'export interface ValidationError {',
    '  field: string;',
    '  message: string;',
    '}',
    '',
    '/**',
    ' * Validation result type',
    ' */',
    'export interface ValidationResult<T = unknown> {',
    '  valid: boolean;',
    '  errors?: ValidationError[];',
    '  data?: T;',
    '}',
    '',
    '/**',
    ' * Email validation regex',
    ' */',
    'const EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
    '',
    '/**',
    ' * URL validation regex',
    ' */',
    'const URL_REGEX = /^https?:\\/\\/.+/;',
    '',
  ];

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    // Create validation function
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} creation data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}(data: unknown): ValidationResult {`);
    lines.push('  const errors: ValidationError[] = [];');
    lines.push('');
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push('  }');
    lines.push('');
    lines.push('  const obj = data as Record<string, unknown>;');
    lines.push('');

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const isRequired = !field.nullable && !field.hasDefault;

      // Required check
      if (isRequired) {
        lines.push(`  if (obj.${field.name} === undefined || obj.${field.name} === null) {`);
        lines.push(`    errors.push({ field: '${field.name}', message: '${field.name} is required' });`);
        lines.push('  }');
      }

      // Type-specific validation
      lines.push(`  if (obj.${field.name} !== undefined && obj.${field.name} !== null) {`);

      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        lines.push(`    if (typeof obj.${field.name} !== 'string') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a string' });`);
        lines.push('    } else {');

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min} characters' });`);
          lines.push('      }');
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max} characters' });`);
          lines.push('      }');
        }

        if (field.type === 'email') {
          lines.push(`      if (!EMAIL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid email format' });`);
          lines.push('      }');
        }

        if (field.type === 'url') {
          lines.push(`      if (!URL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid URL format' });`);
          lines.push('      }');
        }

        if (field.pattern) {
          lines.push(`      if (!/${field.pattern}/.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid format' });`);
          lines.push('      }');
        }

        lines.push('    }');
      } else if (field.type === 'int' || field.type === 'float' || field.type === 'number') {
        lines.push(`    if (typeof obj.${field.name} !== 'number') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a number' });`);
        lines.push('    } else {');

        if (field.type === 'int') {
          lines.push(`      if (!Number.isInteger(obj.${field.name})) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be an integer' });`);
          lines.push('      }');
        }

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min}' });`);
          lines.push('      }');
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max}' });`);
          lines.push('      }');
        }

        lines.push('    }');
      } else if (field.type === 'boolean') {
        lines.push(`    if (typeof obj.${field.name} !== 'boolean') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a boolean' });`);
        lines.push('    }');
      } else if (field.isEnum && field.enumValues) {
        const enumVals = field.enumValues.map((v) => `'${v}'`).join(', ');
        lines.push(`    if (![${enumVals}].includes(obj.${field.name} as string)) {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be one of: ${field.enumValues.join(', ')}' });`);
        lines.push('    }');
      }

      lines.push('  }');
      lines.push('');
    }

    lines.push('  return errors.length > 0 ? { valid: false, errors } : { valid: true, data: obj };');
    lines.push('}');
    lines.push('');

    // Update validation function (all fields optional)
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} update data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}Update(data: unknown): ValidationResult {`);
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push('  }');
    lines.push('');
    lines.push('  const obj = data as Record<string, unknown>;');
    lines.push('');
    lines.push('  // For updates, all fields are optional but must be valid if present');
    lines.push(`  const fullValidation = validate${schema.pascalName}({ ...obj });`);
    lines.push('');
    lines.push("  // Filter out 'required' errors for updates");
    lines.push('  const updateErrors = fullValidation.errors?.filter(');
    lines.push("    (err) => !err.message.includes('is required')");
    lines.push('  ) || [];');
    lines.push('');
    lines.push('  return updateErrors.length > 0 ? { valid: false, errors: updateErrors } : { valid: true, data: obj };');
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}
