/**
 * Node.js Middleware Templates
 *
 * Generates Express-compatible middleware for auth, validation, rate limiting,
 * caching, logging, context extraction, RLS, and custom middleware.
 *
 * @module cli/generators/node-handlers/middleware-template
 * @category CLI
 */

import type {
  AnalyzedSchema,
  GenerationTarget,
  MiddlewareConfig,
  AuthMiddlewareConfig,
  RateLimitMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
  AnalyzedMiddleware,
} from '../../types';
import {
  normalizeAuthConfig,
  normalizeLoggerConfig,
  normalizeCacheConfig,
} from './middleware-chain-template';

/**
 * Generate auth middleware for Node.js
 */
export function generateNodeMiddleware(target: GenerationTarget): string {
  const authConfig = target.middleware?.auth;
  if (!authConfig) return '';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
  ];

  // Provider-specific imports
  if (authConfig.provider === 'supabase-auth') {
    lines.push("import { supabase } from '../db';");
  } else if (authConfig.provider === 'jwt') {
    lines.push("import jwt from 'jsonwebtoken';");
  }

  lines.push('');
  lines.push('/**');
  lines.push(' * Authenticated user attached to request');
  lines.push(' */');
  lines.push('export interface AuthUser {');
  lines.push('  id: string;');
  lines.push('  email?: string;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Extend Express Request with user');
  lines.push(' */');
  lines.push("declare module 'express' {");
  lines.push('  interface Request {');
  lines.push('    user?: AuthUser;');
  lines.push('  }');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Auth middleware - validates request authentication');
  lines.push(' */');
  lines.push('export async function authMiddleware(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');

  if (authConfig.provider === 'supabase-auth') {
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push('    const { data: { user }, error } = await supabase.auth.getUser(token);');
    lines.push('');
    lines.push('    if (error || !user) {');
    lines.push("      res.status(401).json({ error: 'Invalid or expired token' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    req.user = { id: user.id, email: user.email };');
    lines.push('    next();');
    lines.push('  } catch (error) {');
    lines.push("    res.status(401).json({ error: 'Authentication failed' });");
    lines.push('  }');
  } else if (authConfig.provider === 'jwt') {
    const secretEnvVar = authConfig.secretEnvVar || 'JWT_SECRET';
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push(`    const secret = process.env.${secretEnvVar};`);
    lines.push('    if (!secret) {');
    lines.push(`      throw new Error('${secretEnvVar} environment variable not set');`);
    lines.push('    }');
    lines.push('');
    lines.push('    const decoded = jwt.verify(token, secret) as { sub: string; email?: string };');
    lines.push('    req.user = { id: decoded.sub, email: decoded.email };');
    lines.push('    next();');
    lines.push('  } catch (error) {');
    lines.push("    res.status(401).json({ error: 'Invalid or expired token' });");
    lines.push('  }');
  } else if (authConfig.provider === 'custom') {
    lines.push('  // Custom auth implementation');
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push('');
    lines.push('  if (!authHeader) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  // TODO: Implement your custom auth logic here');
    lines.push('  // Example:');
    lines.push('  // const user = await validateCustomToken(authHeader);');
    lines.push('  // if (!user) {');
    lines.push("  //   res.status(401).json({ error: 'Invalid token' });");
    lines.push('  //   return;');
    lines.push('  // }');
    lines.push('  // req.user = user;');
    lines.push('');
    lines.push("  req.user = { id: 'custom-user-id' };");
    lines.push('  next();');
  } else {
    // Fallback for unsupported providers
    lines.push("  const authHeader = req.headers.authorization;");
    lines.push('');
    lines.push('  if (!authHeader) {');
    lines.push("    res.status(401).json({ error: 'Missing authorization header' });");
    lines.push('    return;');
    lines.push('  }');
    lines.push('');
    lines.push('  // TODO: Implement auth for provider: ' + authConfig.provider);
    lines.push("  req.user = { id: 'unknown' };");
    lines.push('  next();');
  }

  lines.push('}');
  lines.push('');

  // Optional: Add requireAuth wrapper
  lines.push('/**');
  lines.push(' * Higher-order function to require auth for specific routes');
  lines.push(' */');
  lines.push('export function requireAuth(');
  lines.push('  handler: (req: Request, res: Response, next: NextFunction) => Promise<void>');
  lines.push(') {');
  lines.push('  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {');
  lines.push('    if (!req.user) {');
  lines.push("      res.status(401).json({ error: 'Authentication required' });");
  lines.push('      return;');
  lines.push('    }');
  lines.push('    await handler(req, res, next);');
  lines.push('  };');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate validation middleware for Node.js
 */
export function generateNodeValidation(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '/**',
    ' * Validation error type',
    ' */',
    'export interface ValidationError {',
    '  field: string;',
    '  message: string;',
    '}',
    '',
    '/**',
    ' * Validation result type',
    ' */',
    'export interface ValidationResult<T = unknown> {',
    '  valid: boolean;',
    '  errors?: ValidationError[];',
    '  data?: T;',
    '}',
    '',
    '/**',
    ' * Email validation regex',
    ' */',
    'const EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
    '',
    '/**',
    ' * URL validation regex',
    ' */',
    'const URL_REGEX = /^https?:\\/\\/.+/;',
    '',
  ];

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    // Create validation function
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} creation data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}(data: unknown): ValidationResult {`);
    lines.push('  const errors: ValidationError[] = [];');
    lines.push('');
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push('  }');
    lines.push('');
    lines.push('  const obj = data as Record<string, unknown>;');
    lines.push('');

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const isRequired = !field.nullable && !field.hasDefault;

      // Required check
      if (isRequired) {
        lines.push(`  if (obj.${field.name} === undefined || obj.${field.name} === null) {`);
        lines.push(`    errors.push({ field: '${field.name}', message: '${field.name} is required' });`);
        lines.push('  }');
      }

      // Type-specific validation
      lines.push(`  if (obj.${field.name} !== undefined && obj.${field.name} !== null) {`);

      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        lines.push(`    if (typeof obj.${field.name} !== 'string') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a string' });`);
        lines.push('    } else {');

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min} characters' });`);
          lines.push('      }');
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max} characters' });`);
          lines.push('      }');
        }

        if (field.type === 'email') {
          lines.push(`      if (!EMAIL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid email format' });`);
          lines.push('      }');
        }

        if (field.type === 'url') {
          lines.push(`      if (!URL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid URL format' });`);
          lines.push('      }');
        }

        if (field.pattern) {
          lines.push(`      if (!/${field.pattern}/.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid format' });`);
          lines.push('      }');
        }

        lines.push('    }');
      } else if (field.type === 'int' || field.type === 'float' || field.type === 'number') {
        lines.push(`    if (typeof obj.${field.name} !== 'number') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a number' });`);
        lines.push('    } else {');

        if (field.type === 'int') {
          lines.push(`      if (!Number.isInteger(obj.${field.name})) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be an integer' });`);
          lines.push('      }');
        }

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min}' });`);
          lines.push('      }');
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max}' });`);
          lines.push('      }');
        }

        lines.push('    }');
      } else if (field.type === 'boolean') {
        lines.push(`    if (typeof obj.${field.name} !== 'boolean') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a boolean' });`);
        lines.push('    }');
      } else if (field.isEnum && field.enumValues) {
        const enumVals = field.enumValues.map((v) => `'${v}'`).join(', ');
        lines.push(`    if (![${enumVals}].includes(obj.${field.name} as string)) {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be one of: ${field.enumValues.join(', ')}' });`);
        lines.push('    }');
      }

      lines.push('  }');
      lines.push('');
    }

    lines.push('  return errors.length > 0 ? { valid: false, errors } : { valid: true, data: obj };');
    lines.push('}');
    lines.push('');

    // Update validation function (all fields optional)
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} update data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}Update(data: unknown): ValidationResult {`);
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push('  }');
    lines.push('');
    lines.push('  const obj = data as Record<string, unknown>;');
    lines.push('');
    lines.push('  // For updates, all fields are optional but must be valid if present');
    lines.push(`  const fullValidation = validate${schema.pascalName}({ ...obj });`);
    lines.push('');
    lines.push("  // Filter out 'required' errors for updates");
    lines.push('  const updateErrors = fullValidation.errors?.filter(');
    lines.push("    (err) => !err.message.includes('is required')");
    lines.push('  ) || [];');
    lines.push('');
    lines.push('  return updateErrors.length > 0 ? { valid: false, errors: updateErrors } : { valid: true, data: obj };');
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate rate limit middleware for Node.js
 */
export function generateRateLimitMiddleware(config: RateLimitMiddlewareConfig): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
    '/**',
    ' * Rate limit store - tracks request counts per key',
    ' */',
    'interface RateLimitEntry {',
    '  count: number;',
    '  resetTime: number;',
    '}',
    '',
    'const rateLimitStore = new Map<string, RateLimitEntry>();',
    '',
    '/**',
    ' * Rate limit configuration',
    ' */',
    `const RATE_LIMIT_MAX = ${config.max};`,
    `const RATE_LIMIT_WINDOW_MS = ${config.windowMs};`,
    '',
    '/**',
    ' * Get rate limit key from request',
    ' */',
    'function getRateLimitKey(req: Request): string {',
  ];

  // Key generator based on config
  if (config.keyGenerator === 'user') {
    lines.push("  // User-based rate limiting");
    lines.push("  if ((req as any).user?.id) {");
    lines.push("    return `user:${(req as any).user.id}`;");
    lines.push("  }");
    lines.push("  // Fallback to IP if no user");
  }

  lines.push("  const forwarded = req.headers['x-forwarded-for'];");
  lines.push("  const ip = typeof forwarded === 'string'");
  lines.push("    ? forwarded.split(',')[0].trim()");
  lines.push("    : req.socket.remoteAddress || 'unknown';");
  lines.push("  return `ip:${ip}`;");
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Clean up expired entries periodically');
  lines.push(' */');
  lines.push('setInterval(() => {');
  lines.push('  const now = Date.now();');
  lines.push('  for (const [key, entry] of rateLimitStore.entries()) {');
  lines.push('    if (now > entry.resetTime) {');
  lines.push('      rateLimitStore.delete(key);');
  lines.push('    }');
  lines.push('  }');
  lines.push('}, RATE_LIMIT_WINDOW_MS);');
  lines.push('');

  lines.push('/**');
  lines.push(' * Rate limit middleware');
  lines.push(' */');
  lines.push('export function rateLimitMiddleware(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): void {');
  lines.push('  const key = getRateLimitKey(req);');
  lines.push('  const now = Date.now();');
  lines.push('');
  lines.push('  let entry = rateLimitStore.get(key);');
  lines.push('');
  lines.push('  if (!entry || now > entry.resetTime) {');
  lines.push('    // Create new entry or reset expired one');
  lines.push('    entry = { count: 1, resetTime: now + RATE_LIMIT_WINDOW_MS };');
  lines.push('    rateLimitStore.set(key, entry);');
  lines.push('  } else {');
  lines.push('    entry.count++;');
  lines.push('  }');
  lines.push('');
  lines.push('  // Set rate limit headers');
  lines.push("  res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX.toString());");
  lines.push("  res.setHeader('X-RateLimit-Remaining', Math.max(0, RATE_LIMIT_MAX - entry.count).toString());");
  lines.push("  res.setHeader('X-RateLimit-Reset', Math.ceil(entry.resetTime / 1000).toString());");
  lines.push('');
  lines.push('  if (entry.count > RATE_LIMIT_MAX) {');
  lines.push("    res.setHeader('Retry-After', Math.ceil((entry.resetTime - now) / 1000).toString());");
  lines.push("    res.status(429).json({");
  lines.push("      error: 'Too many requests',");
  lines.push("      message: `Rate limit exceeded. Try again in ${Math.ceil((entry.resetTime - now) / 1000)} seconds.`,");
  lines.push('    });');
  lines.push('    return;');
  lines.push('  }');
  lines.push('');
  lines.push('  next();');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate cache middleware for Node.js
 */
export function generateCacheMiddleware(config: CacheMiddlewareConfig): string {
  const operations = config.operations ?? ['findOne', 'findMany'];

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
    '/**',
    ' * Cache entry structure',
    ' */',
    'interface CacheEntry {',
    '  data: unknown;',
    '  expires: number;',
    '}',
    '',
    'const cache = new Map<string, CacheEntry>();',
    '',
    '/**',
    ' * Cache configuration',
    ' */',
    `const CACHE_TTL = ${config.ttl};`,
    `const CACHEABLE_METHODS = new Set(['GET']);`,
    '',
    '/**',
    ' * Generate cache key from request',
    ' */',
    'function getCacheKey(req: Request): string {',
    '  const userId = (req as any).user?.id || "anonymous";',
    '  return `${userId}:${req.method}:${req.originalUrl}`;',
    '}',
    '',
    '/**',
    ' * Check if request is cacheable',
    ' */',
    'function isCacheable(req: Request): boolean {',
    '  if (!CACHEABLE_METHODS.has(req.method)) return false;',
    '',
  ];

  // Check for specific operations based on config
  if (operations.includes('findMany') && !operations.includes('findOne')) {
    lines.push("  // Only cache list operations (findMany)");
    lines.push("  return !req.params.id;");
  } else if (operations.includes('findOne') && !operations.includes('findMany')) {
    lines.push("  // Only cache single item operations (findOne)");
    lines.push("  return !!req.params.id;");
  } else {
    lines.push("  // Cache both findOne and findMany operations");
    lines.push("  return true;");
  }

  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Clean up expired entries');
  lines.push(' */');
  lines.push('setInterval(() => {');
  lines.push('  const now = Date.now();');
  lines.push('  for (const [key, entry] of cache.entries()) {');
  lines.push('    if (now > entry.expires) {');
  lines.push('      cache.delete(key);');
  lines.push('    }');
  lines.push('  }');
  lines.push('}, CACHE_TTL);');
  lines.push('');

  lines.push('/**');
  lines.push(' * Invalidate cache entries matching a pattern');
  lines.push(' */');
  lines.push('export function invalidateCache(pattern?: string): void {');
  lines.push('  if (!pattern) {');
  lines.push('    cache.clear();');
  lines.push('    return;');
  lines.push('  }');
  lines.push('  for (const key of cache.keys()) {');
  lines.push('    if (key.includes(pattern)) {');
  lines.push('      cache.delete(key);');
  lines.push('    }');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Cache middleware');
  lines.push(' */');
  lines.push('export function cacheMiddleware(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): void {');
  lines.push('  if (!isCacheable(req)) {');
  lines.push('    return next();');
  lines.push('  }');
  lines.push('');
  lines.push('  const key = getCacheKey(req);');
  lines.push('  const cached = cache.get(key);');
  lines.push('');
  lines.push('  if (cached && Date.now() < cached.expires) {');
  lines.push("    res.setHeader('X-Cache', 'HIT');");
  lines.push('    res.json(cached.data);');
  lines.push('    return;');
  lines.push('  }');
  lines.push('');
  lines.push("  res.setHeader('X-Cache', 'MISS');");
  lines.push('');
  lines.push('  // Override res.json to cache the response');
  lines.push('  const originalJson = res.json.bind(res);');
  lines.push('  res.json = function (data: unknown) {');
  lines.push('    if (res.statusCode >= 200 && res.statusCode < 300) {');
  lines.push('      cache.set(key, {');
  lines.push('        data,');
  lines.push('        expires: Date.now() + CACHE_TTL,');
  lines.push('      });');
  lines.push('    }');
  lines.push('    return originalJson(data);');
  lines.push('  };');
  lines.push('');
  lines.push('  next();');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate logger middleware for Node.js
 */
export function generateLoggerMiddleware(config: LoggerMiddlewareConfig): string {
  const level = config.level ?? 'info';
  const includeBody = config.includeBody ?? false;
  const includeResponse = config.includeResponse ?? false;
  const redactFields = config.redactFields ?? ['password', 'token', 'secret', 'apiKey'];

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
    '/**',
    ' * Log levels',
    ' */',
    "type LogLevel = 'debug' | 'info' | 'warn' | 'error';",
    '',
    'const LOG_LEVELS: Record<LogLevel, number> = {',
    '  debug: 0,',
    '  info: 1,',
    '  warn: 2,',
    '  error: 3,',
    '};',
    '',
    `const CURRENT_LEVEL: LogLevel = '${level}';`,
    '',
    '/**',
    ' * Fields to redact from logs',
    ' */',
    `const REDACT_FIELDS = new Set(${JSON.stringify(redactFields)});`,
    '',
    '/**',
    ' * Redact sensitive fields from an object',
    ' */',
    'function redact<T extends Record<string, unknown>>(obj: T): T {',
    '  const result = { ...obj };',
    '  for (const key of Object.keys(result)) {',
    '    if (REDACT_FIELDS.has(key.toLowerCase())) {',
    "      result[key] = '[REDACTED]' as any;",
    '    } else if (typeof result[key] === "object" && result[key] !== null) {',
    '      result[key] = redact(result[key] as Record<string, unknown>) as any;',
    '    }',
    '  }',
    '  return result;',
    '}',
    '',
    '/**',
    ' * Log a message at the specified level',
    ' */',
    'function log(level: LogLevel, message: string, data?: Record<string, unknown>): void {',
    '  if (LOG_LEVELS[level] < LOG_LEVELS[CURRENT_LEVEL]) return;',
    '',
    '  const timestamp = new Date().toISOString();',
    '  const logData = {',
    '    timestamp,',
    '    level,',
    '    message,',
    '    ...data,',
    '  };',
    '',
    "  if (level === 'error') {",
    '    console.error(JSON.stringify(logData));',
    "  } else if (level === 'warn') {",
    '    console.warn(JSON.stringify(logData));',
    '  } else {',
    '    console.log(JSON.stringify(logData));',
    '  }',
    '}',
    '',
    '/**',
    ' * Logger middleware',
    ' */',
    'export function loggerMiddleware(',
    '  req: Request,',
    '  res: Response,',
    '  next: NextFunction',
    '): void {',
    '  const start = Date.now();',
    '  const requestId = req.headers["x-request-id"] || crypto.randomUUID();',
    '',
    '  // Log request',
    '  const requestData: Record<string, unknown> = {',
    '    requestId,',
    '    method: req.method,',
    '    path: req.path,',
    '    query: redact(req.query as Record<string, unknown>),',
    '    userAgent: req.headers["user-agent"],',
    '    ip: req.ip || req.socket.remoteAddress,',
    '  };',
    '',
  ];

  if (includeBody) {
    lines.push("  if (req.body && Object.keys(req.body).length > 0) {");
    lines.push("    requestData.body = redact(req.body);");
    lines.push("  }");
    lines.push('');
  }

  lines.push("  log('info', 'Request received', requestData);");
  lines.push('');

  if (includeResponse) {
    lines.push('  // Capture response for logging');
    lines.push('  const originalJson = res.json.bind(res);');
    lines.push('  let responseBody: unknown;');
    lines.push('  res.json = function (data: unknown) {');
    lines.push('    responseBody = data;');
    lines.push('    return originalJson(data);');
    lines.push('  };');
    lines.push('');
  }

  lines.push("  res.on('finish', () => {");
  lines.push('    const duration = Date.now() - start;');
  lines.push('    const responseData: Record<string, unknown> = {');
  lines.push('      requestId,');
  lines.push('      method: req.method,');
  lines.push('      path: req.path,');
  lines.push('      statusCode: res.statusCode,');
  lines.push('      duration: `${duration}ms`,');
  lines.push('    };');
  lines.push('');

  if (includeResponse) {
    lines.push('    if (responseBody) {');
    lines.push("      responseData.response = typeof responseBody === 'object'");
    lines.push('        ? redact(responseBody as Record<string, unknown>)');
    lines.push('        : responseBody;');
    lines.push('    }');
    lines.push('');
  }

  lines.push('    const level: LogLevel = res.statusCode >= 500');
  lines.push("      ? 'error'");
  lines.push('      : res.statusCode >= 400');
  lines.push("        ? 'warn'");
  lines.push("        : 'info';");
  lines.push('');
  lines.push("    log(level, 'Response sent', responseData);");
  lines.push('  });');
  lines.push('');
  lines.push('  next();');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate context middleware for Node.js
 * Extracts user context from JWT or headers
 */
export function generateContextMiddleware(): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
    '/**',
    ' * Request context extracted from JWT/headers',
    ' */',
    'export interface RequestContext {',
    '  userId?: string;',
    '  role?: string;',
    '  tenantId?: string;',
    '  [key: string]: unknown;',
    '}',
    '',
    '/**',
    ' * Extend Express Request with context',
    ' */',
    "declare module 'express' {",
    '  interface Request {',
    '    context: RequestContext;',
    '  }',
    '}',
    '',
    '/**',
    ' * Decode JWT payload without verification',
    ' * Note: Verification should be done by auth middleware',
    ' */',
    'function decodeJwtPayload(token: string): Record<string, unknown> | null {',
    '  try {',
    "    const parts = token.split('.');",
    '    if (parts.length !== 3) return null;',
    '    const payload = Buffer.from(parts[1], "base64url").toString("utf-8");',
    '    return JSON.parse(payload);',
    '  } catch {',
    '    return null;',
    '  }',
    '}',
    '',
    '/**',
    ' * Context middleware - extracts context from JWT and headers',
    ' */',
    'export function contextMiddleware(',
    '  req: Request,',
    '  res: Response,',
    '  next: NextFunction',
    '): void {',
    '  const context: RequestContext = {};',
    '',
    '  // Extract from JWT if present',
    '  const authHeader = req.headers.authorization;',
    "  if (authHeader?.startsWith('Bearer ')) {",
    '    const token = authHeader.slice(7);',
    '    const payload = decodeJwtPayload(token);',
    '    if (payload) {',
    '      context.userId = payload.sub as string;',
    '      context.role = payload.role as string;',
    '      // Copy other claims',
    '      for (const [key, value] of Object.entries(payload)) {',
    "        if (!['sub', 'role', 'iat', 'exp', 'iss', 'aud'].includes(key)) {",
    '          context[key] = value;',
    '        }',
    '      }',
    '    }',
    '  }',
    '',
    '  // Extract from headers',
    "  const tenantId = req.headers['x-tenant-id'];",
    '  if (tenantId) {',
    "    context.tenantId = Array.isArray(tenantId) ? tenantId[0] : tenantId;",
    '  }',
    '',
    '  // Allow user from auth middleware to override',
    '  if ((req as any).user?.id) {',
    '    context.userId = (req as any).user.id;',
    '  }',
    '',
    '  req.context = context;',
    '  next();',
    '}',
    '',
  ];

  return lines.join('\n');
}

/**
 * Generate RLS middleware for Node.js
 * Adds row-level security filtering to requests
 */
export function generateRlsMiddleware(schemas: AnalyzedSchema[]): string {
  const schemasWithRls = schemas.filter((s) => s.rls);

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
    '/**',
    ' * RLS context type',
    ' */',
    'export interface RLSContext {',
    '  userId?: string;',
    '  role?: string;',
    '  tenantId?: string;',
    '  [key: string]: unknown;',
    '}',
    '',
    '/**',
    ' * RLS filter function type',
    ' */',
    'export type RLSFilter<T = Record<string, unknown>> = (',
    '  row: T,',
    '  ctx: RLSContext | null',
    ') => boolean;',
    '',
    '/**',
    ' * Extend Express Request with RLS context',
    ' */',
    "declare module 'express' {",
    '  interface Request {',
    '    rlsContext: RLSContext | null;',
    '  }',
    '}',
    '',
  ];

  // Generate RLS filters for each schema
  if (schemasWithRls.length > 0) {
    lines.push('/**');
    lines.push(' * RLS filters by entity');
    lines.push(' */');
    lines.push('export const rlsFilters: Record<string, {');
    lines.push('  select?: RLSFilter;');
    lines.push('  insert?: RLSFilter;');
    lines.push('  update?: RLSFilter;');
    lines.push('  delete?: RLSFilter;');
    lines.push('}> = {');

    for (const schema of schemasWithRls) {
      if (!schema.rls) continue;

      lines.push(`  '${schema.name}': {`);

      // Handle scope-based RLS
      if (schema.rls.scope) {
        const scopeConditions = schema.rls.scope
          .map((s) => `row.${s.field} === ctx?.${s.contextKey}`)
          .join(' && ');
        const bypassConditions = schema.rls.bypass
          ?.map((b) => `${JSON.stringify(b.values)}.includes(ctx?.${b.contextKey} as string)`)
          .join(' || ');

        const filterBody = bypassConditions
          ? `${bypassConditions} || (${scopeConditions})`
          : scopeConditions;

        lines.push(`    select: (row, ctx) => ${filterBody},`);
        lines.push(`    insert: (row, ctx) => ${filterBody},`);
        lines.push(`    update: (row, ctx) => ${filterBody},`);
        lines.push(`    delete: (row, ctx) => ${filterBody},`);
      }

      lines.push('  },');
    }

    lines.push('};');
    lines.push('');
  } else {
    lines.push('/**');
    lines.push(' * No RLS filters configured');
    lines.push(' */');
    lines.push('export const rlsFilters: Record<string, Record<string, RLSFilter>> = {};');
    lines.push('');
  }

  lines.push('/**');
  lines.push(' * Get RLS context from request');
  lines.push(' */');
  lines.push('function getRLSContext(req: Request): RLSContext | null {');
  lines.push('  // Use context middleware if available');
  lines.push('  if ((req as any).context) {');
  lines.push('    return (req as any).context;');
  lines.push('  }');
  lines.push('');
  lines.push('  // Use user from auth middleware');
  lines.push('  if ((req as any).user) {');
  lines.push('    return {');
  lines.push('      userId: (req as any).user.id,');
  lines.push('      role: (req as any).user.role,');
  lines.push('    };');
  lines.push('  }');
  lines.push('');
  lines.push('  return null;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * RLS middleware - attaches RLS context to request');
  lines.push(' */');
  lines.push('export function rlsMiddleware(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): void {');
  lines.push('  req.rlsContext = getRLSContext(req);');
  lines.push('  next();');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Apply RLS filter to data');
  lines.push(' */');
  lines.push('export function applyRLSFilter<T extends Record<string, unknown>>(');
  lines.push('  entity: string,');
  lines.push("  operation: 'select' | 'insert' | 'update' | 'delete',");
  lines.push('  data: T[],');
  lines.push('  ctx: RLSContext | null');
  lines.push('): T[] {');
  lines.push('  const filter = rlsFilters[entity]?.[operation];');
  lines.push('  if (!filter) return data;');
  lines.push('  return data.filter((row) => filter(row, ctx));');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Check if operation is allowed by RLS');
  lines.push(' */');
  lines.push('export function checkRLSPermission<T extends Record<string, unknown>>(');
  lines.push('  entity: string,');
  lines.push("  operation: 'select' | 'insert' | 'update' | 'delete',");
  lines.push('  row: T,');
  lines.push('  ctx: RLSContext | null');
  lines.push('): boolean {');
  lines.push('  const filter = rlsFilters[entity]?.[operation];');
  lines.push('  if (!filter) return true;');
  lines.push('  return filter(row, ctx);');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate custom middleware from analyzed middleware definition
 */
export function generateCustomMiddleware(analyzed: AnalyzedMiddleware): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
    '',
  ];

  // Generate imports for dependencies
  if (analyzed.handlerDependencies && analyzed.handlerDependencies.length > 0) {
    for (const dep of analyzed.handlerDependencies) {
      lines.push(`import { ${dep.name} } from '${dep.from}';`);
    }
    lines.push('');
  }

  // Generate local functions if any
  if (analyzed.localFunctions && analyzed.localFunctions.length > 0) {
    for (const func of analyzed.localFunctions) {
      lines.push(func.source);
      lines.push('');
    }
  }

  // Generate config type if there are config fields
  if (analyzed.configFields.length > 0) {
    lines.push('/**');
    lines.push(` * Configuration for ${analyzed.pascalName} middleware`);
    lines.push(' */');
    lines.push(`export interface ${analyzed.pascalName}Config {`);
    for (const field of analyzed.configFields) {
      const optional = field.hasDefault ? '?' : '';
      lines.push(`  ${field.name}${optional}: ${field.tsType};`);
    }
    lines.push('}');
    lines.push('');

    // Generate default config
    lines.push('/**');
    lines.push(' * Default configuration');
    lines.push(' */');
    lines.push(`const defaultConfig: ${analyzed.pascalName}Config = {`);
    for (const field of analyzed.configFields) {
      if (field.hasDefault) {
        const value = typeof field.default === 'string'
          ? `'${field.default}'`
          : JSON.stringify(field.default);
        lines.push(`  ${field.name}: ${value},`);
      }
    }
    lines.push('};');
    lines.push('');
  }

  // Generate middleware context type (Express-adapted)
  lines.push('/**');
  lines.push(' * Middleware context (Express-adapted)');
  lines.push(' */');
  lines.push('interface MiddlewareContext {');
  lines.push('  headers: Record<string, string | undefined>;');
  lines.push('  path: string;');
  lines.push('  method: string;');
  lines.push('  query: Record<string, string | string[] | undefined>;');
  lines.push('  params: Record<string, string>;');
  lines.push('  body?: unknown;');
  lines.push('  context: Record<string, unknown>;');
  lines.push('  metadata: Record<string, unknown>;');
  lines.push('}');
  lines.push('');

  // Generate the middleware handler
  lines.push('/**');
  if (analyzed.description) {
    lines.push(` * ${analyzed.description}`);
  } else {
    lines.push(` * ${analyzed.pascalName} middleware`);
  }
  lines.push(' */');

  const handlerName = `${analyzed.name}Middleware`;

  if (analyzed.configFields.length > 0) {
    // Configurable middleware - export a factory function
    lines.push(`export function create${analyzed.pascalName}Middleware(`);
    lines.push(`  config: Partial<${analyzed.pascalName}Config> = {}`);
    lines.push(') {');
    lines.push('  const mergedConfig = { ...defaultConfig, ...config };');
    lines.push('');
    lines.push('  return async function (');
    lines.push('    req: Request,');
    lines.push('    res: Response,');
    lines.push('    next: NextFunction');
    lines.push('  ): Promise<void> {');
    lines.push('    // Create context from Express request');
    lines.push('    const ctx: MiddlewareContext = {');
    lines.push('      headers: req.headers as Record<string, string | undefined>,');
    lines.push('      path: req.path,');
    lines.push('      method: req.method,');
    lines.push('      query: req.query as Record<string, string | string[] | undefined>,');
    lines.push('      params: req.params,');
    lines.push('      body: req.body,');
    lines.push('      context: (req as any).context || {},');
    lines.push('      metadata: {},');
    lines.push('    };');
    lines.push('');
    lines.push('    // Create next wrapper');
    lines.push('    let nextCalled = false;');
    lines.push('    const wrappedNext = async () => {');
    lines.push('      nextCalled = true;');
    lines.push('      return {};');
    lines.push('    };');
    lines.push('');
    lines.push('    try {');
    lines.push('      // Execute the handler');
    lines.push('      const handler = ' + analyzed.handlerSource + ';');
    lines.push('      const result = await handler({ ctx, config: mergedConfig, next: wrappedNext });');
    lines.push('');
    lines.push('      // Handle response if returned');
    lines.push('      if (result?.response) {');
    lines.push('        const { status = 200, body, headers = {} } = result.response;');
    lines.push('        for (const [key, value] of Object.entries(headers)) {');
    lines.push('          res.setHeader(key, value);');
    lines.push('        }');
    lines.push('        res.status(status).json(body);');
    lines.push('        return;');
    lines.push('      }');
    lines.push('');
    lines.push('      // Update request context');
    lines.push('      (req as any).context = ctx.context;');
    lines.push('');
    lines.push('      if (nextCalled) {');
    lines.push('        next();');
    lines.push('      }');
    lines.push('    } catch (error) {');
    lines.push('      next(error);');
    lines.push('    }');
    lines.push('  };');
    lines.push('}');
    lines.push('');
    lines.push(`// Export default middleware instance with default config`);
    lines.push(`export const ${handlerName} = create${analyzed.pascalName}Middleware();`);
  } else {
    // Non-configurable middleware
    lines.push('export async function ' + handlerName + '(');
    lines.push('  req: Request,');
    lines.push('  res: Response,');
    lines.push('  next: NextFunction');
    lines.push('): Promise<void> {');
    lines.push('  // Create context from Express request');
    lines.push('  const ctx: MiddlewareContext = {');
    lines.push('    headers: req.headers as Record<string, string | undefined>,');
    lines.push('    path: req.path,');
    lines.push('    method: req.method,');
    lines.push('    query: req.query as Record<string, string | string[] | undefined>,');
    lines.push('    params: req.params,');
    lines.push('    body: req.body,');
    lines.push('    context: (req as any).context || {},');
    lines.push('    metadata: {},');
    lines.push('  };');
    lines.push('');
    lines.push('  // Create next wrapper');
    lines.push('  let nextCalled = false;');
    lines.push('  const wrappedNext = async () => {');
    lines.push('    nextCalled = true;');
    lines.push('    return {};');
    lines.push('  };');
    lines.push('');
    lines.push('  try {');
    lines.push('    // Execute the handler');
    lines.push('    const handler = ' + analyzed.handlerSource + ';');
    lines.push('    const result = await handler({ ctx, config: {}, next: wrappedNext });');
    lines.push('');
    lines.push('    // Handle response if returned');
    lines.push('    if (result?.response) {');
    lines.push('      const { status = 200, body, headers = {} } = result.response;');
    lines.push('      for (const [key, value] of Object.entries(headers)) {');
    lines.push('        res.setHeader(key, value);');
    lines.push('      }');
    lines.push('      res.status(status).json(body);');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    // Update request context');
    lines.push('    (req as any).context = ctx.context;');
    lines.push('');
    lines.push('    if (nextCalled) {');
    lines.push('      next();');
    lines.push('    }');
    lines.push('  } catch (error) {');
    lines.push('    next(error);');
    lines.push('  }');
    lines.push('}');
  }

  lines.push('');

  return lines.join('\n');
}

/**
 * Generate auth middleware from new MiddlewareConfig
 */
export function generateAuthMiddlewareFromConfig(config: AuthMiddlewareConfig): string {
  // Convert new config format to legacy format for reuse
  const target: GenerationTarget = {
    name: 'temp',
    type: 'node-handlers',
    output: '',
    middleware: {
      auth: {
        provider: config.provider,
        secretEnvVar: config.secretEnvVar,
        customHandler: config.customHandler,
      },
    },
  };
  return generateNodeMiddleware(target);
}
