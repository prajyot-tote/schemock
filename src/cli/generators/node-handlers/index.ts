/**
 * Node.js Handler Generator
 *
 * Generates Express-compatible HTTP handlers from Schemock schemas.
 * Works with Express, Fastify, Hono, or any Node.js HTTP framework.
 *
 * @module cli/generators/node-handlers
 * @category CLI
 */

import { mkdir, writeFile } from 'node:fs/promises';
import { join } from 'node:path';
import type {
  AnalyzedSchema,
  GenerationTarget,
  SchemockConfig,
  GenerateOptions,
} from '../../types';

import { generateHandlerFile } from './handler-template';
import { generateRouterFile } from './router-template';
import { generateNodeMiddleware, generateNodeValidation } from './middleware-template';
import { generateNodeLibFiles } from './lib-template';
import { generateTypes } from '../types';

/**
 * Generate Node.js handlers for entities
 *
 * @param allSchemas - All schemas (for type generation, ensures relations work)
 * @param targetSchemas - Filtered schemas (for handler generation)
 * @param outputDir - Output directory
 * @param target - Target configuration
 * @param config - Schemock config
 * @param options - Generation options
 */
export async function generateNodeHandlersTarget(
  allSchemas: AnalyzedSchema[],
  targetSchemas: AnalyzedSchema[],
  outputDir: string,
  target: GenerationTarget,
  config: SchemockConfig,
  options: GenerateOptions
): Promise<string[]> {
  const files: string[] = [];

  // Create handlers directory
  const handlersDir = join(outputDir, 'handlers');
  if (!options.dryRun) {
    await mkdir(handlersDir, { recursive: true });
  }

  // Create middleware directory
  const middlewareDir = join(outputDir, 'middleware');
  if (!options.dryRun) {
    await mkdir(middlewareDir, { recursive: true });
  }

  // Generate TypeScript types (ALL schemas to preserve relations)
  const typesCode = generateTypes(allSchemas);
  await writeOutput(join(outputDir, 'types.ts'), typesCode, options.dryRun);
  files.push('types.ts');
  console.log('   ✓ types.ts');

  // Generate shared library files (excluding types which we just generated)
  const libFiles = generateNodeLibFiles(target, config);
  for (const [filename, content] of Object.entries(libFiles)) {
    if (filename === 'types.ts') continue; // Skip types, already generated
    await writeOutput(join(outputDir, filename), content, options.dryRun);
    files.push(filename);
    console.log(`   ✓ ${filename}`);
  }

  // Generate middleware files
  if (target.middleware?.auth) {
    const authMiddleware = generateNodeMiddleware(target);
    await writeOutput(join(middlewareDir, 'auth.ts'), authMiddleware, options.dryRun);
    files.push('middleware/auth.ts');
    console.log('   ✓ middleware/auth.ts');
  }

  // Generate validation middleware (only for target schemas)
  if (target.middleware?.validation) {
    const validationMiddleware = generateNodeValidation(targetSchemas);
    await writeOutput(join(middlewareDir, 'validate.ts'), validationMiddleware, options.dryRun);
    files.push('middleware/validate.ts');
    console.log('   ✓ middleware/validate.ts');
  }

  // Generate handler files for TARGET schemas only (filtered)
  for (const schema of targetSchemas) {
    if (schema.isJunctionTable) continue;

    const handlerCode = generateHandlerFile(schema, target, config);
    await writeOutput(join(handlersDir, `${schema.pluralName}.ts`), handlerCode, options.dryRun);
    files.push(`handlers/${schema.pluralName}.ts`);
    console.log(`   ✓ handlers/${schema.pluralName}.ts`);
  }

  // Generate main router file (only includes target schemas)
  const routerCode = generateRouterFile(targetSchemas, target, config);
  await writeOutput(join(outputDir, 'router.ts'), routerCode, options.dryRun);
  files.push('router.ts');
  console.log('   ✓ router.ts (combined router)');

  // Generate index file (only exports target schemas)
  const indexCode = generateIndexFile(targetSchemas, target);
  await writeOutput(join(outputDir, 'index.ts'), indexCode, options.dryRun);
  files.push('index.ts');
  console.log('   ✓ index.ts');

  return files;
}

/**
 * Generate index file
 */
function generateIndexFile(schemas: AnalyzedSchema[], target: GenerationTarget): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "export * from './types';",
    "export { router, createRouter } from './router';",
  ];

  // Export handlers
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    lines.push(`export * as ${schema.pluralName}Handlers from './handlers/${schema.pluralName}';`);
  }

  // Export middleware
  if (target.middleware?.auth) {
    lines.push("export { authMiddleware } from './middleware/auth';");
  }
  if (target.middleware?.validation) {
    lines.push("export * from './middleware/validate';");
  }

  return lines.join('\n');
}

/**
 * Write output file (or show dry-run message)
 */
async function writeOutput(
  path: string,
  content: string,
  dryRun?: boolean
): Promise<void> {
  if (dryRun) {
    console.log(`   [DRY RUN] Would write: ${path}`);
    return;
  }
  await writeFile(path, content, 'utf-8');
}
