/**
 * Node.js Handler Templates
 *
 * Generates handler files for Express/Fastify/Hono compatible frameworks.
 *
 * Supports two modes:
 * - Legacy: Direct database access per backend (for backward compatibility)
 * - Service: Uses service layer with withMiddleware (new pattern)
 *
 * @module cli/generators/node-handlers/handler-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget, SchemockConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate handler file for an entity
 */
export function generateHandlerFile(
  schema: AnalyzedSchema,
  target: GenerationTarget,
  _config: SchemockConfig
): string {
  const backend = target.backend || 'supabase';
  const hasValidation = target.middleware?.validation === true;

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
  ];

  // Import backend client
  if (backend === 'supabase') {
    lines.push("import { supabase } from '../db';");
  } else if (backend === 'firebase') {
    lines.push("import { db } from '../db';");
  } else if (backend === 'pglite') {
    lines.push("import { db } from '../db';");
  } else if (backend === 'fetch') {
    lines.push("import { api } from '../api';");
  }

  // Import types (using the naming convention from types generator: UserCreate, UserUpdate)
  lines.push(`import type { ${schema.pascalName}, ${schema.pascalName}Create, ${schema.pascalName}Update } from '../types';`);

  // Import validation if enabled
  if (hasValidation) {
    lines.push(`import { validate${schema.pascalName}, validate${schema.pascalName}Update } from '../middleware/validate';`);
  }

  lines.push('');

  // List handler
  lines.push('/**');
  lines.push(` * GET /${schema.pluralName}`);
  lines.push(` * List all ${schema.pluralName}`);
  lines.push(' */');
  lines.push('export async function list(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push("    const limit = parseInt(req.query.limit as string || '20', 10);");
  lines.push("    const offset = parseInt(req.query.offset as string || '0', 10);");
  lines.push('');

  if (backend === 'supabase') {
    lines.push(`    const { data, error, count } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push("      .select('*', { count: 'exact' })");
    lines.push('      .range(offset, offset + limit - 1);');
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.json({');
    lines.push(`      data: data as ${schema.pascalName}[],`);
    lines.push('      meta: { total: count ?? 0, limit, offset }');
    lines.push('    });');
  } else if (backend === 'firebase') {
    lines.push(`    const snapshot = await db.collection('${schema.tableName}')`);
    lines.push('      .limit(limit)');
    lines.push('      .offset(offset)');
    lines.push('      .get();');
    lines.push('');
    lines.push(`    const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as ${schema.pascalName}[];`);
    lines.push('    res.json({ data, meta: { limit, offset } });');
  } else if (backend === 'pglite') {
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'SELECT * FROM ${schema.tableName} LIMIT $1 OFFSET $2',`);
    lines.push('      [limit, offset]');
    lines.push('    );');
    lines.push('');
    lines.push('    res.json({ data: result.rows, meta: { limit, offset } });');
  } else if (backend === 'fetch') {
    lines.push(`    const response = await api.${schema.pluralName}.list({ limit, offset });`);
    lines.push('    res.json(response);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Get one handler
  lines.push('/**');
  lines.push(` * GET /${schema.pluralName}/:id`);
  lines.push(` * Get a single ${schema.singularName} by ID`);
  lines.push(' */');
  lines.push('export async function getOne(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push('');

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push("      .select('*')");
    lines.push("      .eq('id', id)");
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push("      if (error.code === 'PGRST116') {");
    lines.push("        res.status(404).json({ error: 'Not found' });");
    lines.push('        return;');
    lines.push('      }');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const doc = await db.collection('${schema.tableName}').doc(id).get();`);
    lines.push('');
    lines.push('    if (!doc.exists) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.json({ id: doc.id, ...doc.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'SELECT * FROM ${schema.tableName} WHERE id = $1',`);
    lines.push('      [id]');
    lines.push('    );');
    lines.push('');
    lines.push('    if (result.rows.length === 0) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.json(result.rows[0]);');
  } else if (backend === 'fetch') {
    lines.push(`    const data = await api.${schema.pluralName}.get(id);`);
    lines.push('    res.json(data);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Create handler
  lines.push('/**');
  lines.push(` * POST /${schema.pluralName}`);
  lines.push(` * Create a new ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function create(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push(`    const body = req.body as ${schema.pascalName}Create;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      res.status(400).json({ errors: validation.errors });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
  }

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .insert(body)');
    lines.push('      .select()');
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.status(201).json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const docRef = await db.collection('${schema.tableName}').add({`);
    lines.push('      ...body,');
    lines.push('      createdAt: new Date().toISOString(),');
    lines.push('      updatedAt: new Date().toISOString(),');
    lines.push('    });');
    lines.push('');
    lines.push('    const doc = await docRef.get();');
    lines.push(`    res.status(201).json({ id: doc.id, ...doc.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    const insertFields = schema.fields
      .filter((f) => !f.readOnly && f.name !== 'id' && !f.isComputed)
      .map((f) => f.name);
    const placeholders = insertFields.map((_, i) => `$${i + 1}`).join(', ');
    const values = insertFields.map((f) => `body.${f}`).join(', ');

    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'INSERT INTO ${schema.tableName} (${insertFields.join(', ')}) VALUES (${placeholders}) RETURNING *',`);
    lines.push(`      [${values}]`);
    lines.push('    );');
    lines.push('');
    lines.push('    res.status(201).json(result.rows[0]);');
  } else if (backend === 'fetch') {
    lines.push(`    const data = await api.${schema.pluralName}.create(body);`);
    lines.push('    res.status(201).json(data);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Update handler
  lines.push('/**');
  lines.push(` * PUT /${schema.pluralName}/:id`);
  lines.push(` * Update a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function update(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push(`    const body = req.body as ${schema.pascalName}Update;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}Update(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      res.status(400).json({ errors: validation.errors });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
  }

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .update(body)');
    lines.push("      .eq('id', id)");
    lines.push('      .select()');
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push("      if (error.code === 'PGRST116') {");
    lines.push("        res.status(404).json({ error: 'Not found' });");
    lines.push('        return;');
    lines.push('      }');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const docRef = db.collection('${schema.tableName}').doc(id);`);
    lines.push('    const doc = await docRef.get();');
    lines.push('');
    lines.push('    if (!doc.exists) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    await docRef.update({ ...body, updatedAt: new Date().toISOString() });');
    lines.push('    const updated = await docRef.get();');
    lines.push('');
    lines.push(`    res.json({ id: updated.id, ...updated.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    lines.push('    const entries = Object.entries(body);');
    lines.push('    if (entries.length === 0) {');
    lines.push("      res.status(400).json({ error: 'No fields to update' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push("    const setClauses = entries.map(([key], i) => `${key} = $${i + 1}`).join(', ');");
    lines.push('    const values = entries.map(([, val]) => val);');
    lines.push('');
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      \`UPDATE ${schema.tableName} SET \${setClauses} WHERE id = $\${values.length + 1} RETURNING *\`,`);
    lines.push('      [...values, id]');
    lines.push('    );');
    lines.push('');
    lines.push('    if (result.rows.length === 0) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.json(result.rows[0]);');
  } else if (backend === 'fetch') {
    lines.push(`    const data = await api.${schema.pluralName}.update(id, body);`);
    lines.push('    res.json(data);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Delete handler
  lines.push('/**');
  lines.push(` * DELETE /${schema.pluralName}/:id`);
  lines.push(` * Delete a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function remove(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push('');

  if (backend === 'supabase') {
    lines.push(`    const { error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .delete()');
    lines.push("      .eq('id', id);");
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.status(204).send();');
  } else if (backend === 'firebase') {
    lines.push(`    await db.collection('${schema.tableName}').doc(id).delete();`);
    lines.push('    res.status(204).send();');
  } else if (backend === 'pglite') {
    lines.push(`    await db.query('DELETE FROM ${schema.tableName} WHERE id = $1', [id]);`);
    lines.push('    res.status(204).send();');
  } else if (backend === 'fetch') {
    lines.push(`    await api.${schema.pluralName}.delete(id);`);
    lines.push('    res.status(204).send();');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Configuration for service-based handler generation
 */
export interface ServiceHandlerConfig {
  /** Path to import services from */
  servicesImport?: string;
  /** Path to import middleware from */
  middlewareImport?: string;
  /** Path to import types from */
  typesImport?: string;
  /** Operations to skip generating */
  skip?: string[];
}

/**
 * Generate handler file for an entity using service layer
 *
 * This is the new pattern that uses services instead of direct database access.
 * Services encapsulate business logic and RLS enforcement, handlers just orchestrate.
 *
 * @param schema - Analyzed schema
 * @param config - Service handler configuration
 * @returns Generated handler file content
 */
export function generateServiceHandlerFile(
  schema: AnalyzedSchema,
  config: ServiceHandlerConfig = {}
): string {
  const {
    servicesImport = '../services',
    middlewareImport = '../middleware',
    typesImport = '../types',
    skip = [],
  } = config;

  const code = new CodeBuilder();
  const { name, pascalName, singularName, pluralName } = schema;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment(`Handler for ${pascalName} entity using service layer`);
  code.line();

  // Imports
  code.line("import type { Request, Response, NextFunction } from 'express';");
  code.line(`import { withMiddleware, getMiddleware, type MiddlewareContext } from '${middlewareImport}';`);
  code.line(`import { ${singularName}Service } from '${servicesImport}';`);
  code.line(`import type { ${pascalName}Create, ${pascalName}Update } from '${typesImport}';`);
  code.line();

  // LIST
  if (!skip.includes(`${name}.list`)) {
    code.multiDocComment([
      `GET /${pluralName}`,
      `List all ${pluralName}`,
    ]);
    code.block('export async function list(', () => {
      code.line('req: Request,');
      code.line('res: Response,');
      code.line('next: NextFunction');
    }, '): Promise<void> {');
    code.indent();

    code.block('try {', () => {
      code.line(`await withMiddleware(getMiddleware('${name}', 'list'), req, res, async (ctx) => {`);
      code.indent();
      code.line("const limit = parseInt(req.query.limit as string || '20', 10);");
      code.line("const offset = parseInt(req.query.offset as string || '0', 10);");
      code.line(`const data = await ${singularName}Service.list(ctx, { limit, offset });`);
      code.line('res.json({');
      code.line('  data,');
      code.line('  meta: { limit, offset },');
      code.line('});');
      code.dedent();
      code.line('});');
    }, '} catch (error) {');
    code.indent();
    code.line('next(error);');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();
  }

  // GET ONE
  if (!skip.includes(`${name}.get`)) {
    code.multiDocComment([
      `GET /${pluralName}/:id`,
      `Get a single ${singularName} by ID`,
    ]);
    code.block('export async function getOne(', () => {
      code.line('req: Request,');
      code.line('res: Response,');
      code.line('next: NextFunction');
    }, '): Promise<void> {');
    code.indent();

    code.block('try {', () => {
      code.line(`await withMiddleware(getMiddleware('${name}', 'get'), req, res, async (ctx) => {`);
      code.indent();
      code.line('const { id } = req.params;');
      code.line(`const data = await ${singularName}Service.get(ctx, id);`);
      code.line('res.json({ data });');
      code.dedent();
      code.line('});');
    }, '} catch (error) {');
    code.indent();
    code.line('next(error);');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();
  }

  // CREATE
  if (!skip.includes(`${name}.create`)) {
    code.multiDocComment([
      `POST /${pluralName}`,
      `Create a new ${singularName}`,
    ]);
    code.block('export async function create(', () => {
      code.line('req: Request,');
      code.line('res: Response,');
      code.line('next: NextFunction');
    }, '): Promise<void> {');
    code.indent();

    code.block('try {', () => {
      code.line(`await withMiddleware(getMiddleware('${name}', 'create'), req, res, async (ctx) => {`);
      code.indent();
      code.line(`const body = req.body as ${pascalName}Create;`);
      code.line(`const data = await ${singularName}Service.create(ctx, body);`);
      code.line('res.status(201).json({ data });');
      code.dedent();
      code.line('});');
    }, '} catch (error) {');
    code.indent();
    code.line('next(error);');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();
  }

  // UPDATE
  if (!skip.includes(`${name}.update`)) {
    code.multiDocComment([
      `PUT /${pluralName}/:id`,
      `Update a ${singularName}`,
    ]);
    code.block('export async function update(', () => {
      code.line('req: Request,');
      code.line('res: Response,');
      code.line('next: NextFunction');
    }, '): Promise<void> {');
    code.indent();

    code.block('try {', () => {
      code.line(`await withMiddleware(getMiddleware('${name}', 'update'), req, res, async (ctx) => {`);
      code.indent();
      code.line('const { id } = req.params;');
      code.line(`const body = req.body as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
      code.line('res.json({ data });');
      code.dedent();
      code.line('});');
    }, '} catch (error) {');
    code.indent();
    code.line('next(error);');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.multiDocComment([
      `DELETE /${pluralName}/:id`,
      `Delete a ${singularName}`,
    ]);
    code.block('export async function remove(', () => {
      code.line('req: Request,');
      code.line('res: Response,');
      code.line('next: NextFunction');
    }, '): Promise<void> {');
    code.indent();

    code.block('try {', () => {
      code.line(`await withMiddleware(getMiddleware('${name}', 'delete'), req, res, async (ctx) => {`);
      code.indent();
      code.line('const { id } = req.params;');
      code.line(`await ${singularName}Service.delete(ctx, id);`);
      code.line('res.status(204).send();');
      code.dedent();
      code.line('});');
    }, '} catch (error) {');
    code.indent();
    code.line('next(error);');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
  }

  return code.toString();
}
