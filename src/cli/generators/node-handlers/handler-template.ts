/**
 * Node.js Handler Templates
 *
 * Generates handler files for Express/Fastify/Hono compatible frameworks.
 *
 * @module cli/generators/node-handlers/handler-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget, SchemockConfig } from '../../types';

/**
 * Generate handler file for an entity
 */
export function generateHandlerFile(
  schema: AnalyzedSchema,
  target: GenerationTarget,
  _config: SchemockConfig
): string {
  const backend = target.backend || 'supabase';
  const hasValidation = target.middleware?.validation === true;

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import type { Request, Response, NextFunction } from 'express';",
  ];

  // Import backend client
  if (backend === 'supabase') {
    lines.push("import { supabase } from '../db';");
  } else if (backend === 'firebase') {
    lines.push("import { db } from '../db';");
  } else if (backend === 'pglite') {
    lines.push("import { db } from '../db';");
  } else if (backend === 'fetch') {
    lines.push("import { api } from '../api';");
  }

  // Import types (using the naming convention from types generator: UserCreate, UserUpdate)
  lines.push(`import type { ${schema.pascalName}, ${schema.pascalName}Create, ${schema.pascalName}Update } from '../types';`);

  // Import validation if enabled
  if (hasValidation) {
    lines.push(`import { validate${schema.pascalName}, validate${schema.pascalName}Update } from '../middleware/validate';`);
  }

  lines.push('');

  // List handler
  lines.push('/**');
  lines.push(` * GET /${schema.pluralName}`);
  lines.push(` * List all ${schema.pluralName}`);
  lines.push(' */');
  lines.push('export async function list(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push("    const limit = parseInt(req.query.limit as string || '20', 10);");
  lines.push("    const offset = parseInt(req.query.offset as string || '0', 10);");
  lines.push('');

  if (backend === 'supabase') {
    lines.push(`    const { data, error, count } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push("      .select('*', { count: 'exact' })");
    lines.push('      .range(offset, offset + limit - 1);');
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.json({');
    lines.push(`      data: data as ${schema.pascalName}[],`);
    lines.push('      meta: { total: count ?? 0, limit, offset }');
    lines.push('    });');
  } else if (backend === 'firebase') {
    lines.push(`    const snapshot = await db.collection('${schema.tableName}')`);
    lines.push('      .limit(limit)');
    lines.push('      .offset(offset)');
    lines.push('      .get();');
    lines.push('');
    lines.push(`    const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as ${schema.pascalName}[];`);
    lines.push('    res.json({ data, meta: { limit, offset } });');
  } else if (backend === 'pglite') {
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'SELECT * FROM ${schema.tableName} LIMIT $1 OFFSET $2',`);
    lines.push('      [limit, offset]');
    lines.push('    );');
    lines.push('');
    lines.push('    res.json({ data: result.rows, meta: { limit, offset } });');
  } else if (backend === 'fetch') {
    lines.push(`    const response = await api.${schema.pluralName}.list({ limit, offset });`);
    lines.push('    res.json(response);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Get one handler
  lines.push('/**');
  lines.push(` * GET /${schema.pluralName}/:id`);
  lines.push(` * Get a single ${schema.singularName} by ID`);
  lines.push(' */');
  lines.push('export async function getOne(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push('');

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push("      .select('*')");
    lines.push("      .eq('id', id)");
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push("      if (error.code === 'PGRST116') {");
    lines.push("        res.status(404).json({ error: 'Not found' });");
    lines.push('        return;');
    lines.push('      }');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const doc = await db.collection('${schema.tableName}').doc(id).get();`);
    lines.push('');
    lines.push('    if (!doc.exists) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.json({ id: doc.id, ...doc.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'SELECT * FROM ${schema.tableName} WHERE id = $1',`);
    lines.push('      [id]');
    lines.push('    );');
    lines.push('');
    lines.push('    if (result.rows.length === 0) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.json(result.rows[0]);');
  } else if (backend === 'fetch') {
    lines.push(`    const data = await api.${schema.pluralName}.get(id);`);
    lines.push('    res.json(data);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Create handler
  lines.push('/**');
  lines.push(` * POST /${schema.pluralName}`);
  lines.push(` * Create a new ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function create(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push(`    const body = req.body as ${schema.pascalName}Create;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      res.status(400).json({ errors: validation.errors });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
  }

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .insert(body)');
    lines.push('      .select()');
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.status(201).json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const docRef = await db.collection('${schema.tableName}').add({`);
    lines.push('      ...body,');
    lines.push('      createdAt: new Date().toISOString(),');
    lines.push('      updatedAt: new Date().toISOString(),');
    lines.push('    });');
    lines.push('');
    lines.push('    const doc = await docRef.get();');
    lines.push(`    res.status(201).json({ id: doc.id, ...doc.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    const insertFields = schema.fields
      .filter((f) => !f.readOnly && f.name !== 'id' && !f.isComputed)
      .map((f) => f.name);
    const placeholders = insertFields.map((_, i) => `$${i + 1}`).join(', ');
    const values = insertFields.map((f) => `body.${f}`).join(', ');

    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'INSERT INTO ${schema.tableName} (${insertFields.join(', ')}) VALUES (${placeholders}) RETURNING *',`);
    lines.push(`      [${values}]`);
    lines.push('    );');
    lines.push('');
    lines.push('    res.status(201).json(result.rows[0]);');
  } else if (backend === 'fetch') {
    lines.push(`    const data = await api.${schema.pluralName}.create(body);`);
    lines.push('    res.status(201).json(data);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Update handler
  lines.push('/**');
  lines.push(` * PUT /${schema.pluralName}/:id`);
  lines.push(` * Update a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function update(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push(`    const body = req.body as ${schema.pascalName}Update;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}Update(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      res.status(400).json({ errors: validation.errors });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
  }

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .update(body)');
    lines.push("      .eq('id', id)");
    lines.push('      .select()');
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push("      if (error.code === 'PGRST116') {");
    lines.push("        res.status(404).json({ error: 'Not found' });");
    lines.push('        return;');
    lines.push('      }');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push(`    res.json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const docRef = db.collection('${schema.tableName}').doc(id);`);
    lines.push('    const doc = await docRef.get();');
    lines.push('');
    lines.push('    if (!doc.exists) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    await docRef.update({ ...body, updatedAt: new Date().toISOString() });');
    lines.push('    const updated = await docRef.get();');
    lines.push('');
    lines.push(`    res.json({ id: updated.id, ...updated.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    lines.push('    const entries = Object.entries(body);');
    lines.push('    if (entries.length === 0) {');
    lines.push("      res.status(400).json({ error: 'No fields to update' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push("    const setClauses = entries.map(([key], i) => `${key} = $${i + 1}`).join(', ');");
    lines.push('    const values = entries.map(([, val]) => val);');
    lines.push('');
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      \`UPDATE ${schema.tableName} SET \${setClauses} WHERE id = $\${values.length + 1} RETURNING *\`,`);
    lines.push('      [...values, id]');
    lines.push('    );');
    lines.push('');
    lines.push('    if (result.rows.length === 0) {');
    lines.push("      res.status(404).json({ error: 'Not found' });");
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.json(result.rows[0]);');
  } else if (backend === 'fetch') {
    lines.push(`    const data = await api.${schema.pluralName}.update(id, body);`);
    lines.push('    res.json(data);');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // Delete handler
  lines.push('/**');
  lines.push(` * DELETE /${schema.pluralName}/:id`);
  lines.push(` * Delete a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function remove(');
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');
  lines.push('    const { id } = req.params;');
  lines.push('');

  if (backend === 'supabase') {
    lines.push(`    const { error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .delete()');
    lines.push("      .eq('id', id);");
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      res.status(500).json({ error: error.message });');
    lines.push('      return;');
    lines.push('    }');
    lines.push('');
    lines.push('    res.status(204).send();');
  } else if (backend === 'firebase') {
    lines.push(`    await db.collection('${schema.tableName}').doc(id).delete();`);
    lines.push('    res.status(204).send();');
  } else if (backend === 'pglite') {
    lines.push(`    await db.query('DELETE FROM ${schema.tableName} WHERE id = $1', [id]);`);
    lines.push('    res.status(204).send();');
  } else if (backend === 'fetch') {
    lines.push(`    await api.${schema.pluralName}.delete(id);`);
    lines.push('    res.status(204).send();');
  }

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}
