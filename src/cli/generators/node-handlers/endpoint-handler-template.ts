/**
 * Node.js Endpoint Handler Template
 *
 * Generates Express-compatible handler files for custom endpoints
 * defined via defineEndpoint().
 *
 * @module cli/generators/node-handlers/endpoint-handler-template
 * @category CLI
 */

import type { AnalyzedEndpoint, GenerationTarget, SchemockConfig } from '../../types';
import {
  generateParamParsingExpression,
  generateEndpointTodoBody,
  getQueryParams,
  type BackendType,
} from '../shared/endpoint-helpers';

/**
 * Generate an Express handler file for a custom endpoint
 */
export function generateEndpointHandlerFile(
  endpoint: AnalyzedEndpoint,
  target: GenerationTarget,
  _config: SchemockConfig
): string {
  const backend = (target.backend || 'supabase') as BackendType;
  const hasBody = endpoint.body.length > 0;
  const hasParams = endpoint.params.length > 0 || endpoint.pathParams.length > 0;
  const hasResponse = endpoint.response.length > 0;
  const queryParams = getQueryParams(endpoint);

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    `// Custom endpoint: ${endpoint.method} ${endpoint.path}`,
    '',
    "import type { Request, Response, NextFunction } from 'express';",
  ];

  // Import backend client
  if (backend === 'supabase') {
    lines.push("import { supabase } from '../db';");
  } else if (backend === 'firebase') {
    lines.push("import { db } from '../db';");
  } else if (backend === 'pglite') {
    lines.push("import { db } from '../db';");
  } else if (backend === 'fetch') {
    lines.push("import { api } from '../api';");
  }

  // Import endpoint types
  const typeImports: string[] = [];
  if (hasParams) typeImports.push(`${endpoint.pascalName}Params`);
  if (hasBody) typeImports.push(`${endpoint.pascalName}Body`);
  if (hasResponse) typeImports.push(`${endpoint.pascalName}Response`);

  if (typeImports.length > 0) {
    lines.push(`import type { ${typeImports.join(', ')} } from '../endpoint-types';`);
  }

  lines.push('');

  // Handler function
  lines.push('/**');
  lines.push(` * ${endpoint.method} ${endpoint.path}`);
  if (endpoint.description) {
    lines.push(` * ${endpoint.description}`);
  }
  lines.push(' */');
  lines.push(`export async function handler(`);
  lines.push('  req: Request,');
  lines.push('  res: Response,');
  lines.push('  next: NextFunction');
  lines.push('): Promise<void> {');
  lines.push('  try {');

  // Parse path params
  if (endpoint.pathParams.length > 0) {
    const destructured = endpoint.pathParams.join(', ');
    lines.push(`    const { ${destructured} } = req.params;`);
    lines.push('');
  }

  // Parse query params
  if (queryParams.length > 0) {
    for (const param of queryParams) {
      const accessPattern = `req.query.${param.name} as string`;
      const parsed = generateParamParsingExpression(param, accessPattern);
      lines.push(`    const ${param.name} = ${parsed};`);
    }
    lines.push('');
  }

  // Parse body
  if (hasBody) {
    lines.push(`    const body = req.body as ${endpoint.pascalName}Body;`);
    lines.push('');
  }

  // TODO body with DB-specific example
  const todoLines = generateEndpointTodoBody(endpoint, backend);
  lines.push(...todoLines);
  lines.push('');

  // Default response
  lines.push("    res.status(501).json({ error: 'Not implemented' });");

  lines.push('  } catch (error) {');
  lines.push('    next(error);');
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}
