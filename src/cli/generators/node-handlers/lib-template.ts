/**
 * Node.js Library Templates
 *
 * Generates shared library files for Node.js handlers.
 *
 * @module cli/generators/node-handlers/lib-template
 * @category CLI
 */

import type { GenerationTarget, SchemockConfig } from '../../types';

/**
 * Generate all library files for the target
 */
export function generateNodeLibFiles(
  target: GenerationTarget,
  _config: SchemockConfig
): Record<string, string> {
  const files: Record<string, string> = {};
  const backend = target.backend || 'supabase';

  // Generate types re-export
  files['types.ts'] = generateTypesReexport();

  // Generate backend client/db
  if (backend === 'supabase') {
    files['db.ts'] = generateSupabaseDb(target);
  } else if (backend === 'firebase') {
    files['db.ts'] = generateFirebaseDb(target);
  } else if (backend === 'pglite') {
    files['db.ts'] = generatePGliteDb(target);
  } else if (backend === 'fetch') {
    files['api.ts'] = generateFetchApi(target);
  }

  return files;
}

/**
 * Generate types re-export file
 */
function generateTypesReexport(): string {
  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '// Re-export types from the main types file',
    '// You may need to adjust this path based on your project structure',
    "export * from '../types';",
    '',
  ].join('\n');
}

/**
 * Generate Supabase database client
 */
function generateSupabaseDb(target: GenerationTarget): string {
  const envPrefix = (target.options?.envPrefix as string) || 'SUPABASE';

  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { createClient } from '@supabase/supabase-js';",
    '',
    `const supabaseUrl = process.env.${envPrefix}_URL;`,
    `const supabaseServiceKey = process.env.${envPrefix}_SERVICE_ROLE_KEY;`,
    '',
    'if (!supabaseUrl || !supabaseServiceKey) {',
    `  throw new Error('Missing Supabase environment variables: ${envPrefix}_URL and ${envPrefix}_SERVICE_ROLE_KEY');`,
    '}',
    '',
    '/**',
    ' * Supabase client with service role key for server-side operations',
    ' * WARNING: This has full database access - do not expose to client',
    ' */',
    'export const supabase = createClient(supabaseUrl, supabaseServiceKey, {',
    '  auth: {',
    '    autoRefreshToken: false,',
    '    persistSession: false,',
    '  },',
    '});',
    '',
  ].join('\n');
}

/**
 * Generate Firebase database client
 */
function generateFirebaseDb(_target: GenerationTarget): string {
  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { initializeApp, getApps, cert } from 'firebase-admin/app';",
    "import { getFirestore } from 'firebase-admin/firestore';",
    '',
    '// Initialize Firebase Admin SDK',
    'if (!getApps().length) {',
    '  const projectId = process.env.FIREBASE_PROJECT_ID;',
    '  const clientEmail = process.env.FIREBASE_CLIENT_EMAIL;',
    '  const privateKey = process.env.FIREBASE_PRIVATE_KEY?.replace(/\\\\n/g, "\\n");',
    '',
    '  if (!projectId || !clientEmail || !privateKey) {',
    "    throw new Error('Missing Firebase environment variables');",
    '  }',
    '',
    '  initializeApp({',
    '    credential: cert({ projectId, clientEmail, privateKey }),',
    '  });',
    '}',
    '',
    '/**',
    ' * Firestore database instance',
    ' */',
    'export const db = getFirestore();',
    '',
  ].join('\n');
}

/**
 * Generate PGlite database client
 */
function generatePGliteDb(target: GenerationTarget): string {
  const dataDir = (target.options?.dataDir as string) || './data';

  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { PGlite } from '@electric-sql/pglite';",
    '',
    '/**',
    ' * PGlite database instance',
    ' */',
    `export const db = new PGlite('${dataDir}');`,
    '',
    '/**',
    ' * Initialize database schema',
    ' * Call this before using the database',
    ' */',
    'let initialized = false;',
    '',
    'export async function initDb(): Promise<void> {',
    '  if (initialized) return;',
    '',
    '  // Add your table creation SQL here',
    '  // Example:',
    '  // await db.query(`',
    '  //   CREATE TABLE IF NOT EXISTS users (',
    '  //     id TEXT PRIMARY KEY,',
    '  //     name TEXT NOT NULL,',
    '  //     email TEXT UNIQUE NOT NULL',
    '  //   )',
    '  // `);',
    '',
    '  initialized = true;',
    '}',
    '',
  ].join('\n');
}

/**
 * Generate Fetch API client
 */
function generateFetchApi(target: GenerationTarget): string {
  const baseUrl = (target.options?.baseUrl as string) || 'http://localhost:3000/api';

  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    `const BASE_URL = process.env.API_BASE_URL || '${baseUrl}';`,
    '',
    '/**',
    ' * Generic fetch wrapper with error handling',
    ' */',
    'async function fetchApi<T>(',
    '  endpoint: string,',
    '  options: RequestInit = {}',
    '): Promise<T> {',
    '  const url = `${BASE_URL}${endpoint}`;',
    '',
    '  const response = await fetch(url, {',
    '    ...options,',
    '    headers: {',
    "      'Content-Type': 'application/json',",
    '      ...options.headers,',
    '    },',
    '  });',
    '',
    '  if (!response.ok) {',
    '    const error = await response.json().catch(() => ({ error: response.statusText }));',
    "    throw new Error(error.error || 'API request failed');",
    '  }',
    '',
    '  if (response.status === 204) {',
    '    return undefined as T;',
    '  }',
    '',
    '  return response.json();',
    '}',
    '',
    '/**',
    ' * API client',
    ' * Add entity-specific methods as needed',
    ' */',
    'export const api = {',
    '  get: <T>(endpoint: string) => fetchApi<T>(endpoint),',
    '  post: <T>(endpoint: string, data: unknown) =>',
    '    fetchApi<T>(endpoint, { method: "POST", body: JSON.stringify(data) }),',
    '  put: <T>(endpoint: string, data: unknown) =>',
    '    fetchApi<T>(endpoint, { method: "PUT", body: JSON.stringify(data) }),',
    '  delete: (endpoint: string) =>',
    '    fetchApi<void>(endpoint, { method: "DELETE" }),',
    '};',
    '',
  ].join('\n');
}
