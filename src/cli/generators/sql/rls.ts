/**
 * PostgreSQL Row-Level Security policy generator
 *
 * @module cli/generators/sql/rls
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRLS, RLSScopeMapping, RLSBypass } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSnakeCase } from '../../utils/pluralize';
import { escapeSqlString } from './pg-types';

/**
 * Generate RLS policies for all schemas
 */
export function generateRLSPolicies(schemas: AnalyzedSchema[], target: 'postgres' | 'supabase' | 'pglite' = 'postgres'): string {
  const code = new CodeBuilder();

  code.raw('-- ============================================================================');
  code.raw('-- Row-Level Security (RLS) Policies');
  code.raw('-- Generated by Schemock');
  code.raw('-- ============================================================================');
  code.raw('');

  // Helper text for setting context
  code.raw('-- IMPORTANT: Set context before queries using:');
  if (target === 'supabase') {
    code.raw('-- Context is automatically set from JWT claims in Supabase');
    code.raw('-- Custom claims: user_id, role, etc.');
  } else {
    code.raw('-- SET LOCAL app.user_id = \'your-user-id\';');
    code.raw('-- SET LOCAL app.role = \'admin\';');
  }
  code.raw('');

  let totalPolicies = 0;

  for (const schema of schemas) {
    if (schema.rls.enabled) {
      const policyCount = generateSchemaRLS(code, schema, target);
      totalPolicies += policyCount;
    }
  }

  if (totalPolicies === 0) {
    code.raw('-- No RLS policies defined');
  }

  return code.toString();
}

/**
 * Generate RLS policies for a single schema
 */
function generateSchemaRLS(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  target: 'postgres' | 'supabase' | 'pglite'
): number {
  const { rls } = schema;
  const tableName = toSnakeCase(schema.tableName);
  let policyCount = 0;

  code.raw(`-- ----------------------------------------`);
  code.raw(`-- RLS: ${schema.pascalName} (${tableName})`);
  code.raw(`-- ----------------------------------------`);
  code.raw('');

  // Enable RLS on table
  code.raw(`ALTER TABLE "${tableName}" ENABLE ROW LEVEL SECURITY;`);
  code.raw(`ALTER TABLE "${tableName}" FORCE ROW LEVEL SECURITY;`);
  code.raw('');

  // Generate policies for each operation
  const operations = [
    { name: 'SELECT', key: 'select', has: rls.hasSelect, forClause: 'FOR SELECT' },
    { name: 'INSERT', key: 'insert', has: rls.hasInsert, forClause: 'FOR INSERT' },
    { name: 'UPDATE', key: 'update', has: rls.hasUpdate, forClause: 'FOR UPDATE' },
    { name: 'DELETE', key: 'delete', has: rls.hasDelete, forClause: 'FOR DELETE' },
  ] as const;

  for (const op of operations) {
    if (!op.has) continue;

    // Check for custom SQL first
    const customSql = rls.sql?.[op.key];
    if (customSql) {
      generateCustomPolicy(code, tableName, op.name, op.key, customSql, op.forClause);
      policyCount++;
      continue;
    }

    // Generate from scope + bypass
    if (rls.scope.length > 0 || rls.bypass.length > 0) {
      generateScopePolicy(code, tableName, schema.pascalName, op.name, op.key, rls, target, op.forClause);
      policyCount++;
    }
  }

  code.raw('');
  return policyCount;
}

/**
 * Generate policy from custom SQL
 */
function generateCustomPolicy(
  code: CodeBuilder,
  tableName: string,
  opName: string,
  opKey: string,
  customSql: string,
  forClause: string
): void {
  const policyName = `${tableName}_${opKey}_custom`;

  code.raw(`-- Custom ${opName} policy`);
  code.raw(`CREATE POLICY "${policyName}" ON "${tableName}"`);
  code.raw(`  ${forClause}`);

  if (opKey === 'insert') {
    code.raw(`  WITH CHECK (${customSql});`);
  } else {
    code.raw(`  USING (${customSql});`);
  }
  code.raw('');
}

/**
 * Generate policy from scope mappings and bypass conditions
 */
function generateScopePolicy(
  code: CodeBuilder,
  tableName: string,
  entityName: string,
  opName: string,
  opKey: string,
  rls: AnalyzedRLS,
  target: 'postgres' | 'supabase' | 'pglite',
  forClause: string
): void {
  const conditions: string[] = [];

  // Add bypass conditions first (OR logic - any bypass grants full access)
  for (const bypass of rls.bypass) {
    const bypassCondition = generateBypassCondition(bypass, target);
    conditions.push(`(${bypassCondition})`);
  }

  // Add scope conditions (AND logic - all must match)
  const scopeConditions = rls.scope.map((mapping) => generateScopeCondition(mapping, target));
  if (scopeConditions.length > 0) {
    // Scope conditions are ANDed together
    const combinedScope = scopeConditions.join(' AND ');
    conditions.push(`(${combinedScope})`);
  }

  // Combine with OR (bypass OR scope)
  const finalCondition = conditions.length > 0 ? conditions.join(' OR ') : 'FALSE';

  const policyName = `${tableName}_${opKey}_policy`;

  code.raw(`-- ${opName} policy: ${rls.scope.map((s) => s.field).join(', ') || 'custom'}`);
  code.raw(`CREATE POLICY "${policyName}" ON "${tableName}"`);
  code.raw(`  ${forClause}`);

  if (opKey === 'insert') {
    code.raw(`  WITH CHECK (${finalCondition});`);
  } else if (opKey === 'update') {
    // UPDATE needs both USING and WITH CHECK
    code.raw(`  USING (${finalCondition})`);
    code.raw(`  WITH CHECK (${finalCondition});`);
  } else {
    code.raw(`  USING (${finalCondition});`);
  }
  code.raw('');
}

/**
 * Generate bypass condition SQL
 */
function generateBypassCondition(bypass: RLSBypass, target: 'postgres' | 'supabase' | 'pglite'): string {
  const values = bypass.values.map((v) => `'${escapeSqlString(v)}'`).join(', ');
  const contextKey = escapeSqlString(bypass.contextKey);

  if (target === 'supabase') {
    // Supabase uses auth.jwt() for JWT claims
    return `(auth.jwt()->>'${contextKey}') IN (${values})`;
  } else {
    // Standard Postgres uses current_setting
    return `current_setting('app.${contextKey}', true) IN (${values})`;
  }
}

/**
 * Generate scope condition SQL
 */
function generateScopeCondition(mapping: RLSScopeMapping, target: 'postgres' | 'supabase' | 'pglite'): string {
  // Escape field name for use in double-quoted identifier (escape double quotes)
  const escapedField = mapping.field.replace(/"/g, '""');
  const escapedContextKey = escapeSqlString(mapping.contextKey);

  if (target === 'supabase') {
    // Supabase special handling for user_id
    if (mapping.contextKey === 'userId' || mapping.contextKey === 'user_id') {
      return `"${escapedField}" = auth.uid()`;
    }
    // Other context keys from JWT
    return `"${escapedField}"::text = (auth.jwt()->>'${escapedContextKey}')`;
  } else {
    // Standard Postgres - cast based on common patterns
    if (mapping.contextKey.toLowerCase().includes('id')) {
      return `"${escapedField}" = current_setting('app.${escapedContextKey}', true)::uuid`;
    }
    return `"${escapedField}"::text = current_setting('app.${escapedContextKey}', true)`;
  }
}

/**
 * Count RLS policies across all schemas
 */
export function countRLSPolicies(schemas: AnalyzedSchema[]): number {
  let count = 0;
  for (const schema of schemas) {
    const rls = schema.rls;
    if (rls.hasSelect) count++;
    if (rls.hasInsert) count++;
    if (rls.hasUpdate) count++;
    if (rls.hasDelete) count++;
  }
  return count;
}

/**
 * Get RLS summary for README
 */
export function getRLSSummary(schemas: AnalyzedSchema[]): Array<{
  table: string;
  entity: string;
  operations: string[];
  scope: string[];
  bypass: string[];
}> {
  const summary: Array<{
    table: string;
    entity: string;
    operations: string[];
    scope: string[];
    bypass: string[];
  }> = [];

  for (const schema of schemas) {
    if (!schema.rls.enabled) continue;

    const operations: string[] = [];
    if (schema.rls.hasSelect) operations.push('SELECT');
    if (schema.rls.hasInsert) operations.push('INSERT');
    if (schema.rls.hasUpdate) operations.push('UPDATE');
    if (schema.rls.hasDelete) operations.push('DELETE');

    summary.push({
      table: schema.tableName,
      entity: schema.pascalName,
      operations,
      scope: schema.rls.scope.map((s) => `${s.field} = ctx.${s.contextKey}`),
      bypass: schema.rls.bypass.map((b) => `ctx.${b.contextKey} IN [${b.values.join(', ')}]`),
    });
  }

  return summary;
}
