/**
 * PostgreSQL index generator
 *
 * @module cli/generators/sql/indexes
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedIndex } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSnakeCase } from '../../utils/pluralize';

/**
 * Generate CREATE INDEX statements for all schemas
 */
export function generateIndexes(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.raw('-- ============================================================================');
  code.raw('-- Indexes');
  code.raw('-- Generated by Schemock');
  code.raw('-- ============================================================================');
  code.raw('');

  let totalIndexes = 0;

  for (const schema of schemas) {
    if (schema.indexes.length > 0) {
      code.raw(`-- Indexes: ${schema.pascalName}`);

      for (const index of schema.indexes) {
        generateIndex(code, index);
        totalIndexes++;
      }

      code.raw('');
    }
  }

  if (totalIndexes === 0) {
    code.raw('-- No indexes defined');
  }

  return code.toString();
}

/**
 * Generate a single CREATE INDEX statement
 */
function generateIndex(code: CodeBuilder, index: AnalyzedIndex): void {
  const parts: string[] = [];

  // CREATE [UNIQUE] INDEX [CONCURRENTLY]
  parts.push('CREATE');
  if (index.unique) {
    parts.push('UNIQUE');
  }
  parts.push('INDEX');
  if (index.concurrently) {
    parts.push('CONCURRENTLY');
  }
  parts.push('IF NOT EXISTS');

  // Index name
  parts.push(`"${index.name}"`);

  // ON table
  const tableName = toSnakeCase(index.tableName);
  parts.push('ON');
  parts.push(`"${tableName}"`);

  // USING method (if not default btree or if using expression)
  if (index.using) {
    // Functional index with custom expression
    parts.push(`USING ${index.type}`);
    parts.push(`(${index.using})`);
  } else if (index.type !== 'btree') {
    parts.push(`USING ${index.type}`);
    parts.push(`(${index.fields.map((f) => `"${f}"`).join(', ')})`);
  } else {
    // Standard btree index
    parts.push(`(${index.fields.map((f) => `"${f}"`).join(', ')})`);
  }

  // WHERE clause for partial indexes
  if (index.where) {
    parts.push(`WHERE ${index.where}`);
  }

  code.raw(parts.join(' ') + ';');

  // Add comment for auto-generated indexes
  if (index.autoGenerated) {
    code.raw(`  -- Auto-generated for ${index.fields.length > 1 ? 'composite' : index.fields[0].includes('Id') ? 'foreign key' : 'unique field'}`);
  }
}

/**
 * Count total indexes across all schemas
 */
export function countIndexes(schemas: AnalyzedSchema[]): number {
  return schemas.reduce((sum, schema) => sum + schema.indexes.length, 0);
}

/**
 * Get index summary for README
 */
export function getIndexSummary(schemas: AnalyzedSchema[]): Array<{
  table: string;
  name: string;
  fields: string[];
  type: string;
  unique: boolean;
  autoGenerated: boolean;
}> {
  const summary: Array<{
    table: string;
    name: string;
    fields: string[];
    type: string;
    unique: boolean;
    autoGenerated: boolean;
  }> = [];

  for (const schema of schemas) {
    for (const index of schema.indexes) {
      summary.push({
        table: schema.tableName,
        name: index.name,
        fields: index.fields,
        type: index.type,
        unique: index.unique,
        autoGenerated: index.autoGenerated,
      });
    }
  }

  return summary;
}
