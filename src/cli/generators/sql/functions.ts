/**
 * PostgreSQL function (RPC) generator
 *
 * @module cli/generators/sql/functions
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRPC } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSnakeCase } from '../../utils/pluralize';

/**
 * Generate CREATE FUNCTION statements for all schemas
 */
export function generateFunctions(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.raw('-- ============================================================================');
  code.raw('-- Functions (RPC/Stored Procedures)');
  code.raw('-- Generated by Schemock');
  code.raw('-- ============================================================================');
  code.raw('');

  let totalFunctions = 0;

  for (const schema of schemas) {
    if (schema.rpc.length > 0) {
      code.raw(`-- Functions: ${schema.pascalName}`);
      code.raw('');

      for (const rpc of schema.rpc) {
        generateFunction(code, rpc);
        totalFunctions++;
      }
    }
  }

  if (totalFunctions === 0) {
    code.raw('-- No RPC functions defined');
  }

  return code.toString();
}

/**
 * Generate a single CREATE FUNCTION statement
 */
function generateFunction(code: CodeBuilder, rpc: AnalyzedRPC): void {
  const funcName = toSnakeCase(rpc.name);

  // Add description as comment
  if (rpc.description) {
    code.raw(`-- ${rpc.description}`);
  }

  // Build argument list
  const args = rpc.args.map((arg) => {
    let argDef = `${arg.name} ${arg.pgType}`;
    if (arg.default) {
      argDef += ` DEFAULT ${arg.default}`;
    }
    return argDef;
  });

  const argList = args.length > 0 ? args.join(', ') : '';

  // Start function definition
  code.raw(`CREATE OR REPLACE FUNCTION ${funcName}(${argList})`);
  code.raw(`RETURNS ${rpc.pgReturns}`);
  code.raw(`LANGUAGE ${rpc.language}`);
  code.raw(rpc.volatility.toUpperCase());
  code.raw(`SECURITY ${rpc.security.toUpperCase()}`);
  code.raw('AS $$');

  // Function body
  const sqlBody = rpc.sql.trim();
  if (rpc.language === 'plpgsql') {
    // PL/pgSQL - body should include DECLARE/BEGIN/END
    if (!sqlBody.toUpperCase().includes('BEGIN')) {
      // Wrap simple SQL in BEGIN/END for plpgsql
      code.raw('BEGIN');
      code.raw(`  ${sqlBody}`);
      code.raw('END;');
    } else {
      code.raw(sqlBody);
    }
  } else {
    // Plain SQL
    code.raw(`  ${sqlBody}`);
  }

  code.raw('$$;');
  code.raw('');
}

/**
 * Count total functions across all schemas
 */
export function countFunctions(schemas: AnalyzedSchema[]): number {
  return schemas.reduce((sum, schema) => sum + schema.rpc.length, 0);
}

/**
 * Get function summary for README
 */
export function getFunctionSummary(schemas: AnalyzedSchema[]): Array<{
  name: string;
  entity: string;
  args: string;
  returns: string;
  description?: string;
}> {
  const summary: Array<{
    name: string;
    entity: string;
    args: string;
    returns: string;
    description?: string;
  }> = [];

  for (const schema of schemas) {
    for (const rpc of schema.rpc) {
      const argStr = rpc.args.map((a) => `${a.name}: ${a.type}`).join(', ');

      summary.push({
        name: rpc.name,
        entity: schema.pascalName,
        args: argStr || '(none)',
        returns: rpc.returns,
        description: rpc.description,
      });
    }
  }

  return summary;
}
