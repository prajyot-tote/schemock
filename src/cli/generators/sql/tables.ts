/**
 * PostgreSQL table DDL generator
 *
 * @module cli/generators/sql/tables
 * @category CLI
 */

import type { AnalyzedSchema } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { fieldToPgColumn, generateTimestampColumns } from './pg-types';
import { toSnakeCase } from '../../utils/pluralize';

/**
 * Generate CREATE TABLE statements for all schemas
 */
export function generateTables(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.raw('-- ============================================================================');
  code.raw('-- Tables');
  code.raw('-- Generated by Schemock');
  code.raw('-- ============================================================================');
  code.raw('');

  for (const schema of schemas) {
    generateTable(code, schema);
    code.raw('');
  }

  return code.toString();
}

/**
 * Generate CREATE TABLE statement for a single schema
 */
function generateTable(code: CodeBuilder, schema: AnalyzedSchema): void {
  const tableName = toSnakeCase(schema.tableName);

  code.raw(`-- Table: ${schema.pascalName}`);
  code.raw(`CREATE TABLE IF NOT EXISTS "${tableName}" (`);

  const columns: string[] = [];

  // Fields to skip when timestamps are enabled (they'll be added separately)
  const timestampFields = ['createdAt', 'updatedAt', 'created_at', 'updated_at'];

  // Add field columns
  for (const field of schema.fields) {
    // Skip relation fields (they don't have columns)
    if (field.type === 'relation') continue;

    // Skip computed fields (they're not stored in the database)
    if (field.isComputed) continue;

    // Skip timestamp fields when timestamps are enabled (they'll be added by generateTimestampColumns)
    if (schema.hasTimestamps && timestampFields.includes(field.name)) {
      continue;
    }

    const columnDef = fieldToPgColumn(field);
    columns.push(`  ${columnDef}`);
  }

  // Add timestamp columns if enabled
  if (schema.hasTimestamps) {
    const timestampCols = generateTimestampColumns();
    columns.push(...timestampCols.map((col) => `  ${col}`));
  }

  code.raw(columns.join(',\n'));
  code.raw(');');
}

/**
 * Generate foreign key constraints for all schemas
 */
export function generateForeignKeys(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.raw('-- ============================================================================');
  code.raw('-- Foreign Key Constraints');
  code.raw('-- Generated by Schemock');
  code.raw('-- ============================================================================');
  code.raw('');

  const schemaMap = new Map(schemas.map((s) => [s.name, s]));
  let fkCount = 0;

  for (const schema of schemas) {
    const tableName = toSnakeCase(schema.tableName);

    for (const field of schema.fields) {
      if (field.isRef && field.refTarget) {
        const targetSchema = schemaMap.get(field.refTarget);
        if (targetSchema) {
          const targetTable = toSnakeCase(targetSchema.tableName);
          const constraintName = `fk_${tableName}_${toSnakeCase(field.name)}`;

          // Determine ON DELETE behavior
          const onDelete = field.nullable ? 'SET NULL' : 'CASCADE';

          code.raw(`ALTER TABLE "${tableName}"`);
          code.raw(`  ADD CONSTRAINT "${constraintName}"`);
          code.raw(`  FOREIGN KEY ("${field.name}")`);
          code.raw(`  REFERENCES "${targetTable}"("id")`);
          code.raw(`  ON DELETE ${onDelete};`);
          code.raw('');

          fkCount++;
        }
      }
    }
  }

  if (fkCount === 0) {
    code.raw('-- No foreign key constraints');
  }

  return code.toString();
}

/**
 * Generate triggers for automatic timestamp updates
 */
export function generateTriggers(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.raw('-- ============================================================================');
  code.raw('-- Triggers');
  code.raw('-- Generated by Schemock');
  code.raw('-- ============================================================================');
  code.raw('');

  // Generate the shared update_updated_at function
  code.raw('-- Function to update updated_at timestamp');
  code.raw('CREATE OR REPLACE FUNCTION update_updated_at_column()');
  code.raw('RETURNS TRIGGER AS $$');
  code.raw('BEGIN');
  code.raw('  NEW.updated_at = NOW();');
  code.raw('  RETURN NEW;');
  code.raw('END;');
  code.raw('$$ LANGUAGE plpgsql;');
  code.raw('');

  // Generate triggers for each table with timestamps
  for (const schema of schemas) {
    if (schema.hasTimestamps) {
      const tableName = toSnakeCase(schema.tableName);
      const triggerName = `update_${tableName}_updated_at`;

      code.raw(`-- Trigger: ${schema.pascalName}`);
      code.raw(`DROP TRIGGER IF EXISTS "${triggerName}" ON "${tableName}";`);
      code.raw(`CREATE TRIGGER "${triggerName}"`);
      code.raw(`  BEFORE UPDATE ON "${tableName}"`);
      code.raw('  FOR EACH ROW');
      code.raw('  EXECUTE FUNCTION update_updated_at_column();');
      code.raw('');
    }
  }

  return code.toString();
}
