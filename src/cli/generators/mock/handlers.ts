/**
 * MSW handlers generator
 *
 * Generates MSW request handlers that route through the unified API client,
 * ensuring all requests go through the middleware chain (auth, context, RLS).
 *
 * Supports two modes:
 * - Legacy: Uses unified API client directly (for backward compatibility)
 * - Service: Uses service layer with withMiddleware (new pattern)
 *
 * @module cli/generators/mock/handlers
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedEndpoint } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { pluralize } from '../../utils/pluralize';
import { hasAnyRLS } from '../shared/rls';

/**
 * Configuration for handler generation mode
 */
export interface MockHandlersConfig {
  /** API prefix for endpoints (default: '/api') */
  apiPrefix?: string;
  /** Use service layer with middleware (default: false for backward compatibility) */
  useServiceLayer?: boolean;
  /** Path to import services from (when useServiceLayer=true) */
  servicesImport?: string;
  /** Path to import middleware from (when useServiceLayer=true) */
  middlewareImport?: string;
  /** Operations to skip generating */
  skip?: string[];
}

/**
 * Generate MSW request handlers for all entities
 *
 * @param schemas - Analyzed schemas
 * @param apiPrefix - API prefix for endpoints (default: '/api')
 * @returns Generated TypeScript code
 */
export function generateMockHandlers(schemas: AnalyzedSchema[], apiPrefix: string = '/api'): string {
  const code = new CodeBuilder();
  const hasRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { http, HttpResponse } from 'msw';");
  code.line("import { api } from './client';");
  code.line("import { routes } from './routes';");
  code.line("import type * as Types from './types';");
  code.line();

  // Define RLSError locally to avoid bundler issues with symlinked packages
  if (hasRLS) {
    code.comment('RLS error class for access denied responses');
    code.block('class RLSError extends Error {', () => {
      code.line('readonly code = "RLS_DENIED";');
      code.block('constructor(operation: string, entity: string) {', () => {
        code.line('super(`Access denied: ${operation} on ${entity}`);');
        code.line('this.name = "RLSError";');
      });
    });
    code.line();

    code.comment('Handle errors and return appropriate HTTP responses');
    code.block('function handleError(error: unknown): Response {', () => {
      code.block('if (error instanceof RLSError) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 403 });");
      });
      code.block('if (error instanceof Error && error.message.includes("not found")) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 404 });");
      });
      code.line('console.error(error);');
      code.line("return HttpResponse.json({ error: 'Internal server error' }, { status: 500 });");
    });
    code.line();
  }

  code.block('export const handlers = [', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityHandlers(code, schema, hasRLS);
    }
  }, '];');

  return code.toString();
}

/**
 * Generate handlers for a single entity
 */
function generateEntityHandlers(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { name, pascalName } = schema;
  const pluralName = pluralize(name);

  code.comment(`${pascalName} handlers`);

  // GET list
  code.block(`http.get(routes.${pluralName}.list.path, async ({ request }) => {`, () => {
    code.line('const url = new URL(request.url);');
    code.line("const limit = parseInt(url.searchParams.get('limit') || '20');");
    code.line("const offset = parseInt(url.searchParams.get('offset') || '0');");
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.list({ limit, offset });`);
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.list({ limit, offset });`);
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // GET single
  code.block(`http.get(routes.${pluralName}.get.path, async ({ params }) => {`, () => {
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.get(params.id as string);`);
        code.line('if (!response.data) {');
        code.line(`  return HttpResponse.json({ error: '${pascalName} not found' }, { status: 404 });`);
        code.line('}');
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.get(params.id as string);`);
      code.line('if (!response.data) {');
      code.line(`  return HttpResponse.json({ error: '${pascalName} not found' }, { status: 404 });`);
      code.line('}');
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // POST create
  code.block(`http.post(routes.${pluralName}.create.path, async ({ request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Create;`);
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.create(body);`);
        code.line('return HttpResponse.json(response, { status: 201 });');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.create(body);`);
      code.line('return HttpResponse.json(response, { status: 201 });');
    }
  }, '}),');
  code.line();

  // PUT update
  code.block(`http.put(routes.${pluralName}.update.path, async ({ params, request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Update;`);
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.update(params.id as string, body);`);
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.update(params.id as string, body);`);
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // PATCH update (partial)
  code.block(`http.patch(routes.${pluralName}.patch.path, async ({ params, request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Update;`);
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.update(params.id as string, body);`);
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.update(params.id as string, body);`);
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // DELETE
  code.block(`http.delete(routes.${pluralName}.delete.path, async ({ params }) => {`, () => {
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`await api.${name}.delete(params.id as string);`);
        code.line('return new HttpResponse(null, { status: 204 });');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`await api.${name}.delete(params.id as string);`);
      code.line('return new HttpResponse(null, { status: 204 });');
    }
  }, '}),');
  code.line();
}

/**
 * Generate combined handlers export that includes endpoint handlers if they exist
 *
 * @param hasEndpoints - Whether there are custom endpoints defined
 * @returns Generated TypeScript code for all handlers export
 */
export function generateAllHandlersExport(hasEndpoints: boolean): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Combined handlers for MSW setup');
  code.line();

  code.line("import { handlers } from './handlers';");

  if (hasEndpoints) {
    code.line("import { endpointHandlers } from './endpoint-handlers';");
    code.line();
    code.comment('All handlers: entity CRUD + custom endpoints');
    code.line('export const allHandlers = [...handlers, ...endpointHandlers];');
  } else {
    code.line();
    code.comment('All handlers (no custom endpoints defined)');
    code.line('export const allHandlers = handlers;');
  }

  code.line();
  code.comment('Re-export for convenience');
  code.line('export { handlers };');

  if (hasEndpoints) {
    code.line('export { endpointHandlers };');
  }

  return code.toString();
}

/**
 * Generate MSW handlers using service layer with middleware
 *
 * This is the new pattern that uses services instead of the unified client.
 * Services encapsulate business logic and RLS enforcement, handlers just orchestrate.
 *
 * @param schemas - Analyzed schemas
 * @param endpoints - Custom endpoints (optional)
 * @param config - Handler configuration
 * @returns Generated TypeScript code
 */
export function generateMockHandlersWithServices(
  schemas: AnalyzedSchema[],
  endpoints: AnalyzedEndpoint[] = [],
  config: MockHandlersConfig = {}
): string {
  const {
    apiPrefix = '/api',
    servicesImport = './services',
    middlewareImport = './middleware',
    skip = [],
  } = config;

  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('MSW handlers using service layer with middleware');
  code.line();

  // Imports
  code.line("import { http, HttpResponse } from 'msw';");
  code.line(`import { withMiddleware, getMiddleware, type MiddlewareContext } from '${middlewareImport}';`);

  // Import services
  const serviceImports = schemas
    .filter((s) => !s.isJunctionTable)
    .map((s) => `${s.singularName}Service`);
  if (serviceImports.length > 0) {
    code.line(`import { ${serviceImports.join(', ')} } from '${servicesImport}';`);
  }

  // Import types
  const typeImports: string[] = [];
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    typeImports.push(`${schema.pascalName}Create`, `${schema.pascalName}Update`);
  }
  if (typeImports.length > 0) {
    code.line(`import type { ${typeImports.join(', ')} } from './types';`);
  }
  code.line();

  // Query options parser
  generateQueryOptionsParserForMock(code);

  // Generate handlers array
  code.block('export const handlers = [', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateServiceEntityHandlers(code, schema, apiPrefix, skip);
    }

    // Generate endpoint handlers if configured
    if (endpoints.length > 0) {
      code.comment('Custom endpoint handlers');
      for (const endpoint of endpoints) {
        generateServiceEndpointHandler(code, endpoint, apiPrefix);
      }
    }
  }, '];');

  return code.toString();
}

/**
 * Generate query options parser for mock handlers
 */
function generateQueryOptionsParserForMock(code: CodeBuilder): void {
  code.multiDocComment([
    'Parse query options from URL search params',
  ]);
  code.block('function parseQueryOptions(url: URL): { limit?: number; offset?: number; where?: Record<string, unknown> } {', () => {
    code.line("const limit = url.searchParams.get('limit');");
    code.line("const offset = url.searchParams.get('offset');");
    code.line();
    code.line('return {');
    code.line('  limit: limit ? parseInt(limit, 10) : undefined,');
    code.line('  offset: offset ? parseInt(offset, 10) : undefined,');
    code.line('};');
  });
  code.line();
}

/**
 * Generate handlers for a single entity using service layer
 */
function generateServiceEntityHandlers(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  apiPrefix: string,
  skip: string[]
): void {
  const { name, pascalName, singularName } = schema;
  const pluralName = pluralize(name);
  const basePath = `${apiPrefix}/${pluralName}`;

  code.comment(`${pascalName} handlers`);

  // LIST
  if (!skip.includes(`${name}.list`)) {
    code.block(`http.get('${basePath}', async ({ request }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'list'), request, async (ctx) => {`);
      code.indent();
      code.line('const options = parseQueryOptions(new URL(request.url));');
      code.line(`const data = await ${singularName}Service.list(ctx, options);`);
      code.line('return HttpResponse.json({');
      code.line('  data,');
      code.line('  meta: { limit: options.limit ?? 20, offset: options.offset ?? 0 },');
      code.line('});');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // GET
  if (!skip.includes(`${name}.get`)) {
    code.block(`http.get('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'get'), request, async (ctx) => {`);
      code.indent();
      code.line(`const data = await ${singularName}Service.get(ctx, params.id as string);`);
      code.line('return HttpResponse.json({ data });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // CREATE
  if (!skip.includes(`${name}.create`)) {
    code.block(`http.post('${basePath}', async ({ request }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'create'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Create;`);
      code.line(`const data = await ${singularName}Service.create(ctx, body);`);
      code.line('return HttpResponse.json({ data }, { status: 201 });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // UPDATE (PUT)
  if (!skip.includes(`${name}.update`)) {
    code.block(`http.put('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, params.id as string, body);`);
      code.line('return HttpResponse.json({ data });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();

    // UPDATE (PATCH) - same as PUT
    code.block(`http.patch('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, params.id as string, body);`);
      code.line('return HttpResponse.json({ data });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.block(`http.delete('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'delete'), request, async (ctx) => {`);
      code.indent();
      code.line(`await ${singularName}Service.delete(ctx, params.id as string);`);
      code.line('return new HttpResponse(null, { status: 204 });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }
}

/**
 * Generate handler for custom endpoint using service layer
 */
function generateServiceEndpointHandler(
  code: CodeBuilder,
  endpoint: AnalyzedEndpoint,
  apiPrefix: string
): void {
  const method = endpoint.method.toLowerCase();
  const path = endpoint.path.startsWith('/') ? endpoint.path : `/${endpoint.path}`;

  // Convert :param to path params pattern for MSW
  const mswPath = path.replace(/:([^/]+)/g, ':$1');

  code.block(`http.${method}('${apiPrefix}${mswPath}', async ({ request, params }) => {`, () => {
    code.comment(`Custom endpoint: ${endpoint.name}`);

    // Check if endpoint has middleware
    const hasMiddleware = endpoint.middleware && endpoint.middleware.length > 0;

    if (hasMiddleware) {
      code.line(`return withMiddleware([], request, async (ctx) => { // TODO: Wire up middleware`);
    } else {
      code.line('const ctx: MiddlewareContext = {}; // No middleware configured');
    }

    code.indent();
    code.comment('TODO: Import and call endpoint service');
    code.line('return HttpResponse.json({ message: "Not implemented" }, { status: 501 });');
    code.dedent();

    if (hasMiddleware) {
      code.line('});');
    }
  }, '}),');
  code.line();
}
