/**
 * MSW handlers generator
 *
 * Generates MSW request handlers that route through the unified API client,
 * ensuring all requests go through the middleware chain (auth, context, RLS).
 *
 * @module cli/generators/mock/handlers
 * @category CLI
 */

import type { AnalyzedSchema } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { pluralize } from '../../utils/pluralize';
import { hasAnyRLS } from '../shared/rls';

/**
 * Generate MSW request handlers for all entities
 *
 * @param schemas - Analyzed schemas
 * @param apiPrefix - API prefix for endpoints (default: '/api')
 * @returns Generated TypeScript code
 */
export function generateMockHandlers(schemas: AnalyzedSchema[], apiPrefix: string = '/api'): string {
  const code = new CodeBuilder();
  const hasRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { http, HttpResponse } from 'msw';");
  code.line("import { api } from './client';");
  code.line("import { routes } from './routes';");
  code.line("import type * as Types from './types';");
  code.line();

  // Define RLSError locally to avoid bundler issues with symlinked packages
  if (hasRLS) {
    code.comment('RLS error class for access denied responses');
    code.block('class RLSError extends Error {', () => {
      code.line('readonly code = "RLS_DENIED";');
      code.block('constructor(operation: string, entity: string) {', () => {
        code.line('super(`Access denied: ${operation} on ${entity}`);');
        code.line('this.name = "RLSError";');
      });
    });
    code.line();

    code.comment('Handle errors and return appropriate HTTP responses');
    code.block('function handleError(error: unknown): Response {', () => {
      code.block('if (error instanceof RLSError) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 403 });");
      });
      code.block('if (error instanceof Error && error.message.includes("not found")) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 404 });");
      });
      code.line('console.error(error);');
      code.line("return HttpResponse.json({ error: 'Internal server error' }, { status: 500 });");
    });
    code.line();
  }

  code.block('export const handlers = [', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityHandlers(code, schema, hasRLS);
    }
  }, '];');

  return code.toString();
}

/**
 * Generate handlers for a single entity
 */
function generateEntityHandlers(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { name, pascalName } = schema;
  const pluralName = pluralize(name);

  code.comment(`${pascalName} handlers`);

  // GET list
  code.block(`http.get(routes.${pluralName}.list.path, async ({ request }) => {`, () => {
    code.line('const url = new URL(request.url);');
    code.line("const limit = parseInt(url.searchParams.get('limit') || '20');");
    code.line("const offset = parseInt(url.searchParams.get('offset') || '0');");
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.list({ limit, offset });`);
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.list({ limit, offset });`);
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // GET single
  code.block(`http.get(routes.${pluralName}.get.path, async ({ params }) => {`, () => {
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.get(params.id as string);`);
        code.line('if (!response.data) {');
        code.line(`  return HttpResponse.json({ error: '${pascalName} not found' }, { status: 404 });`);
        code.line('}');
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.get(params.id as string);`);
      code.line('if (!response.data) {');
      code.line(`  return HttpResponse.json({ error: '${pascalName} not found' }, { status: 404 });`);
      code.line('}');
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // POST create
  code.block(`http.post(routes.${pluralName}.create.path, async ({ request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Create;`);
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.create(body);`);
        code.line('return HttpResponse.json(response, { status: 201 });');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.create(body);`);
      code.line('return HttpResponse.json(response, { status: 201 });');
    }
  }, '}),');
  code.line();

  // PUT update
  code.block(`http.put(routes.${pluralName}.update.path, async ({ params, request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Update;`);
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.update(params.id as string, body);`);
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.update(params.id as string, body);`);
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // PATCH update (partial)
  code.block(`http.patch(routes.${pluralName}.patch.path, async ({ params, request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Update;`);
    code.line();
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`const response = await api.${name}.update(params.id as string, body);`);
        code.line('return HttpResponse.json(response);');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`const response = await api.${name}.update(params.id as string, body);`);
      code.line('return HttpResponse.json(response);');
    }
  }, '}),');
  code.line();

  // DELETE
  code.block(`http.delete(routes.${pluralName}.delete.path, async ({ params }) => {`, () => {
    if (hasRLS) {
      code.block('try {', () => {
        code.line(`await api.${name}.delete(params.id as string);`);
        code.line('return new HttpResponse(null, { status: 204 });');
      }, '} catch (error) {');
      code.indent();
      code.line('return handleError(error);');
      code.dedent();
      code.line('}');
    } else {
      code.line(`await api.${name}.delete(params.id as string);`);
      code.line('return new HttpResponse(null, { status: 204 });');
    }
  }, '}),');
  code.line();
}

/**
 * Generate combined handlers export that includes endpoint handlers if they exist
 *
 * @param hasEndpoints - Whether there are custom endpoints defined
 * @returns Generated TypeScript code for all handlers export
 */
export function generateAllHandlersExport(hasEndpoints: boolean): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Combined handlers for MSW setup');
  code.line();

  code.line("import { handlers } from './handlers';");

  if (hasEndpoints) {
    code.line("import { endpointHandlers } from './endpoint-handlers';");
    code.line();
    code.comment('All handlers: entity CRUD + custom endpoints');
    code.line('export const allHandlers = [...handlers, ...endpointHandlers];');
  } else {
    code.line();
    code.comment('All handlers (no custom endpoints defined)');
    code.line('export const allHandlers = handlers;');
  }

  code.line();
  code.comment('Re-export for convenience');
  code.line('export { handlers };');

  if (hasEndpoints) {
    code.line('export { endpointHandlers };');
  }

  return code.toString();
}
