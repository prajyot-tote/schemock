/**
 * Mock database factory generator (@mswjs/data)
 *
 * @module cli/generators/mock/db
 * @category CLI
 */

import type { AnalyzedSchema } from '../../types';
import type { MockAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate @mswjs/data factory for mock database
 *
 * @param schemas - Analyzed schemas
 * @param config - Mock adapter configuration
 * @returns Generated TypeScript code
 */
export function generateMockDb(schemas: AnalyzedSchema[], config: MockAdapterConfig): string {
  const code = new CodeBuilder();
  const entityNames = schemas.map((s) => s.name);
  const persist = config.persist !== false; // Default to true

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { factory, primaryKey, nullable } from '@mswjs/data';");
  code.line("import { faker } from '@faker-js/faker';");
  code.line();

  // Set faker seed
  if (config.fakerSeed !== undefined) {
    code.line(`faker.seed(${config.fakerSeed});`);
  } else {
    code.line('faker.seed(Date.now());');
  }
  code.line();

  // Generate factory
  code.block('export const db = factory({', () => {
    for (const schema of schemas) {
      generateEntityFactory(code, schema);
    }
  }, '});');
  code.line();

  code.line('export type Database = typeof db;');

  // Add localStorage persistence
  if (persist) {
    code.line();
    generatePersistenceLayer(code, entityNames, config.storageKey);
  }

  return code.toString();
}

/**
 * Generate localStorage persistence layer
 */
function generatePersistenceLayer(code: CodeBuilder, entityNames: string[], storageKey?: string): void {
  const key = storageKey || 'schemock';

  code.comment('=== localStorage Persistence ===');
  code.line();

  code.line(`const STORAGE_KEY = '${key}';`);
  code.line();

  // Check localStorage availability
  code.block('function isLocalStorageAvailable(): boolean {', () => {
    code.block('try {', () => {
      code.line("if (typeof window === 'undefined' || !window.localStorage) return false;");
      code.line("const testKey = '__schemock_test__';");
      code.line("window.localStorage.setItem(testKey, 'test');");
      code.line('window.localStorage.removeItem(testKey);');
      code.line('return true;');
    }, '} catch {');
    code.indent();
    code.line('return false;');
    code.dedent();
    code.line('}');
  });
  code.line();

  // Restore dates helper
  code.block('function restoreDates(record: Record<string, unknown>): Record<string, unknown> {', () => {
    code.line('const result = { ...record };');
    code.block('for (const [key, value] of Object.entries(result)) {', () => {
      code.block("if (typeof value === 'string' && /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(value)) {", () => {
        code.line('const date = new Date(value);');
        code.line('if (!isNaN(date.getTime())) result[key] = date;');
      });
    });
    code.line('return result;');
  });
  code.line();

  // Load from localStorage
  code.block('function loadFromStorage(): void {', () => {
    code.line('if (!isLocalStorageAvailable()) return;');
    code.line();
    code.block('try {', () => {
      for (const entity of entityNames) {
        code.line(`const ${entity}Data = window.localStorage.getItem(\`\${STORAGE_KEY}:${entity}\`);`);
        code.block(`if (${entity}Data) {`, () => {
          code.line(`const records = JSON.parse(${entity}Data) as Record<string, unknown>[];`);
          code.block('for (const record of records) {', () => {
            code.line('const restored = restoreDates(record);');
            code.line(`db.${entity}.create(restored as Parameters<typeof db.${entity}.create>[0]);`);
          });
        });
      }
    }, '} catch (error) {');
    code.indent();
    code.line("console.warn('[Schemock] Error loading from localStorage:', error);");
    code.dedent();
    code.line('}');
  });
  code.line();

  // Save to localStorage
  code.block('function saveToStorage(): void {', () => {
    code.line('if (!isLocalStorageAvailable()) return;');
    code.line();
    code.block('try {', () => {
      for (const entity of entityNames) {
        code.line(`window.localStorage.setItem(\`\${STORAGE_KEY}:${entity}\`, JSON.stringify(db.${entity}.getAll()));`);
      }
    }, '} catch (error) {');
    code.indent();
    code.line("console.warn('[Schemock] Error saving to localStorage:', error);");
    code.dedent();
    code.line('}');
  });
  code.line();

  // Clear storage
  code.block('function clearStorage(): void {', () => {
    code.line('if (!isLocalStorageAvailable()) return;');
    for (const entity of entityNames) {
      code.line(`window.localStorage.removeItem(\`\${STORAGE_KEY}:${entity}\`);`);
    }
  });
  code.line();

  // Debounced save
  code.line('let saveTimer: ReturnType<typeof setTimeout> | null = null;');
  code.line();
  code.block('function scheduleSave(): void {', () => {
    code.line('if (saveTimer) clearTimeout(saveTimer);');
    code.line('saveTimer = setTimeout(() => {');
    code.line('  saveToStorage();');
    code.line('  saveTimer = null;');
    code.line('}, 100);');
  });
  code.line();

  // Wrap db methods to auto-save (entity-specific for type safety)
  code.comment('Wrap database methods to persist on changes');
  code.block('function wrapDbMethods(): void {', () => {
    for (const entity of entityNames) {
      code.line(`const orig${entity}Create = db.${entity}.create.bind(db.${entity});`);
      code.line(`const orig${entity}Update = db.${entity}.update.bind(db.${entity});`);
      code.line(`const orig${entity}Delete = db.${entity}.delete.bind(db.${entity});`);
      code.line();
      code.line(`db.${entity}.create = (data) => {`);
      code.line(`  const result = orig${entity}Create(data);`);
      code.line('  scheduleSave();');
      code.line('  return result;');
      code.line('};');
      code.line();
      code.line(`db.${entity}.update = (query) => {`);
      code.line(`  const result = orig${entity}Update(query);`);
      code.line('  scheduleSave();');
      code.line('  return result;');
      code.line('};');
      code.line();
      code.line(`db.${entity}.delete = (query) => {`);
      code.line(`  const result = orig${entity}Delete(query);`);
      code.line('  scheduleSave();');
      code.line('  return result;');
      code.line('};');
      code.line();
    }
  });
  code.line();

  // Export persistence utilities
  code.comment('Persistence utilities');
  code.block('export const persistence = {', () => {
    code.line('save: saveToStorage,');
    code.line('load: loadFromStorage,');
    code.line('clear: clearStorage,');
    code.line('/** Force immediate save (bypass debounce) */');
    code.block('flush: () => {', () => {
      code.line('if (saveTimer) {');
      code.line('  clearTimeout(saveTimer);');
      code.line('  saveTimer = null;');
      code.line('}');
      code.line('saveToStorage();');
    }, '},');
  }, '};');
  code.line();

  // Initialize
  code.comment('Initialize: load data and wrap methods');
  code.line('loadFromStorage();');
  code.line('wrapDbMethods();');
}

/**
 * Generate factory definition for a single entity
 */
function generateEntityFactory(code: CodeBuilder, schema: AnalyzedSchema): void {
  code.block(`${schema.name}: {`, () => {
    for (const field of schema.fields) {
      if (field.name === 'id') {
        code.line('id: primaryKey(faker.string.uuid),');
      } else if (field.isObject) {
        // @mswjs/data only accepts primitives - serialize objects as JSON strings
        // They'll be parsed back when read from the API
        if (field.nullable) {
          code.line(`${field.name}: nullable(() => JSON.stringify(${field.fakerCall})),`);
        } else {
          code.line(`${field.name}: () => JSON.stringify(${field.fakerCall}),`);
        }
      } else if (field.nullable) {
        code.line(`${field.name}: nullable(() => ${field.fakerCall}),`);
      } else {
        code.line(`${field.name}: () => ${field.fakerCall},`);
      }
    }
    // Note: timestamps (createdAt/updatedAt) are already in schema.fields from defineData()
  }, '},');
}
