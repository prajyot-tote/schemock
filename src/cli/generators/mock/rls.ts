/**
 * RLS generator - Generates RLS filter functions for the mock adapter
 *
 * @module cli/generators/mock/rls
 * @category CLI
 */

import type { AnalyzedSchema } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { collectBypassConditions, hasAnyRLS } from '../shared/rls';

/**
 * Generate rls.ts file with RLS filter functions
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateRLS(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();
  const hasRLS = hasAnyRLS(schemas);
  const bypassConditions = collectBypassConditions(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Import types
  code.line("import type { RLSFilters, RLSFilter } from 'schemock/middleware';");
  code.line();

  // RLS Context type
  code.comment('RLS Context (generic key-value)');
  code.block('export interface RLSContext {', () => {
    code.line('[key: string]: unknown;');
  }, '}');
  code.line();

  // Bypass check function
  if (bypassConditions.length > 0) {
    code.comment('Bypass check - returns true for privileged contexts');
    code.block('function checkBypass(ctx: RLSContext | null): boolean {', () => {
      code.line('if (!ctx) return false;');
      for (const bypass of bypassConditions) {
        const valuesStr = bypass.values.map(v => `'${v}'`).join(', ');
        code.line(`if ([${valuesStr}].includes(ctx.${bypass.contextKey} as string)) return true;`);
      }
      code.line('return false;');
    });
    code.line();
  } else {
    code.comment('No bypass conditions configured');
    code.block('function checkBypass(_ctx: RLSContext | null): boolean {', () => {
      code.line('return false;');
    });
    code.line();
  }

  // Generate filter functions for each entity
  const hasGlobalBypass = bypassConditions.length > 0;
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityRLSFunctions(code, schema, hasGlobalBypass);
  }

  // Generate rlsFilters export
  code.comment('RLS filters export - used by RLS middleware');
  code.block('export const rlsFilters: Record<string, RLSFilters> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const { name, pascalName } = schema;
      code.block(`${name}: {`, () => {
        code.line(`select: rls${pascalName}Select,`);
        code.line(`insert: rls${pascalName}Insert,`);
        code.line(`update: rls${pascalName}Update,`);
        code.line(`delete: rls${pascalName}Delete,`);
      }, '},');
    }
  }, '};');

  return code.toString();
}

/**
 * Generate RLS filter functions for a single entity
 *
 * @param code - Code builder instance
 * @param schema - Analyzed schema for the entity
 * @param hasGlobalBypass - Whether any schema defines bypass conditions (applies to all RLS-enabled entities)
 */
function generateEntityRLSFunctions(code: CodeBuilder, schema: AnalyzedSchema, hasGlobalBypass: boolean): void {
  const { pascalName, rls } = schema;

  code.comment(`RLS filters for ${pascalName}`);
  code.line();

  // Generate each operation filter
  for (const op of ['Select', 'Insert', 'Update', 'Delete'] as const) {
    const funcName = `rls${pascalName}${op}`;

    if (!rls.enabled) {
      // Passthrough function
      code.line(`const ${funcName}: RLSFilter = (_row, _ctx) => true;`);
      continue;
    }

    code.block(`const ${funcName}: RLSFilter = (row, ctx) => {`, () => {
      // Check bypass first - use global bypass conditions (applies to all RLS-enabled entities)
      if (hasGlobalBypass) {
        code.line('if (checkBypass(ctx)) return true;');
        code.line();
      }

      // Apply scope mappings
      if (rls.scope.length > 0) {
        for (const mapping of rls.scope) {
          code.comment(`Scope: ${mapping.field} must match context.${mapping.contextKey}`);
          code.line(`if (!ctx || row.${mapping.field} !== ctx.${mapping.contextKey}) return false;`);
        }
        code.line('return true;');
      } else {
        // No scope - allow all (subject to bypass)
        code.line('return true;');
      }
    }, '};');
    code.line();
  }
}
