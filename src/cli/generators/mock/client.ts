/**
 * Mock API client generator
 *
 * @module cli/generators/mock/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSafePropertyName } from '../../utils/pluralize';
import {
  generateRLSContextType,
  generateBypassCheck,
  generateRLSError,
  collectBypassConditions,
  hasAnyRLS,
  getRLSImports,
} from '../shared/rls';

/**
 * Generate API client for mock adapter
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateMockClient(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();
  const schemasWithRLS = hasAnyRLS(schemas);
  const allBypassConditions = collectBypassConditions(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db } from './db';");
  code.line("import type * as Types from './types';");

  // Add RLS context imports (browser-compatible)
  if (schemasWithRLS) {
    code.line(getRLSImports());
  }
  code.line();

  // RLS support
  if (schemasWithRLS) {
    generateRLSContextType(code);
    generateRLSError(code);
    generateBypassCheck(code, allBypassConditions);
    code.line();

    // Generate RLS filters for each entity
    const hasGlobalBypass = allBypassConditions.length > 0;
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityRLSFilters(code, schema, hasGlobalBypass);
    }
    code.line();
  }

  // Helper for filtering
  generateFilterHelper(code);
  code.line();

  // Helper for parsing JSONB fields (stored as strings in @mswjs/data)
  generateParseRowHelper(code);
  code.line();

  // Generate API
  code.block('export const api = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityApi(code, schema, schemas, schemasWithRLS);
    }
  }, '};');

  return code.toString();
}

/**
 * Generate RLS filter functions for an entity
 *
 * @param code - Code builder instance
 * @param schema - Analyzed schema for the entity
 * @param hasGlobalBypass - Whether any schema defines bypass conditions (applies to all RLS-enabled entities)
 */
function generateEntityRLSFilters(code: CodeBuilder, schema: AnalyzedSchema, hasGlobalBypass: boolean): void {
  const { pascalName, rls } = schema;

  if (!rls.enabled) {
    // Generate passthrough functions
    code.comment(`RLS filters for ${pascalName} (disabled)`);
    code.line(`const rls${pascalName}Select = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Insert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Update = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Delete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line();
    return;
  }

  code.comment(`RLS filters for ${pascalName}`);

  // Map operation to source field
  const sourceFields = {
    Select: rls.selectSource,
    Insert: rls.insertSource,
    Update: rls.updateSource,
    Delete: rls.deleteSource,
  };

  // Generate each operation filter
  for (const op of ['Select', 'Insert', 'Update', 'Delete'] as const) {
    const hasPolicy = rls[`has${op}` as keyof typeof rls];
    const customSource = sourceFields[op];

    code.block(`const rls${pascalName}${op} = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {`, () => {
      // Check bypass conditions first - use global bypass (applies to all RLS-enabled entities)
      if (hasGlobalBypass) {
        code.line('if (checkBypass(ctx)) return true;');
      }

      if (!hasPolicy) {
        code.line('return true;');
        return;
      }

      // If we have custom source code, embed it directly
      if (customSource) {
        // Embed the serialized function body
        for (const line of customSource.split('\n')) {
          code.line(line.trim());
        }
        return;
      }

      // Fallback: Apply scope mappings
      if (rls.scope.length > 0) {
        for (const mapping of rls.scope) {
          code.line(`// Scope: ${mapping.field} must match context.${mapping.contextKey}`);
          code.line(`if (!ctx || row.${mapping.field} !== ctx.${mapping.contextKey}) return false;`);
        }
      }

      code.line('return true;');
    }, '};');
  }
  code.line();
}

/**
 * Generate filter helper function
 */
function generateFilterHelper(code: CodeBuilder): void {
  code.block('function applyFilter<T>(items: T[], filter: Record<string, unknown>): T[] {', () => {
    code.block('return items.filter(item => {', () => {
      code.block('for (const [key, value] of Object.entries(filter)) {', () => {
        code.line('const itemValue = (item as Record<string, unknown>)[key];');
        code.block('if (typeof value === "object" && value !== null) {', () => {
          code.line('const f = value as Record<string, unknown>;');
          code.line("if ('equals' in f && itemValue !== f.equals) return false;");
          code.line("if ('not' in f && itemValue === f.not) return false;");
          code.line("if ('in' in f && !(f.in as unknown[]).includes(itemValue)) return false;");
          code.line("if ('notIn' in f && (f.notIn as unknown[]).includes(itemValue)) return false;");
          code.line("if ('contains' in f && !String(itemValue).includes(f.contains as string)) return false;");
          code.line("if ('startsWith' in f && !String(itemValue).startsWith(f.startsWith as string)) return false;");
          code.line("if ('endsWith' in f && !String(itemValue).endsWith(f.endsWith as string)) return false;");
          code.line("if ('gt' in f && (itemValue as number) <= (f.gt as number)) return false;");
          code.line("if ('lt' in f && (itemValue as number) >= (f.lt as number)) return false;");
          code.line("if ('gte' in f && (itemValue as number) < (f.gte as number)) return false;");
          code.line("if ('lte' in f && (itemValue as number) > (f.lte as number)) return false;");
          code.line("if ('isNull' in f && f.isNull && itemValue !== null && itemValue !== undefined) return false;");
          code.line("if ('isNull' in f && !f.isNull && (itemValue === null || itemValue === undefined)) return false;");
        }, '} else {');
        code.indent();
        code.line('if (itemValue !== value) return false;');
        code.dedent();
        code.line('}');
      });
      code.line('return true;');
    }, '});');
  });
}

/**
 * Generate parseRow helper for JSONB fields
 */
function generateParseRowHelper(code: CodeBuilder): void {
  code.comment('Parse JSONB fields stored as strings by @mswjs/data');
  code.block(
    'function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {',
    () => {
      code.line('const result = { ...row };');
      code.block('for (const field of jsonFields) {', () => {
        code.block('if (result[field] && typeof result[field] === "string") {', () => {
          code.block('try {', () => {
            code.line('result[field] = JSON.parse(result[field] as string);');
          }, '} catch { /* keep as string */ }');
        });
      });
      code.line('return result as T;');
    }
  );
}

/**
 * Generate API methods for a single entity
 */
function generateEntityApi(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  hasRLS: boolean
): void {
  const { name, pascalName, relations, fields, rls } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  // Find JSON/Object fields that need parsing
  const jsonFields = fields.filter((f) => f.isArray || f.isObject).map((f) => f.name);
  const hasJsonFields = jsonFields.length > 0;
  const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');

  code.block(`${name}: {`, () => {
    // LIST
    code.block(
      `list: async (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>): Promise<Types.ListResponse<Types.${pascalName}>> => {`,
      () => {
        if (hasJsonFields) {
          code.line(`let rawItems = db.${name}.getAll() as unknown as Record<string, unknown>[];`);
          code.line(`let items = rawItems.map(row => parseRow<Types.${pascalName}>(row, [${jsonFieldsStr}]));`);
        } else {
          code.line(`let items = db.${name}.getAll() as unknown as Types.${pascalName}[];`);
        }
        code.line();

        // Apply RLS filter for select
        if (hasRLS) {
          code.comment('Apply RLS filter');
          code.line(`const ctx = getContext();`);
          code.line(`items = items.filter(item => rls${pascalName}Select(item as unknown as Record<string, unknown>, ctx));`);
          code.line();
        }

        // Filter
        code.block('if (options?.where) {', () => {
          code.line('items = applyFilter(items, options.where);');
        });
        code.line();

        code.line('const total = items.length;');
        code.line();

        // Sort
        code.block('if (options?.orderBy) {', () => {
          code.line('const [field, dir] = Object.entries(options.orderBy)[0];');
          code.block('items = [...items].sort((a, b) => {', () => {
            code.line('const aVal = (a as Record<string, unknown>)[field] as string | number | Date;');
            code.line('const bVal = (b as Record<string, unknown>)[field] as string | number | Date;');
            code.line("if (aVal < bVal) return dir === 'asc' ? -1 : 1;");
            code.line("if (aVal > bVal) return dir === 'asc' ? 1 : -1;");
            code.line('return 0;');
          }, '});');
        });
        code.line();

        // Paginate
        code.line('const limit = options?.limit ?? 20;');
        code.line('const offset = options?.offset ?? 0;');
        code.line('items = items.slice(offset, offset + limit);');
        code.line();

        // Load relations
        if (hasRelations) {
          code.block('if (options?.include?.length) {', () => {
            code.block('items = items.map(item => {', () => {
              code.line('const result = { ...item } as Record<string, unknown>;');

              for (const rel of relations) {
                code.block(`if (options.include!.includes('${rel.name}')) {`, () => {
                  generateRelationLoad(code, schema, rel);
                });
              }

              code.line(`return result as Types.${pascalName};`);
            }, '});');
          });
          code.line();
        }

        code.line('return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };');
      },
      '},'
    );
    code.line();

    // GET
    code.block(
      `get: async (id: string, options?: { include?: ${includeType}[] }): Promise<Types.ItemResponse<Types.${pascalName}>> => {`,
      () => {
        code.line(`const rawItem = db.${name}.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;`);
        code.line(`if (!rawItem) throw new Error('${pascalName} not found');`);
        if (hasJsonFields) {
          code.line(`const item = parseRow<Types.${pascalName}>(rawItem, [${jsonFieldsStr}]);`);
        } else {
          code.line(`const item = rawItem as Types.${pascalName};`);
        }
        code.line();

        // Apply RLS check for select
        if (hasRLS) {
          code.comment('Apply RLS check');
          code.line(`const ctx = getContext();`);
          code.block(`if (!rls${pascalName}Select(item as unknown as Record<string, unknown>, ctx)) {`, () => {
            code.line(`throw new RLSError('select', '${pascalName}');`);
          });
          code.line();
        }

        if (hasRelations) {
          code.line('const result = { ...item } as Record<string, unknown>;');
          code.line();
          code.block('if (options?.include?.length) {', () => {
            for (const rel of relations) {
              code.block(`if (options.include.includes('${rel.name}')) {`, () => {
                generateRelationLoad(code, schema, rel);
              });
            }
          });
          code.line();
          code.line(`return { data: result as Types.${pascalName} };`);
        } else {
          code.line('return { data: item };');
        }
      },
      '},'
    );
    code.line();

    // CREATE
    generateCreateMethod(code, schema, hasJsonFields, jsonFieldsStr, hasRLS);
    code.line();

    // UPDATE
    code.block(`update: async (id: string, input: Types.${pascalName}Update): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      // Check RLS on existing item first
      if (hasRLS) {
        code.comment('Check RLS before update');
        code.line(`const existing = db.${name}.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;`);
        code.line(`if (!existing) throw new Error('${pascalName} not found');`);
        code.line(`const ctx = getContext();`);
        code.block(`if (!rls${pascalName}Update(existing, ctx)) {`, () => {
          code.line(`throw new RLSError('update', '${pascalName}');`);
        });
        code.line();
      }

      code.line(`const rawItem = db.${name}.update({`);
      code.line('  where: { id: { equals: id } },');
      code.line(`  // eslint-disable-next-line @typescript-eslint/no-explicit-any`);
      code.line('  data: { ...input, updatedAt: new Date() } as any,');
      code.line('}) as unknown as Record<string, unknown> | null;');
      if (!hasRLS) {
        code.line(`if (!rawItem) throw new Error('${pascalName} not found');`);
      }
      if (hasJsonFields) {
        code.line(`return { data: parseRow<Types.${pascalName}>(rawItem!, [${jsonFieldsStr}]) };`);
      } else {
        code.line(`return { data: rawItem as Types.${pascalName} };`);
      }
    }, '},');
    code.line();

    // DELETE
    code.block('delete: async (id: string): Promise<void> => {', () => {
      // Check RLS on existing item first
      if (hasRLS) {
        code.comment('Check RLS before delete');
        code.line(`const existing = db.${name}.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;`);
        code.line(`if (!existing) throw new Error('${pascalName} not found');`);
        code.line(`const ctx = getContext();`);
        code.block(`if (!rls${pascalName}Delete(existing, ctx)) {`, () => {
          code.line(`throw new RLSError('delete', '${pascalName}');`);
        });
        code.line();
      }

      code.line(`const item = db.${name}.delete({ where: { id: { equals: id } } });`);
      if (!hasRLS) {
        code.line(`if (!item) throw new Error('${pascalName} not found');`);
      }
    }, '},');
  }, '},');
  code.line();
}

/**
 * Generate code to load a relation
 */
function generateRelationLoad(code: CodeBuilder, schema: AnalyzedSchema, rel: AnalyzedRelation): void {
  // Use resolvedTarget to get the actual entity name (handles aliasing like 'user' -> 'authUser')
  const targetDbName = toSafePropertyName(rel.resolvedTarget);

  if (rel.type === 'hasMany') {
    code.line(`result.${rel.name} = db.${targetDbName}.findMany({`);
    code.line(`  where: { ${rel.foreignKey}: { equals: item.id } }`);
    code.line('});');
  } else if (rel.type === 'hasOne') {
    code.line(`result.${rel.name} = db.${targetDbName}.findFirst({`);
    code.line(`  where: { ${rel.foreignKey}: { equals: item.id } }`);
    code.line('});');
  } else if (rel.type === 'belongsTo') {
    code.line(`result.${rel.name} = db.${targetDbName}.findFirst({`);
    code.line(`  where: { id: { equals: (item as Record<string, unknown>).${rel.localField} as string } }`);
    code.line('});');
  } else if (rel.type === 'manyToMany') {
    // foreignKey is the FK on the junction table pointing to the source entity
    // Note: rel.through should also be resolved if it can be aliased
    const throughDbName = toSafePropertyName(rel.through!);
    code.line(`const junctions = db.${throughDbName}.findMany({`);
    code.line(`  where: { ${rel.foreignKey}: { equals: item.id } }`);
    code.line('});');
    code.line(`result.${rel.name} = junctions`);
    code.line(`  .map(j => db.${targetDbName}.findFirst({`);
    code.line(`    where: { id: { equals: (j as Record<string, unknown>).${rel.otherKey} as string } }`);
    code.line('  }))');
    code.line('  .filter(Boolean);');
  }
}

/**
 * Generate create method with nested relation support
 */
function generateCreateMethod(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  hasJsonFields: boolean,
  jsonFieldsStr: string,
  hasRLS: boolean
): void {
  const { name, pascalName, relations } = schema;
  const nestedRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');

  code.block(`create: async (input: Types.${pascalName}Create): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
    if (nestedRels.length > 0) {
      // Extract nested creates
      const relNames = nestedRels.map((r) => r.name).join(', ');
      code.line(`const { ${relNames}, ...data } = input;`);
      code.line();
      code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
      code.line(`const rawItem = db.${name}.create(data as any) as unknown as Record<string, unknown>;`);
      if (hasJsonFields) {
        code.line(`const item = parseRow<Types.${pascalName}>(rawItem, [${jsonFieldsStr}]);`);
      } else {
        code.line(`const item = rawItem as Types.${pascalName};`);
      }
      code.line();

      // Check RLS on created item
      if (hasRLS) {
        code.comment('Check RLS on created item');
        code.line(`const ctx = getContext();`);
        code.block(`if (!rls${pascalName}Insert(item as unknown as Record<string, unknown>, ctx)) {`, () => {
          code.comment('Rollback by deleting');
          code.line(`db.${name}.delete({ where: { id: { equals: item.id } } });`);
          code.line(`throw new RLSError('insert', '${pascalName}');`);
        });
        code.line();
      }

      for (const rel of nestedRels) {
        // Use resolvedTarget to get the actual entity name
        const targetDbName = toSafePropertyName(rel.resolvedTarget);
        code.block(`if (${rel.name}) {`, () => {
          if (rel.type === 'hasMany') {
            code.block(`for (const nested of ${rel.name}) {`, () => {
              code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
              code.line(`db.${targetDbName}.create({ ...nested, ${rel.foreignKey}: item.id } as any);`);
            });
          } else {
            code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
            code.line(`db.${targetDbName}.create({ ...${rel.name}, ${rel.foreignKey}: item.id } as any);`);
          }
        });
      }

      code.line();
      code.line('return { data: item };');
    } else {
      code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
      code.line(`const rawItem = db.${name}.create(input as any) as unknown as Record<string, unknown>;`);
      if (hasJsonFields) {
        code.line(`const item = parseRow<Types.${pascalName}>(rawItem, [${jsonFieldsStr}]);`);
      } else {
        code.line(`const item = rawItem as Types.${pascalName};`);
      }

      // Check RLS on created item
      if (hasRLS) {
        code.line();
        code.comment('Check RLS on created item');
        code.line(`const ctx = getContext();`);
        code.block(`if (!rls${pascalName}Insert(item as unknown as Record<string, unknown>, ctx)) {`, () => {
          code.comment('Rollback by deleting');
          code.line(`db.${name}.delete({ where: { id: { equals: item.id } } });`);
          code.line(`throw new RLSError('insert', '${pascalName}');`);
        });
      }

      code.line();
      code.line('return { data: item };');
    }
  }, '},');
}
