/**
 * Mock API client generator
 *
 * @module cli/generators/mock/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSafePropertyName } from '../../utils/pluralize';
import {
  generateRLSContextType,
  generateBypassCheck,
  generateRLSError,
  generateNotFoundError,
  collectBypassConditions,
  hasAnyRLS,
  getRLSImports,
} from '../shared/rls';

/**
 * Generate API client for mock adapter
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateMockClient(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();
  const schemasWithRLS = hasAnyRLS(schemas);
  const allBypassConditions = collectBypassConditions(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db } from './db';");
  code.line("import type * as Types from './types';");

  // Add RLS context imports (browser-compatible)
  if (schemasWithRLS) {
    code.line(getRLSImports());
  }
  code.line();

  // Always generate the interceptor infrastructure
  generateRLSContextType(code);

  // Always generate the not found error helper (needed for all entities)
  generateNotFoundError(code);

  // RLS support
  if (schemasWithRLS) {
    generateRLSError(code);
    generateBypassCheck(code, allBypassConditions);
    code.line();

    // Generate RLS filters for each entity
    const hasGlobalBypass = allBypassConditions.length > 0;
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityRLSFilters(code, schema, hasGlobalBypass);
    }
    code.line();
  }

  // Helper for filtering
  generateFilterHelper(code);
  code.line();

  // Helper for parsing JSONB fields (stored as strings in @mswjs/data)
  generateParseRowHelper(code);
  code.line();

  // Generate the API type
  generateApiType(code, schemas);
  code.line();

  // Generate the createClient factory
  generateCreateClientFactory(code, schemas, schemasWithRLS);
  code.line();

  // Export default unconfigured client for simple usage
  code.multiDocComment([
    'Default API client (no interceptors configured).',
    'For production, use createClient() with interceptors instead.',
    '',
    '@example',
    '```typescript',
    "// Simple usage (no auth)",
    'const posts = await api.post.list();',
    '',
    '// For production with auth, use createClient instead:',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${getToken()}`;',
    '    return ctx;',
    '  }',
    '});',
    '```',
  ]);
  code.line('export const api = createClient();');

  return code.toString();
}

/**
 * Generate the ApiClient type
 */
function generateApiType(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.comment('API client type');
  code.block('export interface ApiClient {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const { name, pascalName, relations } = schema;
      const hasRelations = relations.length > 0;
      const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

      code.block(`${name}: {`, () => {
        code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) => Promise<Types.ListResponse<Types.${pascalName}>>;`);
        code.line(`get: (id: string, options?: { include?: ${includeType}[] }) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`create: (input: Types.${pascalName}Create) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`update: (id: string, input: Types.${pascalName}Update) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line('delete: (id: string) => Promise<void>;');
      }, '};');
    }
  }, '}');
}

/**
 * Generate the createClient factory function (both internal and public versions)
 */
function generateCreateClientFactory(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  hasRLS: boolean
): void {
  // Generate internal config type with bypass option
  code.comment('Internal config with RLS bypass option (not exported)');
  code.block('interface _InternalClientConfig extends ClientConfig {', () => {
    code.comment('@internal Bypass RLS checks - for seed/admin operations only');
    code.line('_bypassRLS?: boolean;');
  }, '}');
  code.line();

  // Generate internal factory (used by seed.ts)
  code.comment('Internal factory with RLS bypass capability - used by seed.ts');
  code.block('export function _createInternalClient(config?: _InternalClientConfig): ApiClient {', () => {
    code.line('const interceptors = config ?? {};');
    code.line('const bypassRLS = config?._bypassRLS ?? false;');
    code.line();

    code.comment('Internal helper to run request through interceptors');
    code.block('async function executeRequest<T>(', () => {
      code.line('operation: string,');
      code.line('fn: (ctx: RLSContext | null, bypass: boolean) => T | Promise<T>');
    }, '): Promise<T> {');
    code.indent();

    code.comment('Build request context');
    code.line('let requestCtx: RequestContext = { headers: {}, operation };');
    code.line();

    code.comment('Run onRequest interceptor (user adds auth headers here)');
    code.block('if (interceptors.onRequest) {', () => {
      code.line('requestCtx = await interceptors.onRequest(requestCtx);');
    });
    code.line();

    code.comment('Extract RLS context from headers');
    code.line('const rlsCtx = extractContextFromHeaders(requestCtx.headers);');
    code.line();

    code.block('try {', () => {
      code.line('return await fn(rlsCtx, bypassRLS);');
    }, '} catch (err) {');
    code.indent();
    code.comment('Enhance error if not already ApiError');
    code.line('const error = err instanceof ApiError ? err : new ApiError(');
    code.line('  err instanceof Error ? err.message : String(err),');
    code.line('  500,');
    code.line('  "INTERNAL_ERROR",');
    code.line('  operation');
    code.line(');');
    code.line();
    code.comment('Run onError interceptor');
    code.block('if (interceptors.onError) {', () => {
      code.line('await interceptors.onError(error);');
    });
    code.line();
    code.line('throw error;');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();

    code.comment('Build API client with all entity methods');
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        generateEntityApiFactory(code, schema, schemas, hasRLS);
      }
    }, '};');
  });
  code.line();

  // Generate public factory (no bypass capability)
  code.multiDocComment([
    'Create a configured API client with interceptors.',
    '',
    'Use this for production code to centralize auth and error handling.',
    '',
    '@param config - Client configuration with interceptors',
    '@returns Configured API client',
    '',
    '@example',
    '```typescript',
    "import { createClient } from './generated/client';",
    "import { createMockJwt } from 'schemock/middleware';",
    '',
    'const api = createClient({',
    '  // Add auth headers to every request',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("authToken");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '',
    '  // Centralized error handling',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      // Token expired - redirect to login',
    '      window.location.href = "/login";',
    '    }',
    '    if (error.status === 403) {',
    '      // Access denied - show notification',
    '      toast.error("Access denied");',
    '    }',
    '  }',
    '});',
    '',
    '// Now use the API - auth is automatic',
    'const posts = await api.post.list();',
    '```',
  ]);
  code.block('export function createClient(config?: ClientConfig): ApiClient {', () => {
    code.line('return _createInternalClient(config);');
  });
}

/**
 * Generate RLS filter functions for an entity
 */
function generateEntityRLSFilters(code: CodeBuilder, schema: AnalyzedSchema, hasGlobalBypass: boolean): void {
  const { pascalName, rls } = schema;

  if (!rls.enabled) {
    // Generate passthrough functions
    code.comment(`RLS filters for ${pascalName} (disabled)`);
    code.line(`const rls${pascalName}Select = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Insert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Update = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Delete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line();
    return;
  }

  code.comment(`RLS filters for ${pascalName}`);

  // Map operation to source field
  const sourceFields = {
    Select: rls.selectSource,
    Insert: rls.insertSource,
    Update: rls.updateSource,
    Delete: rls.deleteSource,
  };

  // Generate each operation filter
  for (const op of ['Select', 'Insert', 'Update', 'Delete'] as const) {
    const hasPolicy = rls[`has${op}` as keyof typeof rls];
    const customSource = sourceFields[op];

    code.block(`const rls${pascalName}${op} = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {`, () => {
      // Check bypass conditions first - use global bypass (applies to all RLS-enabled entities)
      if (hasGlobalBypass) {
        code.line('if (checkBypass(ctx)) return true;');
      }

      if (!hasPolicy) {
        code.line('return true;');
        return;
      }

      // If we have custom source code, embed it directly
      if (customSource) {
        // Embed the serialized function body
        for (const line of customSource.split('\n')) {
          code.line(line.trim());
        }
        return;
      }

      // Fallback: Apply scope mappings
      if (rls.scope.length > 0) {
        for (const mapping of rls.scope) {
          code.line(`// Scope: ${mapping.field} must match context.${mapping.contextKey}`);
          code.line(`if (!ctx || row.${mapping.field} !== ctx.${mapping.contextKey}) return false;`);
        }
      }

      code.line('return true;');
    }, '};');
  }
  code.line();
}

/**
 * Generate filter helper function
 */
function generateFilterHelper(code: CodeBuilder): void {
  code.block('function applyFilter<T>(items: T[], filter: Record<string, unknown>): T[] {', () => {
    code.block('return items.filter(item => {', () => {
      code.block('for (const [key, value] of Object.entries(filter)) {', () => {
        code.line('const itemValue = (item as Record<string, unknown>)[key];');
        code.block('if (typeof value === "object" && value !== null) {', () => {
          code.line('const f = value as Record<string, unknown>;');
          code.line("if ('equals' in f && itemValue !== f.equals) return false;");
          code.line("if ('not' in f && itemValue === f.not) return false;");
          code.line("if ('in' in f && !(f.in as unknown[]).includes(itemValue)) return false;");
          code.line("if ('notIn' in f && (f.notIn as unknown[]).includes(itemValue)) return false;");
          code.line("if ('contains' in f && !String(itemValue).includes(f.contains as string)) return false;");
          code.line("if ('startsWith' in f && !String(itemValue).startsWith(f.startsWith as string)) return false;");
          code.line("if ('endsWith' in f && !String(itemValue).endsWith(f.endsWith as string)) return false;");
          code.line("if ('gt' in f && (itemValue as number) <= (f.gt as number)) return false;");
          code.line("if ('lt' in f && (itemValue as number) >= (f.lt as number)) return false;");
          code.line("if ('gte' in f && (itemValue as number) < (f.gte as number)) return false;");
          code.line("if ('lte' in f && (itemValue as number) > (f.lte as number)) return false;");
          code.line("if ('isNull' in f && f.isNull && itemValue !== null && itemValue !== undefined) return false;");
          code.line("if ('isNull' in f && !f.isNull && (itemValue === null || itemValue === undefined)) return false;");
        }, '} else {');
        code.indent();
        code.line('if (itemValue !== value) return false;');
        code.dedent();
        code.line('}');
      });
      code.line('return true;');
    }, '});');
  });
}

/**
 * Generate parseRow helper for JSONB fields
 */
function generateParseRowHelper(code: CodeBuilder): void {
  code.comment('Parse JSONB fields stored as strings by @mswjs/data');
  code.block(
    'function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {',
    () => {
      code.line('const result = { ...row };');
      code.block('for (const field of jsonFields) {', () => {
        code.block('if (result[field] && typeof result[field] === "string") {', () => {
          code.block('try {', () => {
            code.line('result[field] = JSON.parse(result[field] as string);');
          }, '} catch { /* keep as string */ }');
        });
      });
      code.line('return result as T;');
    }
  );
}

/**
 * Generate API methods for a single entity (factory version)
 */
function generateEntityApiFactory(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  hasRLS: boolean
): void {
  const { name, pascalName, relations, fields, rls } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  // Find JSON/Object fields that need parsing
  const jsonFields = fields.filter((f) => f.isArray || f.isObject).map((f) => f.name);
  const hasJsonFields = jsonFields.length > 0;
  const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');

  code.block(`${name}: {`, () => {
    // LIST
    code.line(
      `list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) =>`
    );
    code.indent();
    code.line(`executeRequest('${name}.list', (ctx, bypass) => {`);
    code.indent();
    if (hasJsonFields) {
      code.line(`let rawItems = db.${name}.getAll() as unknown as Record<string, unknown>[];`);
      code.line(`let items = rawItems.map(row => parseRow<Types.${pascalName}>(row, [${jsonFieldsStr}]));`);
    } else {
      code.line(`let items = db.${name}.getAll() as unknown as Types.${pascalName}[];`);
    }
    code.line();

    // Apply RLS filter for select (unless bypass is enabled)
    if (hasRLS) {
      code.comment('Apply RLS filter (skip if bypass enabled)');
      code.block('if (!bypass) {', () => {
        code.line(`items = items.filter(item => rls${pascalName}Select(item as unknown as Record<string, unknown>, ctx));`);
      });
      code.line();
    }

    // Filter
    code.block('if (options?.where) {', () => {
      code.line('items = applyFilter(items, options.where);');
    });
    code.line();

    code.line('const total = items.length;');
    code.line();

    // Sort
    code.block('if (options?.orderBy) {', () => {
      code.line('const [field, dir] = Object.entries(options.orderBy)[0];');
      code.block('items = [...items].sort((a, b) => {', () => {
        code.line('const aVal = (a as Record<string, unknown>)[field] as string | number | Date;');
        code.line('const bVal = (b as Record<string, unknown>)[field] as string | number | Date;');
        code.line("if (aVal < bVal) return dir === 'asc' ? -1 : 1;");
        code.line("if (aVal > bVal) return dir === 'asc' ? 1 : -1;");
        code.line('return 0;');
      }, '});');
    });
    code.line();

    // Paginate
    code.line('const limit = options?.limit ?? 20;');
    code.line('const offset = options?.offset ?? 0;');
    code.line('items = items.slice(offset, offset + limit);');
    code.line();

    // Load relations
    if (hasRelations) {
      code.block('if (options?.include?.length) {', () => {
        code.block('items = items.map(item => {', () => {
          code.line('const result = { ...item } as Record<string, unknown>;');

          for (const rel of relations) {
            code.block(`if (options.include!.includes('${rel.name}')) {`, () => {
              generateRelationLoad(code, schema, rel);
            });
          }

          code.line(`return result as Types.${pascalName};`);
        }, '});');
      });
      code.line();
    }

    code.line('return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };');
    code.dedent();
    code.line('}),');
    code.dedent();
    code.line();

    // GET
    code.line(`get: (id: string, options?: { include?: ${includeType}[] }) =>`);
    code.indent();
    code.line(`executeRequest('${name}.get', (ctx, bypass) => {`);
    code.indent();
    code.line(`const rawItem = db.${name}.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;`);
    code.line(`if (!rawItem) throw createNotFoundError('${pascalName}', id);`);
    if (hasJsonFields) {
      code.line(`const item = parseRow<Types.${pascalName}>(rawItem, [${jsonFieldsStr}]);`);
    } else {
      code.line(`const item = rawItem as Types.${pascalName};`);
    }
    code.line();

    // Apply RLS check for select (unless bypass is enabled)
    if (hasRLS) {
      code.comment('Apply RLS check (skip if bypass enabled)');
      code.block(`if (!bypass && !rls${pascalName}Select(item as unknown as Record<string, unknown>, ctx)) {`, () => {
        code.line(`throw createRLSError('select', '${pascalName}');`);
      });
      code.line();
    }

    if (hasRelations) {
      code.line('const result = { ...item } as Record<string, unknown>;');
      code.line();
      code.block('if (options?.include?.length) {', () => {
        for (const rel of relations) {
          code.block(`if (options.include.includes('${rel.name}')) {`, () => {
            generateRelationLoad(code, schema, rel);
          });
        }
      });
      code.line();
      code.line(`return { data: result as Types.${pascalName} };`);
    } else {
      code.line('return { data: item };');
    }
    code.dedent();
    code.line('}),');
    code.dedent();
    code.line();

    // CREATE
    generateCreateMethodFactory(code, schema, hasJsonFields, jsonFieldsStr, hasRLS);
    code.line();

    // UPDATE
    code.line(`update: (id: string, input: Types.${pascalName}Update) =>`);
    code.indent();
    code.line(`executeRequest('${name}.update', (ctx, bypass) => {`);
    code.indent();

    // Check RLS on existing item first (unless bypass is enabled)
    if (hasRLS) {
      code.comment('Check RLS before update (skip if bypass enabled)');
      code.line(`const existing = db.${name}.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;`);
      code.line(`if (!existing) throw createNotFoundError('${pascalName}', id);`);
      code.block(`if (!bypass && !rls${pascalName}Update(existing, ctx)) {`, () => {
        code.line(`throw createRLSError('update', '${pascalName}');`);
      });
      code.line();
    }

    code.line(`const rawItem = db.${name}.update({`);
    code.line('  where: { id: { equals: id } },');
    code.line(`  // eslint-disable-next-line @typescript-eslint/no-explicit-any`);
    code.line('  data: { ...input, updatedAt: new Date() } as any,');
    code.line('}) as unknown as Record<string, unknown> | null;');
    if (!hasRLS) {
      code.line(`if (!rawItem) throw createNotFoundError('${pascalName}', id);`);
    }
    if (hasJsonFields) {
      code.line(`return { data: parseRow<Types.${pascalName}>(rawItem!, [${jsonFieldsStr}]) };`);
    } else {
      code.line(`return { data: rawItem as Types.${pascalName} };`);
    }
    code.dedent();
    code.line('}),');
    code.dedent();
    code.line();

    // DELETE
    code.line('delete: (id: string) =>');
    code.indent();
    code.line(`executeRequest('${name}.delete', (ctx, bypass) => {`);
    code.indent();

    // Check RLS on existing item first (unless bypass is enabled)
    if (hasRLS) {
      code.comment('Check RLS before delete (skip if bypass enabled)');
      code.line(`const existing = db.${name}.findFirst({ where: { id: { equals: id } } }) as unknown as Record<string, unknown> | null;`);
      code.line(`if (!existing) throw createNotFoundError('${pascalName}', id);`);
      code.block(`if (!bypass && !rls${pascalName}Delete(existing, ctx)) {`, () => {
        code.line(`throw createRLSError('delete', '${pascalName}');`);
      });
      code.line();
    }

    code.line(`const item = db.${name}.delete({ where: { id: { equals: id } } });`);
    if (!hasRLS) {
      code.line(`if (!item) throw createNotFoundError('${pascalName}', id);`);
    }
    code.dedent();
    code.line('}),');
    code.dedent();
  }, '},');
  code.line();
}

/**
 * Generate code to load a relation
 */
function generateRelationLoad(code: CodeBuilder, schema: AnalyzedSchema, rel: AnalyzedRelation): void {
  // Use resolvedTarget to get the actual entity name (handles aliasing like 'user' -> 'authUser')
  const targetDbName = toSafePropertyName(rel.resolvedTarget);

  if (rel.type === 'hasMany') {
    code.line(`result.${rel.name} = db.${targetDbName}.findMany({`);
    code.line(`  where: { ${rel.foreignKey}: { equals: item.id } }`);
    code.line('});');
  } else if (rel.type === 'hasOne') {
    code.line(`result.${rel.name} = db.${targetDbName}.findFirst({`);
    code.line(`  where: { ${rel.foreignKey}: { equals: item.id } }`);
    code.line('});');
  } else if (rel.type === 'belongsTo') {
    code.line(`result.${rel.name} = db.${targetDbName}.findFirst({`);
    code.line(`  where: { id: { equals: (item as Record<string, unknown>).${rel.localField} as string } }`);
    code.line('});');
  } else if (rel.type === 'manyToMany') {
    // foreignKey is the FK on the junction table pointing to the source entity
    const throughDbName = toSafePropertyName(rel.through!);
    code.line(`const junctions = db.${throughDbName}.findMany({`);
    code.line(`  where: { ${rel.foreignKey}: { equals: item.id } }`);
    code.line('});');
    code.line(`result.${rel.name} = junctions`);
    code.line(`  .map(j => db.${targetDbName}.findFirst({`);
    code.line(`    where: { id: { equals: (j as Record<string, unknown>).${rel.otherKey} as string } }`);
    code.line('  }))');
    code.line('  .filter(Boolean);');
  }
}

/**
 * Generate create method with nested relation support (factory version)
 */
function generateCreateMethodFactory(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  hasJsonFields: boolean,
  jsonFieldsStr: string,
  hasRLS: boolean
): void {
  const { name, pascalName, relations } = schema;
  const nestedRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');

  code.line(`create: (input: Types.${pascalName}Create) =>`);
  code.indent();
  code.line(`executeRequest('${name}.create', (ctx, bypass) => {`);
  code.indent();

  if (nestedRels.length > 0) {
    // Extract nested creates
    const relNames = nestedRels.map((r) => r.name).join(', ');
    code.line(`const { ${relNames}, ...data } = input;`);
    code.line();
    code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
    code.line(`const rawItem = db.${name}.create(data as any) as unknown as Record<string, unknown>;`);
    if (hasJsonFields) {
      code.line(`const item = parseRow<Types.${pascalName}>(rawItem, [${jsonFieldsStr}]);`);
    } else {
      code.line(`const item = rawItem as Types.${pascalName};`);
    }
    code.line();

    // Check RLS on created item (unless bypass is enabled)
    if (hasRLS) {
      code.comment('Check RLS on created item (skip if bypass enabled)');
      code.block(`if (!bypass && !rls${pascalName}Insert(item as unknown as Record<string, unknown>, ctx)) {`, () => {
        code.comment('Rollback by deleting');
        code.line(`db.${name}.delete({ where: { id: { equals: item.id } } });`);
        code.line(`throw createRLSError('insert', '${pascalName}');`);
      });
      code.line();
    }

    for (const rel of nestedRels) {
      const targetDbName = toSafePropertyName(rel.resolvedTarget);
      code.block(`if (${rel.name}) {`, () => {
        if (rel.type === 'hasMany') {
          code.block(`for (const nested of ${rel.name}) {`, () => {
            code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
            code.line(`db.${targetDbName}.create({ ...nested, ${rel.foreignKey}: item.id } as any);`);
          });
        } else {
          code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
          code.line(`db.${targetDbName}.create({ ...${rel.name}, ${rel.foreignKey}: item.id } as any);`);
        }
      });
    }

    code.line();
    code.line('return { data: item };');
  } else {
    code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
    code.line(`const rawItem = db.${name}.create(input as any) as unknown as Record<string, unknown>;`);
    if (hasJsonFields) {
      code.line(`const item = parseRow<Types.${pascalName}>(rawItem, [${jsonFieldsStr}]);`);
    } else {
      code.line(`const item = rawItem as Types.${pascalName};`);
    }

    // Check RLS on created item (unless bypass is enabled)
    if (hasRLS) {
      code.line();
      code.comment('Check RLS on created item (skip if bypass enabled)');
      code.block(`if (!bypass && !rls${pascalName}Insert(item as unknown as Record<string, unknown>, ctx)) {`, () => {
        code.comment('Rollback by deleting');
        code.line(`db.${name}.delete({ where: { id: { equals: item.id } } });`);
        code.line(`throw createRLSError('insert', '${pascalName}');`);
      });
    }

    code.line();
    code.line('return { data: item };');
  }

  code.dedent();
  code.line('}),');
  code.dedent();
}
