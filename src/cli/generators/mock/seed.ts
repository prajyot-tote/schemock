/**
 * Mock seed generator
 *
 * Generates seed utilities for the mock adapter using the db.* layer directly.
 * The db layer has no RLS enforcement, so seed operations naturally bypass RLS.
 *
 * @module cli/generators/mock/seed
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedField, ProductionSeedConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSafePropertyName } from '../../utils/pluralize';

/**
 * Configuration for seed generation
 */
export interface SeedConfig {
  /** Default seed counts per entity */
  seed?: Record<string, number>;
  /** Faker seed for reproducible data */
  fakerSeed?: number;
  /** Production seed configuration */
  productionSeed?: ProductionSeedConfig;
}

/**
 * Generate seed and reset utilities using the db layer directly
 *
 * The generated code uses `db.{entity}.create()`, `db.{entity}.getAll()`, etc.
 * directly, which bypasses RLS naturally since RLS is only enforced at the
 * api.* layer.
 *
 * @param schemas - Analyzed schemas (topologically sorted)
 * @param config - Seed configuration
 * @returns Generated TypeScript code
 */
export function generateMockSeed(schemas: AnalyzedSchema[], config: SeedConfig = {}): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db } from './db';");
  code.line("import { faker } from '@faker-js/faker';");
  code.line();

  // Set faker seed
  if (config.fakerSeed !== undefined) {
    code.line(`faker.seed(${config.fakerSeed});`);
  } else {
    code.line('faker.seed(Date.now());');
  }
  code.line();

  // Type for seed counts
  code.block('export interface SeedCounts {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      code.line(`${safeName}?: number;`);
    }
  });
  code.line();

  // Default counts
  code.block('const defaultCounts: Required<SeedCounts> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      const count = config.seed?.[schema.name] ?? 10;
      code.line(`${safeName}: ${count},`);
    }
  }, '};');
  code.line();

  // Helper to pick random item from array
  code.block('function pickRandom<T>(arr: T[]): T | undefined {', () => {
    code.line('if (arr.length === 0) return undefined;');
    code.line('return arr[Math.floor(Math.random() * arr.length)];');
  });
  code.line();

  // Generate entity data generator functions
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityGenerator(code, schema);
    code.line();
  }

  // Seed function - creates relational data with valid foreign keys
  code.multiDocComment([
    'Seed the database with fake data.',
    '',
    'Creates entities in dependency order to ensure valid foreign key references.',
    'Uses the db layer directly, which naturally bypasses RLS.',
    '',
    '@param counts - Optional count overrides per entity',
    '',
    '@example',
    '```typescript',
    '// Seed with defaults',
    'await seed();',
    '',
    '// Seed with custom counts',
    'await seed({ user: 5, post: 20 });',
    '```',
  ]);
  code.block('export async function seed(counts: SeedCounts = {}): Promise<void> {', () => {
    code.line('const merged = { ...defaultCounts, ...counts };');
    code.line();
    code.comment('Track created entity IDs for foreign key references');
    code.line('const ids: Record<string, string[]> = {};');
    code.line();

    // Generate in dependency order (schemas are already sorted)
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;

      const safeName = toSafePropertyName(schema.name);

      // Find FK fields from belongsTo relations (these need valid parent IDs)
      const belongsToRels = schema.relations.filter((r) => r.type === 'belongsTo');
      // Map: localField -> target entity name
      const fkFields = belongsToRels.map((r) => ({
        fieldName: r.localField || r.foreignKey,
        target: toSafePropertyName(r.target),
        nullable: schema.fields.find((f) => f.name === (r.localField || r.foreignKey))?.nullable ?? false,
      }));

      code.line(`ids.${safeName} = [];`);
      code.block(`for (let i = 0; i < merged.${safeName}; i++) {`, () => {
        code.line(`const data = generate${schema.pascalName}();`);

        // Set FK values from parent entities
        if (fkFields.length > 0) {
          for (const fk of fkFields) {
            if (fk.nullable) {
              // Nullable FK: sometimes null, sometimes valid ID
              code.line(`data.${fk.fieldName} = Math.random() > 0.3 ? pickRandom(ids.${fk.target}) ?? null : null;`);
            } else {
              // Required FK: always use valid parent ID
              code.line(`data.${fk.fieldName} = pickRandom(ids.${fk.target})!;`);
            }
          }
        }

        code.line();
        code.comment('Use db layer directly - bypasses RLS');
        code.line(`// eslint-disable-next-line @typescript-eslint/no-explicit-any`);
        code.line(`const created = db.${safeName}.create(data as any);`);
        code.line(`ids.${safeName}.push(created.id);`);
      });
      code.line();
    }

    code.line("console.log('\\u2713 Database seeded');");
  });
  code.line();

  // Reset function - delete all data
  code.multiDocComment([
    'Reset the database by deleting all data.',
    '',
    'Deletes entities in reverse dependency order to respect foreign key constraints.',
    '',
    '@example',
    '```typescript',
    'await reset();',
    '```',
  ]);
  code.block('export async function reset(): Promise<void> {', () => {
    // Delete in reverse order (dependents first)
    for (const schema of [...schemas].reverse()) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      code.line(`const ${safeName}List = db.${safeName}.getAll();`);
      code.block(`for (const item of ${safeName}List) {`, () => {
        code.line(`db.${safeName}.delete({ where: { id: { equals: item.id } } });`);
      });
      code.line();
    }

    code.line("console.log('\\u2713 Database reset');");
  });
  code.line();

  // Get all function (for debugging)
  code.multiDocComment([
    'Get all data from the database.',
    '',
    'Useful for debugging and testing.',
    '',
    '@returns Record of entity name to array of items',
    '',
    '@example',
    '```typescript',
    'const data = await getAll();',
    'console.log(data.user); // All users',
    '```',
  ]);
  code.block('export async function getAll(): Promise<Record<string, unknown[]>> {', () => {
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        const safeName = toSafePropertyName(schema.name);
        code.line(`${safeName}: db.${safeName}.getAll(),`);
      }
    }, '};');
  });
  code.line();

  // Count function
  code.multiDocComment([
    'Get the count of each entity in the database.',
    '',
    '@returns Record of entity name to count',
    '',
    '@example',
    '```typescript',
    'const counts = await count();',
    'console.log(counts.user); // Number of users',
    '```',
  ]);
  code.block('export async function count(): Promise<Record<string, number>> {', () => {
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        const safeName = toSafePropertyName(schema.name);
        code.line(`${safeName}: db.${safeName}.getAll().length,`);
      }
    }, '};');
  });
  code.line();

  // Production seed utilities
  generateProductionSeedUtils(code, schemas, config.productionSeed);

  return code.toString();
}

/**
 * Generate a function that creates fake entity data
 */
function generateEntityGenerator(code: CodeBuilder, schema: AnalyzedSchema): void {
  // Build the return type shape for fields
  const fieldTypes: string[] = [];
  for (const field of schema.fields) {
    if (field.name === 'id') continue; // UUID auto-generated by DB/client
    if (field.readOnly) continue; // Skip readOnly fields (createdAt, updatedAt)
    if (field.isRef) {
      // FK fields - respect nullable property
      fieldTypes.push(`${field.name}: string${field.nullable ? ' | null' : ''}`);
    } else {
      fieldTypes.push(`${field.name}: ${field.tsType}${field.nullable ? ' | null' : ''}`);
    }
  }

  code.block(`function generate${schema.pascalName}(): { ${fieldTypes.join('; ')} } {`, () => {
    code.block('return {', () => {
      for (const field of schema.fields) {
        if (field.name === 'id') continue; // UUID auto-generated
        if (field.readOnly) continue; // Skip readOnly fields
        if (field.isRef) {
          // FK fields - placeholder, will be set by seed function
          if (field.nullable) {
            code.line(`${field.name}: null,`);
          } else {
            // Non-nullable FK: use empty string as placeholder (will be overwritten)
            code.line(`${field.name}: '',`);
          }
        } else {
          generateFieldValue(code, field);
        }
      }
    }, '};');
  });
}

/**
 * Generate faker call for a field
 */
function generateFieldValue(code: CodeBuilder, field: AnalyzedField): void {
  // Handle nullable fields
  if (field.nullable) {
    code.line(`${field.name}: Math.random() > 0.1 ? ${field.fakerCall} : null,`);
  } else {
    code.line(`${field.name}: ${field.fakerCall},`);
  }
}

/**
 * Generate production seed utilities with kill switch
 *
 * These functions allow users to seed custom production data (super admin, default products)
 * that runs only once using a localStorage-based kill switch.
 */
function generateProductionSeedUtils(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  productionSeedConfig?: ProductionSeedConfig
): void {
  // Always generate the types and utilities, but show conditional import based on config
  const dataPath = productionSeedConfig?.dataPath ?? '../../seed-data';

  code.comment('='.repeat(70));
  code.comment('Production Seed Utilities');
  code.comment('='.repeat(70));
  code.line();

  // Import seed config from user's file (conditionally)
  code.comment('Import production seed configuration');
  code.comment('Create a seed-data.ts file in your project root with:');
  code.comment('export const seedConfig = { secret: "your-secret", data: { users: [...], products: [...] } };');
  code.line();

  // SeedResult type
  code.multiDocComment([
    'Result of a production seed operation.',
  ]);
  code.block('export interface SeedResult {', () => {
    code.line('success: boolean;');
    code.line("error?: 'INVALID_SECRET' | 'ALREADY_SEEDED';");
    code.line('seededAt?: Date;');
  });
  code.line();

  // SeedConfig type
  code.multiDocComment([
    'Configuration for production seed data.',
    '',
    'Define this in your seed-data.ts file:',
    '```typescript',
    "export const seedConfig = {",
    "  secret: 'my-production-secret-123',",
    "  data: {",
    "    users: [{ id: 'admin-uuid', name: 'Super Admin', email: 'admin@example.com' }],",
    "    products: [{ id: 'prod-1', name: 'Default Product', price: 9.99 }],",
    "  },",
    "};",
    '```',
  ]);
  code.block('export interface ProductionSeedData {', () => {
    code.line('secret: string;');
    code.line('data: Record<string, Record<string, unknown>[]>;');
  });
  code.line();

  code.comment('localStorage key for kill switch');
  code.line("const SEED_STORAGE_KEY = '_schemock_seeded';");
  code.line();

  // isSeeded function
  code.multiDocComment([
    'Check if production data has already been seeded.',
    '',
    '@returns true if production seed has already run',
    '',
    '@example',
    '```typescript',
    'if (!isSeeded()) {',
    "  await runProductionSeed('my-secret');",
    '}',
    '```',
  ]);
  code.block('export function isSeeded(): boolean {', () => {
    code.line("if (typeof localStorage === 'undefined') return false;");
    code.line('return localStorage.getItem(SEED_STORAGE_KEY) !== null;');
  });
  code.line();

  // resetProductionSeed function
  code.multiDocComment([
    'Reset the production seed kill switch.',
    '',
    'Call this if you need to re-seed production data.',
    '',
    '@example',
    '```typescript',
    'resetProductionSeed();',
    "await runProductionSeed('my-secret');",
    '```',
  ]);
  code.block('export function resetProductionSeed(): void {', () => {
    code.line("if (typeof localStorage === 'undefined') return;");
    code.line('localStorage.removeItem(SEED_STORAGE_KEY);');
  });
  code.line();

  // getSeededAt function
  code.multiDocComment([
    'Get the timestamp when production data was seeded.',
    '',
    '@returns Date when seeded, or null if not seeded',
  ]);
  code.block('export function getSeededAt(): Date | null {', () => {
    code.line("if (typeof localStorage === 'undefined') return null;");
    code.line('const timestamp = localStorage.getItem(SEED_STORAGE_KEY);');
    code.line('if (!timestamp) return null;');
    code.line('return new Date(parseInt(timestamp, 10));');
  });
  code.line();

  // runProductionSeed function
  code.multiDocComment([
    'Run the production seed with secret validation and kill switch.',
    '',
    'This function:',
    '1. Validates the provided secret against seedConfig.secret',
    '2. Checks if data has already been seeded (kill switch)',
    '3. Inserts the seed data into the database',
    '4. Sets the kill switch to prevent re-seeding',
    '',
    '@param secretKey - The secret key to validate against seedConfig.secret',
    '@param seedConfig - The seed configuration with secret and data',
    '@returns SeedResult indicating success or failure',
    '',
    '@example',
    '```typescript',
    '// First, import your seed config',
    "import { seedConfig } from './seed-data';",
    '',
    '// Run the seed',
    "const result = await runProductionSeed('my-secret', seedConfig);",
    '',
    'if (result.success) {',
    '  console.log("Seeded at:", result.seededAt);',
    '} else if (result.error === "ALREADY_SEEDED") {',
    '  console.log("Already seeded at:", result.seededAt);',
    '} else if (result.error === "INVALID_SECRET") {',
    '  console.error("Invalid secret key");',
    '}',
    '```',
  ]);
  code.line('export async function runProductionSeed(');
  code.line('  secretKey: string,');
  code.line('  seedConfig: ProductionSeedData');
  code.line('): Promise<SeedResult> {');
  code.indent();

  // Step 1: Validate secret
  code.comment('1. Validate secret');
  code.block('if (secretKey !== seedConfig.secret) {', () => {
    code.line("return { success: false, error: 'INVALID_SECRET' };");
  });
  code.line();

  // Step 2: Check kill switch
  code.comment('2. Check kill switch');
  code.block('if (isSeeded()) {', () => {
    code.line('return {');
    code.line('  success: false,');
    code.line("  error: 'ALREADY_SEEDED',");
    code.line('  seededAt: getSeededAt() ?? undefined,');
    code.line('};');
  });
  code.line();

  // Step 3: Insert data
  code.comment('3. Insert data for each entity');
  code.block('for (const [entity, items] of Object.entries(seedConfig.data)) {', () => {
    code.comment('Get the db method for this entity');
    code.line('// eslint-disable-next-line @typescript-eslint/no-explicit-any');
    code.line('const entityDb = (db as any)[entity];');
    code.block('if (!entityDb) {', () => {
      code.line('console.warn(`Unknown entity in seed data: ${entity}`);');
      code.line('continue;');
    });
    code.line();
    code.block('for (const item of items) {', () => {
      code.block('try {', () => {
        code.line('entityDb.create(item);');
      }, '} catch (e) {');
      code.indent();
      code.comment('Ignore duplicate key errors, log others');
      code.line('const error = e as Error;');
      code.line("if (!error.message?.includes('duplicate')) {");
      code.line('  console.warn(`Failed to seed ${entity}:`, error.message);');
      code.line('}');
      code.dedent();
      code.line('}');
    });
  });
  code.line();

  // Step 4: Set kill switch
  code.comment('4. Set kill switch');
  code.line('const seededAt = new Date();');
  code.line("if (typeof localStorage !== 'undefined') {");
  code.line('  localStorage.setItem(SEED_STORAGE_KEY, seededAt.getTime().toString());');
  code.line('}');
  code.line();

  code.line("console.log('\\u2713 Production data seeded');");
  code.line('return { success: true, seededAt };');
  code.dedent();
  code.line('}');
}
