/**
 * Middleware generator - Generates middleware setup for mock adapter
 *
 * @module cli/generators/mock/middleware
 * @category CLI
 */

import type { AnalyzedSchema } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { hasAnyRLS } from '../shared/rls';

/**
 * Configuration for middleware generation
 */
export interface MiddlewareGenConfig {
  /** Enable auth middleware */
  auth?: boolean;
  /** Enable context middleware */
  context?: boolean;
  /** Enable RLS middleware */
  rls?: boolean;
  /** Enable cache middleware */
  cache?: boolean;
  /** Enable logger middleware */
  logger?: boolean;
  /** Additional headers to extract */
  extractHeaders?: string[];
}

const DEFAULT_CONFIG: MiddlewareGenConfig = {
  auth: true,
  context: true,
  rls: true,
  cache: false,
  logger: true,
  extractHeaders: [],
};

/**
 * Generate middleware.ts file for the mock adapter
 *
 * @param schemas - Analyzed schemas
 * @param config - Generation configuration
 * @returns Generated TypeScript code
 */
export function generateMiddleware(
  schemas: AnalyzedSchema[],
  config?: MiddlewareGenConfig
): string {
  const cfg = { ...DEFAULT_CONFIG, ...config };
  const code = new CodeBuilder();
  const hasRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  generateImports(code, cfg, hasRLS);
  code.line();

  // Default headers storage
  code.comment('Default headers storage (set via setDefaultHeaders)');
  code.line('let defaultHeaders: Record<string, string> = {};');
  code.line();

  code.comment('Set default headers to include in all requests');
  code.block('export function setDefaultHeaders(headers: Record<string, string>): void {', () => {
    code.line('defaultHeaders = headers;');
  });
  code.line();

  code.comment('Get current default headers');
  code.block('export function getDefaultHeaders(): Record<string, string> {', () => {
    code.line('return defaultHeaders;');
  });
  code.line();

  // Import RLS filters if RLS is enabled
  if (cfg.rls && hasRLS) {
    code.comment('Import RLS filters');
    code.line("import { rlsFilters } from './rls';");
    code.line("import { schemas } from './schemas';");
    code.line();
  }

  // Create middleware chain function
  generateCreateMiddlewareChain(code, cfg, hasRLS);

  return code.toString();
}

/**
 * Generate imports
 */
function generateImports(code: CodeBuilder, cfg: MiddlewareGenConfig, hasRLS: boolean): void {
  const imports: string[] = ['orderMiddleware'];

  if (cfg.auth) imports.push('createAuthMiddleware');
  if (cfg.context) imports.push('createContextMiddleware');
  if (cfg.rls && hasRLS) imports.push('createRLSMiddleware');
  if (cfg.cache) imports.push('createCacheMiddleware');
  if (cfg.logger) imports.push('createLoggerMiddleware');

  code.line(`import {`);
  code.indent();
  for (const imp of imports) {
    code.line(`${imp},`);
  }
  code.dedent();
  code.line(`} from 'schemock/middleware';`);

  code.line("import type { Middleware } from 'schemock/middleware';");
}

/**
 * Generate createMiddlewareChain function
 */
function generateCreateMiddlewareChain(
  code: CodeBuilder,
  cfg: MiddlewareGenConfig,
  hasRLS: boolean
): void {
  code.comment('Create and configure the middleware chain');
  code.block('export function createMiddlewareChain(): Middleware[] {', () => {
    code.line('const middlewares: Middleware[] = [];');
    code.line();

    // Auth middleware
    if (cfg.auth) {
      code.comment('Auth: adds token to headers from defaultHeaders');
      code.block('middlewares.push(createAuthMiddleware({', () => {
        code.line('getToken: () => {');
        code.indent();
        code.line("const auth = defaultHeaders['Authorization'] || defaultHeaders['authorization'];");
        code.line("if (!auth) return null;");
        code.line("return auth.replace(/^Bearer\\s+/i, '');");
        code.dedent();
        code.line('},');
      }, '}));');
      code.line();
    }

    // Logger middleware
    if (cfg.logger) {
      code.comment('Logger: logs requests/responses in development');
      code.block('middlewares.push(createLoggerMiddleware({', () => {
        code.line("enabled: process.env.NODE_ENV !== 'production',");
      }, '}));');
      code.line();
    }

    // Context middleware
    if (cfg.context) {
      code.comment('Context: extracts context from headers');
      code.block('middlewares.push(createContextMiddleware({', () => {
        code.line('mockMode: true, // Decode JWT without validation');
        if (cfg.extractHeaders?.length) {
          const headersStr = cfg.extractHeaders.map(h => `'${h}'`).join(', ');
          code.line(`extractHeaders: [${headersStr}],`);
        }
      }, '}));');
      code.line();
    }

    // RLS middleware
    if (cfg.rls && hasRLS) {
      code.comment('RLS: applies row-level security');
      code.block('middlewares.push(createRLSMiddleware({', () => {
        code.line('schemas: new Map(schemas.map(s => [s.name, s])),');
        code.line('getFilters: () => rlsFilters,');
      }, '}));');
      code.line();
    }

    // Cache middleware
    if (cfg.cache) {
      code.comment('Cache: caches read operations');
      code.block('middlewares.push(createCacheMiddleware({', () => {
        code.line('ttl: 60000, // 1 minute');
      }, '}));');
      code.line();
    }

    code.comment('Return ordered middleware');
    code.line('return orderMiddleware(middlewares);');
  });
}
