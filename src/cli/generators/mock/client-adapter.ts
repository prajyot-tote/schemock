/**
 * Mock API client generator (adapter-based)
 *
 * Generates a client that routes all operations through the MockAdapter,
 * which applies middleware (context extraction, RLS, etc.).
 *
 * @module cli/generators/mock/client-adapter
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSafePropertyName } from '../../utils/pluralize';

/**
 * Generate API client that uses the adapter
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateMockClientWithAdapter(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('API client using MockAdapter with middleware pipeline');
  code.line();

  // Imports
  code.line("import { adapter } from './adapter';");
  code.line("import type * as Types from './types';");
  code.line();

  // Generate interceptor types and ApiError
  generateInterceptorTypes(code);
  code.line();

  // Generate ApiClient type
  generateApiType(code, schemas);
  code.line();

  // Generate createClient factory
  generateCreateClientFactory(code, schemas);
  code.line();

  // Export default unconfigured client
  code.multiDocComment([
    'Default API client (no interceptors configured).',
    'For production, use createClient() with interceptors instead.',
    '',
    '@example',
    '```typescript',
    "// Simple usage (no auth)",
    'const posts = await api.post.list();',
    '',
    '// For production with auth, use createClient instead:',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${getToken()}`;',
    '    return ctx;',
    '  }',
    '});',
    '```',
  ]);
  code.line('export const api = createClient();');

  return code.toString();
}

/**
 * Generate interceptor types and error classes
 */
function generateInterceptorTypes(code: CodeBuilder): void {
  code.comment('Request context for interceptors');
  code.block('export interface RequestContext {', () => {
    code.line('headers: Record<string, string>;');
    code.line('operation: string;');
  }, '}');
  code.line();

  code.comment('API error class');
  code.block('export class ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line('readonly operation: string;');
    code.line();
    code.block('constructor(message: string, status: number, code: string, operation: string) {', () => {
      code.line('super(message);');
      code.line("this.name = 'ApiError';");
      code.line('this.status = status;');
      code.line('this.code = code;');
      code.line('this.operation = operation;');
    });
  }, '}');
  code.line();

  code.comment('Client configuration');
  code.block('export interface ClientConfig {', () => {
    code.line('onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;');
    code.line('onError?: (error: ApiError) => void | Promise<void>;');
  }, '}');
}

/**
 * Generate the ApiClient type
 */
function generateApiType(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.comment('Options that can include headers for MSW handler usage');
  code.block('export interface WithHeaders {', () => {
    code.line('/** Headers to pass to adapter (used by MSW handlers) */');
    code.line('headers?: Record<string, string>;');
  }, '}');
  code.line();

  code.comment('API client type');
  code.block('export interface ApiClient {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const { name, pascalName, relations } = schema;
      const hasRelations = relations.length > 0;
      const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

      code.block(`${name}: {`, () => {
        code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}> & WithHeaders) => Promise<Types.ListResponse<Types.${pascalName}>>;`);
        code.line(`get: (id: string, options?: { include?: ${includeType}[] } & WithHeaders) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`create: (input: Types.${pascalName}Create, options?: WithHeaders) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`update: (id: string, input: Types.${pascalName}Update, options?: WithHeaders) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line('delete: (id: string, options?: WithHeaders) => Promise<void>;');
      }, '};');
    }
  }, '}');
}

/**
 * Generate the createClient factory function
 */
function generateCreateClientFactory(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.multiDocComment([
    'Create a configured API client with interceptors.',
    '',
    'Use this for production code to centralize auth and error handling.',
    'The client routes all operations through the MockAdapter, which applies',
    'middleware for context extraction, RLS enforcement, and more.',
    '',
    '@param config - Client configuration with interceptors',
    '@returns Configured API client',
    '',
    '@example',
    '```typescript',
    "import { createClient } from './generated/client';",
    '',
    'const api = createClient({',
    '  // Add auth headers to every request',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("authToken");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '',
    '  // Centralized error handling',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      window.location.href = "/login";',
    '    }',
    '    if (error.status === 403) {',
    '      toast.error("Access denied");',
    '    }',
    '  }',
    '});',
    '```',
  ]);
  code.block('export function createClient(config?: ClientConfig): ApiClient {', () => {
    code.line('const interceptors = config ?? {};');
    code.line();

    code.comment('Helper to build request context and run interceptor');
    code.comment('If headers are provided (from MSW handlers), use them directly');
    code.comment('Otherwise, run onRequest interceptor (for browser usage)');
    code.block('async function buildContext(operation: string, providedHeaders?: Record<string, string>): Promise<Record<string, string>> {', () => {
      code.block('if (providedHeaders) {', () => {
        code.line('return providedHeaders;');
      });
      code.line('let ctx: RequestContext = { headers: {}, operation };');
      code.block('if (interceptors.onRequest) {', () => {
        code.line('ctx = await interceptors.onRequest(ctx);');
      });
      code.line('return ctx.headers;');
    });
    code.line();

    code.comment('Helper to handle errors');
    code.block('async function handleError(error: unknown, operation: string): Promise<never> {', () => {
      code.line("const apiError = error instanceof ApiError ? error : new ApiError(");
      code.line("  error instanceof Error ? error.message : String(error),");
      code.line("  500,");
      code.line("  'INTERNAL_ERROR',");
      code.line("  operation");
      code.line(');');
      code.block('if (interceptors.onError) {', () => {
        code.line('await interceptors.onError(apiError);');
      });
      code.line('throw apiError;');
    });
    code.line();

    code.comment('Build API client with all entity methods');
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        generateEntityApiMethods(code, schema);
      }
    }, '};');
  });
}

/**
 * Generate API methods for a single entity
 */
function generateEntityApiMethods(code: CodeBuilder, schema: AnalyzedSchema): void {
  const { name, pascalName, relations } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  code.block(`${name}: {`, () => {
    // LIST
    code.line(`list: async (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}> & WithHeaders) => {`);
    code.indent();
    code.block('try {', () => {
      code.line(`const headers = await buildContext('${name}.list', options?.headers);`);
      code.line(`const result = await adapter.findMany<Types.${pascalName}>({`);
      code.line(`  entity: '${name}',`);
      code.line('  filter: options?.where,');
      code.line('  orderBy: options?.orderBy,');
      code.line('  limit: options?.limit,');
      code.line('  offset: options?.offset,');
      code.line('  include: options?.include,');
      code.line('  headers,');
      code.line('});');
      code.line('return {');
      code.line('  data: result.data,');
      code.line('  meta: {');
      code.line('    total: result.meta?.total ?? result.data.length,');
      code.line('    limit: options?.limit ?? 20,');
      code.line('    offset: options?.offset ?? 0,');
      code.line('    hasMore: result.meta?.hasMore ?? false,');
      code.line('  },');
      code.line('};');
    }, '} catch (error) {');
    code.indent();
    code.line(`return handleError(error, '${name}.list');`);
    code.dedent();
    code.line('}');
    code.dedent();
    code.line('},');
    code.line();

    // GET
    code.line(`get: async (id: string, options?: { include?: ${includeType}[] } & WithHeaders) => {`);
    code.indent();
    code.block('try {', () => {
      code.line(`const headers = await buildContext('${name}.get', options?.headers);`);
      code.line(`const result = await adapter.findOne<Types.${pascalName}>({`);
      code.line(`  entity: '${name}',`);
      code.line('  params: { id: { equals: id } },');
      code.line('  include: options?.include,');
      code.line('  headers,');
      code.line('});');
      code.block('if (!result.data) {', () => {
        code.line(`throw new ApiError('${pascalName} not found', 404, 'NOT_FOUND', '${name}.get');`);
      });
      code.line('return { data: result.data };');
    }, '} catch (error) {');
    code.indent();
    code.line(`return handleError(error, '${name}.get');`);
    code.dedent();
    code.line('}');
    code.dedent();
    code.line('},');
    code.line();

    // CREATE
    code.line(`create: async (input: Types.${pascalName}Create, options?: WithHeaders) => {`);
    code.indent();
    code.block('try {', () => {
      code.line(`const headers = await buildContext('${name}.create', options?.headers);`);
      code.line(`const result = await adapter.create<Types.${pascalName}>({`);
      code.line(`  entity: '${name}',`);
      code.line('  data: input,');
      code.line('  headers,');
      code.line('});');
      code.line('return { data: result.data };');
    }, '} catch (error) {');
    code.indent();
    code.line(`return handleError(error, '${name}.create');`);
    code.dedent();
    code.line('}');
    code.dedent();
    code.line('},');
    code.line();

    // UPDATE
    code.line(`update: async (id: string, input: Types.${pascalName}Update, options?: WithHeaders) => {`);
    code.indent();
    code.block('try {', () => {
      code.line(`const headers = await buildContext('${name}.update', options?.headers);`);
      code.line(`const result = await adapter.update<Types.${pascalName}>({`);
      code.line(`  entity: '${name}',`);
      code.line('  params: { id: { equals: id } },');
      code.line('  data: input,');
      code.line('  headers,');
      code.line('});');
      code.block('if (!result.data) {', () => {
        code.line(`throw new ApiError('${pascalName} not found', 404, 'NOT_FOUND', '${name}.update');`);
      });
      code.line('return { data: result.data };');
    }, '} catch (error) {');
    code.indent();
    code.line(`return handleError(error, '${name}.update');`);
    code.dedent();
    code.line('}');
    code.dedent();
    code.line('},');
    code.line();

    // DELETE
    code.line('delete: async (id: string, options?: WithHeaders) => {');
    code.indent();
    code.block('try {', () => {
      code.line(`const headers = await buildContext('${name}.delete', options?.headers);`);
      code.line('await adapter.delete({');
      code.line(`  entity: '${name}',`);
      code.line('  params: { id: { equals: id } },');
      code.line('  headers,');
      code.line('});');
    }, '} catch (error) {');
    code.indent();
    code.line(`return handleError(error, '${name}.delete');`);
    code.dedent();
    code.line('}');
    code.dedent();
    code.line('},');
  }, '},');
  code.line();
}
