/**
 * Code generators for custom endpoints
 *
 * Generates TypeScript types, client methods, MSW handlers, and resolvers
 * for custom endpoints defined with defineEndpoint().
 *
 * @module cli/generators/mock/endpoints
 * @category CLI
 */

import type { AnalyzedEndpoint, AnalyzedEndpointField } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

// ============================================================================
// Type Generation
// ============================================================================

/**
 * Generate TypeScript types for all endpoints
 *
 * @param endpoints - Analyzed endpoints
 * @returns Generated TypeScript code for types
 */
export function generateEndpointTypes(endpoints: AnalyzedEndpoint[]): string {
  const code = new CodeBuilder();

  code.line();
  code.comment('=============================================================================');
  code.comment('Custom Endpoint Types');
  code.comment('=============================================================================');
  code.line();

  for (const endpoint of endpoints) {
    generateEndpointTypeSet(code, endpoint);
  }

  return code.toString();
}

/**
 * Generate types for a single endpoint (params, body, response)
 */
function generateEndpointTypeSet(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { pascalName, params, body, response } = endpoint;

  // Generate params type if there are parameters
  if (params.length > 0) {
    code.comment(`Parameters for ${endpoint.path}`);
    code.block(`export interface ${pascalName}Params {`, () => {
      for (const param of params) {
        const optional = !param.required ? '?' : '';
        code.line(`${param.name}${optional}: ${param.tsType};`);
      }
    });
    code.line();
  }

  // Generate body type if there's a body
  if (body.length > 0) {
    code.comment(`Request body for ${endpoint.path}`);
    code.block(`export interface ${pascalName}Body {`, () => {
      for (const field of body) {
        const optional = !field.required ? '?' : '';
        code.line(`${field.name}${optional}: ${field.tsType};`);
      }
    });
    code.line();
  }

  // Generate response type
  code.comment(`Response from ${endpoint.path}`);
  code.block(`export interface ${pascalName}Response {`, () => {
    for (const field of response) {
      code.line(`${field.name}: ${field.tsType};`);
    }
  });
  code.line();
}

// ============================================================================
// Client Generation
// ============================================================================

/**
 * Generate client methods for all endpoints
 *
 * @param endpoints - Analyzed endpoints
 * @returns Generated TypeScript code for endpoint client
 */
export function generateEndpointClient(endpoints: AnalyzedEndpoint[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Client methods for custom endpoints');
  code.line();

  code.line("import type * as Types from './types';");
  code.line();

  code.comment('API base URL - configure based on environment');
  code.line("const API_BASE = typeof window !== 'undefined' ? window.location.origin : '';");
  code.line();

  code.block('export const endpoints = {', () => {
    for (const endpoint of endpoints) {
      generateClientMethod(code, endpoint);
    }
  }, '};');

  return code.toString();
}

/**
 * Generate a single client method
 */
function generateClientMethod(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { name, pascalName, method, path, params, body, pathParams } = endpoint;

  // Build function signature
  const args: string[] = [];
  if (params.length > 0) {
    args.push(`params: Types.${pascalName}Params`);
  }
  if (body.length > 0) {
    args.push(`body: Types.${pascalName}Body`);
  }

  const returnType = `Promise<Types.${pascalName}Response>`;

  code.block(`${name}: async (${args.join(', ')}): ${returnType} => {`, () => {
    // Build URL with path parameter substitution
    let urlExpr: string;

    if (pathParams.length > 0) {
      // URL with path parameters - use template literal
      let pathTemplate = path;
      for (const param of pathParams) {
        pathTemplate = pathTemplate.replace(`:${param}`, `\${params.${param}}`);
      }
      urlExpr = `\`\${API_BASE}${pathTemplate}\``;
    } else {
      urlExpr = `\`\${API_BASE}${path}\``;
    }

    if (method === 'GET' && params.length > 0) {
      // GET with query parameters
      code.line(`const url = new URL(${urlExpr});`);

      // Add non-path query parameters
      const queryParams = params.filter((p) => !pathParams.includes(p.name));
      for (const param of queryParams) {
        code.block(`if (params.${param.name} !== undefined) {`, () => {
          code.line(`url.searchParams.set('${param.name}', String(params.${param.name}));`);
        });
      }

      code.line('const response = await fetch(url.toString());');
    } else if (body.length > 0) {
      // POST/PUT/PATCH with body
      code.line(`const response = await fetch(${urlExpr}, {`);
      code.line(`  method: '${method}',`);
      code.line("  headers: { 'Content-Type': 'application/json' },");
      code.line('  body: JSON.stringify(body),');
      code.line('});');
    } else {
      // Simple request without body
      code.line(`const response = await fetch(${urlExpr}, { method: '${method}' });`);
    }

    code.line();
    code.block('if (!response.ok) {', () => {
      code.line('const error = await response.json().catch(() => ({}));');
      code.line("throw new Error(error.message || `HTTP ${response.status}`);");
    });
    code.line();
    code.line('return response.json();');
  }, '},');
  code.line();
}

// ============================================================================
// Handler Generation
// ============================================================================

/**
 * Generate MSW handlers for all endpoints
 *
 * @param endpoints - Analyzed endpoints
 * @returns Generated TypeScript code for MSW handlers
 */
export function generateEndpointHandlers(endpoints: AnalyzedEndpoint[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('MSW handlers for custom endpoints');
  code.line();

  code.line("import { http, HttpResponse } from 'msw';");
  code.line("import { db } from './db';");
  code.line("import { endpointResolvers } from './endpoint-resolvers';");
  code.line();

  // Generate error handling infrastructure
  code.comment('Error classes for typed error handling');
  code.block('class ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line();
    code.block('constructor(message: string, status: number, code?: string) {', () => {
      code.line('super(message);');
      code.line('this.name = "ApiError";');
      code.line('this.status = status;');
      code.line('this.code = code ?? "API_ERROR";');
    });
  });
  code.line();

  code.block('class RLSError extends Error {', () => {
    code.block('constructor(message: string = "Access denied") {', () => {
      code.line('super(message);');
      code.line('this.name = "RLSError";');
    });
  });
  code.line();

  code.comment('Centralized error handler for endpoint handlers');
  code.block('function handleError(error: unknown): Response {', () => {
    code.block('if (error instanceof ApiError) {', () => {
      code.line('return HttpResponse.json({ error: error.message, code: error.code }, { status: error.status });');
    });
    code.block('if (error instanceof RLSError) {', () => {
      code.line('return HttpResponse.json({ error: error.message }, { status: 403 });');
    });
    code.block('if (error instanceof Error) {', () => {
      code.block('if (error.message.toLowerCase().includes("not found")) {', () => {
        code.line('return HttpResponse.json({ error: error.message }, { status: 404 });');
      });
      code.line('console.error("Endpoint error:", error);');
      code.line('return HttpResponse.json({ error: error.message }, { status: 500 });');
    });
    code.line('console.error("Unknown endpoint error:", error);');
    code.line('return HttpResponse.json({ error: "Internal server error" }, { status: 500 });');
  });
  code.line();

  code.block('export const endpointHandlers = [', () => {
    for (const endpoint of endpoints) {
      generateHandler(code, endpoint);
    }
  }, '];');

  return code.toString();
}

/**
 * Generate a single MSW handler
 */
function generateHandler(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { name, method, path, params, body, pathParams } = endpoint;
  const httpMethod = method.toLowerCase();

  code.comment(`${method} ${path}`);
  code.block(`http.${httpMethod}('${path}', async ({ request, params: pathParams }) => {`, () => {
    // Parse query parameters for GET
    if (method === 'GET' && params.length > 0) {
      code.line('const url = new URL(request.url);');
      code.block('const params = {', () => {
        for (const param of params) {
          if (pathParams.includes(param.name)) {
            // Path parameter
            code.line(`${param.name}: pathParams.${param.name} as string,`);
          } else {
            // Query parameter
            generateParamParsing(code, param);
          }
        }
      }, '};');
      code.line();
    } else if (pathParams.length > 0) {
      // Only path params, no query params
      code.block('const params = {', () => {
        for (const paramName of pathParams) {
          code.line(`${paramName}: pathParams.${paramName} as string,`);
        }
      }, '};');
      code.line();
    }

    // Parse body for POST/PUT/PATCH
    if (body.length > 0) {
      code.line('const body = await request.json();');
      code.line();
    }

    // Build context object
    const ctxParts: string[] = ['db'];
    if (params.length > 0 || pathParams.length > 0) ctxParts.push('params');
    if (body.length > 0) ctxParts.push('body');
    code.line('const headers: Record<string, string> = {};');
    code.line("request.headers.forEach((value, key) => { headers[key] = value; });");
    ctxParts.push('headers');
    code.line();

    // Call resolver with try/catch
    code.block('try {', () => {
      code.line(`const result = await endpointResolvers.${name}({ ${ctxParts.join(', ')} });`);
      code.line('return HttpResponse.json(result);');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();
}

/**
 * Generate parameter parsing code
 */
function generateParamParsing(code: CodeBuilder, param: AnalyzedEndpointField): void {
  const { name, tsType, hasDefault } = param;
  const defaultVal = hasDefault ? JSON.stringify(param.default) : 'undefined';

  if (tsType === 'number' || tsType.includes('number')) {
    if (hasDefault) {
      code.line(`${name}: Number(url.searchParams.get('${name}') ?? ${defaultVal}),`);
    } else {
      code.line(`${name}: url.searchParams.has('${name}') ? Number(url.searchParams.get('${name}')) : undefined,`);
    }
  } else if (tsType === 'boolean' || tsType.includes('boolean')) {
    if (hasDefault) {
      code.line(`${name}: url.searchParams.has('${name}') ? url.searchParams.get('${name}') === 'true' : ${defaultVal},`);
    } else {
      code.line(`${name}: url.searchParams.has('${name}') ? url.searchParams.get('${name}') === 'true' : undefined,`);
    }
  } else {
    // String or enum
    if (hasDefault) {
      code.line(`${name}: url.searchParams.get('${name}') ?? ${defaultVal},`);
    } else {
      code.line(`${name}: url.searchParams.get('${name}') ?? undefined,`);
    }
  }
}

// ============================================================================
// Resolver Generation
// ============================================================================

/**
 * Generate endpoint resolvers file
 *
 * Contains the serialized mock resolver functions from endpoint definitions.
 *
 * @param endpoints - Analyzed endpoints
 * @returns Generated TypeScript code for resolvers
 */
export function generateEndpointResolvers(endpoints: AnalyzedEndpoint[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Mock resolvers for custom endpoints');
  code.comment('');
  code.comment('These resolvers are copied from your defineEndpoint() calls.');
  code.comment('They receive { params, body, db, headers } and return the response.');
  code.line();

  // Type imports
  code.line("import type { MockResolverContext } from 'schemock/schema';");
  code.line();

  // Resolver type
  code.line('type ResolverFn = (ctx: MockResolverContext) => unknown | Promise<unknown>;');
  code.line();

  code.block('export const endpointResolvers: Record<string, ResolverFn> = {', () => {
    for (const endpoint of endpoints) {
      code.comment(`${endpoint.method} ${endpoint.path}`);
      if (endpoint.description) {
        code.comment(endpoint.description);
      }
      code.line(`${endpoint.name}: ${endpoint.mockResolverSource},`);
      code.line();
    }
  }, '};');

  return code.toString();
}
