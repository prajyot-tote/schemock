/**
 * Mock adapter generator - Creates MockAdapter setup with middleware
 *
 * @module cli/generators/mock/adapter
 * @category CLI
 */

import type { AnalyzedSchema } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { hasAnyRLS } from '../shared/rls';
import { toSafePropertyName } from '../../utils/pluralize';

/**
 * Generate adapter.ts with MockAdapter setup including middleware
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateMockAdapter(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();
  const schemasWithRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('MockAdapter setup with middleware pipeline');
  code.line();

  // Imports
  code.line("import { MockAdapter } from 'schemock/adapters';");
  code.line("import type { StorageDriver, QueryOptions, QueryMeta } from 'schemock/adapters';");
  code.line("import { createContextMiddleware } from 'schemock/middleware';");
  if (schemasWithRLS) {
    code.line("import { createRLSMiddleware } from 'schemock/middleware';");
  }
  code.line("import type { EntitySchema } from 'schemock/schema';");
  code.line("import { db, schemas } from './db';");
  if (schemasWithRLS) {
    code.line("import { rlsFilters } from './rls';");
  }
  code.line();

  // Generate the storage driver wrapper
  generateStorageDriverWrapper(code, schemas);
  code.line();

  // Generate schema map for middleware
  code.comment('Schema map for middleware');
  code.line('const schemaMap = new Map<string, EntitySchema>(schemas.map(s => [s.name, s]));');
  code.line();

  // Generate adapter instance
  code.comment('Create MockAdapter with middleware pipeline');
  code.block('export const adapter = new MockAdapter({', () => {
    code.line('driver,');
    code.line('schemas,');
    code.block('middleware: [', () => {
      code.line('createContextMiddleware({ mockMode: true }),');
      if (schemasWithRLS) {
        code.line('createRLSMiddleware({ schemas: schemaMap, getFilters: () => rlsFilters }),');
      }
    }, '],');
  }, '});');
  code.line();

  // Export helper to reinitialize adapter (useful after db reset)
  code.comment('Re-export for convenience');
  code.line('export { schemas, schemaMap };');

  return code.toString();
}

/**
 * Generate a StorageDriver wrapper class that uses the existing @mswjs/data db
 */
function generateStorageDriverWrapper(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.comment('Storage driver wrapper that uses the existing @mswjs/data database');
  code.block('class DbStorageDriver implements StorageDriver {', () => {
    code.line("readonly name = 'msw-wrapper';");
    code.line();

    // initialize - no-op since db is already created
    code.block('async initialize(_schemas: EntitySchema[]): Promise<void> {', () => {
      code.comment('Database is already initialized via db.ts');
    });
    code.line();

    // create
    code.block('async create<T>(entity: string, data: Record<string, unknown>): Promise<T> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.line('return entityDb.create(data) as T;');
    });
    code.line();

    // findOne
    code.block('async findOne<T>(entity: string, where: Record<string, unknown>): Promise<T | null> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.line('return entityDb.findFirst({ where }) as T | null;');
    });
    code.line();

    // findMany
    code.block('async findMany<T>(entity: string, options?: QueryOptions): Promise<{ data: T[]; meta: QueryMeta }> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.line();
      code.line('const query: Record<string, unknown> = {};');
      code.line('if (options?.where) query.where = options.where;');
      code.line('if (options?.orderBy) query.orderBy = options.orderBy;');
      code.line('if (options?.limit) query.take = options.limit;');
      code.line('if (options?.offset) query.skip = options.offset;');
      code.line();
      code.line('const results = entityDb.findMany(query) as T[];');
      code.line('const total = entityDb.count(options?.where ? { where: options.where } : undefined);');
      code.line('const hasMore = options?.limit ? results.length === options.limit : false;');
      code.line();
      code.line('return { data: results, meta: { total, hasMore } };');
    });
    code.line();

    // update
    code.block('async update<T>(entity: string, where: Record<string, unknown>, data: Record<string, unknown>): Promise<T | null> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.block('try {', () => {
        code.line('return entityDb.update({ where, data }) as T;');
      }, '} catch {');
      code.indent();
      code.line('return null;');
      code.dedent();
      code.line('}');
    });
    code.line();

    // delete
    code.block('async delete(entity: string, where: Record<string, unknown>): Promise<boolean> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.block('try {', () => {
        code.line('entityDb.delete({ where });');
        code.line('return true;');
      }, '} catch {');
      code.indent();
      code.line('return false;');
      code.dedent();
      code.line('}');
    });
    code.line();

    // count
    code.block('async count(entity: string, where?: Record<string, unknown>): Promise<number> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.line('return entityDb.count(where ? { where } : undefined);');
    });
    code.line();

    // getAll
    code.block('async getAll<T>(entity: string): Promise<T[]> {', () => {
      code.line('const entityDb = (db as Record<string, any>)[entity];');
      code.line("if (!entityDb) throw new Error(`Entity '${entity}' not found`);");
      code.line('return entityDb.getAll() as T[];');
    });
    code.line();

    // includeRelations
    code.block('async includeRelations<T>(', () => {
      code.line('entity: string,');
      code.line('data: T[],');
      code.line('relations: string[],');
      code.line('schemas: Map<string, EntitySchema>');
    }, '): Promise<T[]> {');
    code.indent();
    code.line('const schema = schemas.get(entity);');
    code.line('if (!schema?.relations) return data;');
    code.line();
    code.line('const result: T[] = [];');
    code.block('for (const record of data) {', () => {
      code.line('const hydrated = { ...(record as Record<string, unknown>) };');
      code.block('for (const relationName of relations) {', () => {
        code.line('const relation = schema.relations![relationName];');
        code.line('if (!relation) continue;');
        code.line('hydrated[relationName] = await this.loadRelation(record as Record<string, unknown>, relation, schemas);');
      });
      code.line('result.push(hydrated as T);');
    });
    code.line('return result;');
    code.dedent();
    code.line('}');
    code.line();

    // seed - delegate to individual creates
    code.block('async seed(counts: Record<string, number>, schemas: Map<string, EntitySchema>): Promise<void> {', () => {
      code.comment('Use the seed utility from seed.ts instead');
      code.line("throw new Error('Use seed() from seed.ts for seeding');");
    });
    code.line();

    // reset
    code.block('async reset(): Promise<void> {', () => {
      code.block('for (const entityName of Object.keys(db)) {', () => {
        code.line('const entityDb = (db as Record<string, any>)[entityName];');
        code.line('if (entityDb?.deleteMany) {');
        code.line('  entityDb.deleteMany({ where: {} });');
        code.line('}');
      });
    });
    code.line();

    // loadRelation helper
    generateLoadRelationHelper(code);
  }, '}');
  code.line();

  code.comment('Create driver instance');
  code.line('const driver = new DbStorageDriver();');
}

/**
 * Generate the loadRelation helper method
 */
function generateLoadRelationHelper(code: CodeBuilder): void {
  code.comment('Helper to load a single relation');
  code.block('private async loadRelation(', () => {
    code.line('record: Record<string, unknown>,');
    code.line("relation: { type: string; target: string; foreignKey?: string; through?: string; otherKey?: string },");
    code.line('schemas: Map<string, EntitySchema>');
  }, '): Promise<unknown> {');
  code.indent();

  code.line('const targetDb = (db as Record<string, any>)[relation.target];');
  code.line("if (!targetDb) return relation.type === 'hasMany' ? [] : null;");
  code.line();

  code.block('switch (relation.type) {', () => {
    code.block("case 'belongsTo': {", () => {
      code.line('const foreignKey = relation.foreignKey || `${relation.target}Id`;');
      code.line('const fkValue = record[foreignKey];');
      code.line('if (!fkValue) return null;');
      code.line('return targetDb.findFirst({ where: { id: { equals: fkValue } } });');
    }, '}');
    code.line();
    code.block("case 'hasOne': {", () => {
      code.line("const foreignKey = relation.foreignKey || 'id';");
      code.line('return targetDb.findFirst({ where: { [foreignKey]: { equals: record.id } } });');
    }, '}');
    code.line();
    code.block("case 'hasMany': {", () => {
      code.line("const foreignKey = relation.foreignKey || 'id';");
      code.line('return targetDb.findMany({ where: { [foreignKey]: { equals: record.id } } });');
    }, '}');
    code.line();
    code.line('default:');
    code.line('  return null;');
  });

  code.dedent();
  code.line('}');
}
