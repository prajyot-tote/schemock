/**
 * Frontend Interceptor Generator
 *
 * Generates interceptor configuration that can be used with createClient().
 * This integrates the middleware chain with the client's onRequest/onError hooks.
 *
 * @module cli/generators/frontend-middleware/interceptor
 * @category CLI
 */

import type {
  SchemockConfig,
  MiddlewareConfig,
  AnalyzedMiddleware,
  AnalyzedSchema,
  AuthMiddlewareConfig,
} from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { hasAnyRLS } from '../shared/rls';

/**
 * Generate the frontend interceptor file
 *
 * This creates an interceptor.ts file that provides a pre-configured
 * onRequest/onError setup that integrates with the middleware chain.
 */
export function generateFrontendInterceptor(
  schemas: AnalyzedSchema[],
  config: SchemockConfig,
  customMiddleware: AnalyzedMiddleware[] = []
): string {
  const code = new CodeBuilder();
  const middleware = config.middleware ?? {};
  const hasRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Frontend interceptor configuration');
  code.line();

  // Generate imports
  generateImports(code, middleware);
  code.line();

  // Generate interceptor config type
  generateInterceptorConfigType(code, middleware);
  code.line();

  // Generate the createInterceptor function
  generateCreateInterceptor(code, middleware, hasRLS);
  code.line();

  // Generate helper functions
  generateHelpers(code, middleware);
  code.line();

  // Generate error handler
  generateErrorHandler(code);
  code.line();

  // Generate pre-configured interceptor export
  generateDefaultInterceptor(code, middleware);

  return code.toString();
}

/**
 * Generate import statements
 */
function generateImports(code: CodeBuilder, middleware: MiddlewareConfig): void {
  code.line("import {");
  code.indent();
  code.line("createMiddlewareChain,");
  code.line("setDefaultHeaders,");
  code.line("getDefaultHeaders,");
  code.line("clearDefaultHeaders,");
  code.line("type FrontendMiddlewareChainConfig,");
  code.line("type FrontendRequestContext,");
  code.dedent();
  code.line("} from './middleware-chain';");
  code.line();
  code.line("import type { MiddlewareContext } from 'schemock/middleware';");
}

/**
 * Generate interceptor config type
 */
function generateInterceptorConfigType(code: CodeBuilder, middleware: MiddlewareConfig): void {
  code.comment('Configuration for creating an interceptor');
  code.block('export interface InterceptorConfig extends FrontendMiddlewareChainConfig {', () => {
    code.comment('Storage for auth token (localStorage key or custom getter)');
    code.line('tokenStorage?: string | (() => string | null | Promise<string | null>);');
    code.line();
    code.comment('Auto-redirect on 401 errors');
    code.line('onUnauthorized?: (error: ApiError) => void;');
    code.line();
    code.comment('Auto-handle 403 errors');
    code.line('onForbidden?: (error: ApiError) => void;');
    code.line();
    code.comment('Global error handler');
    code.line('onError?: (error: ApiError) => void;');
    code.line();
    code.comment('Enable request/response logging');
    code.line('debug?: boolean;');
  });
  code.line();

  code.comment('API Error type');
  code.block('export interface ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line('readonly operation: string;');
    code.line('readonly details?: unknown;');
  });
  code.line();

  code.comment('Request context for interceptor');
  code.block('export interface RequestContext {', () => {
    code.line('headers: Record<string, string>;');
    code.line('operation: string;');
  });
  code.line();

  code.comment('Client configuration');
  code.block('export interface ClientConfig {', () => {
    code.line('onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;');
    code.line('onError?: (error: ApiError) => void | Promise<void>;');
  });
}

/**
 * Generate the createInterceptor function
 */
function generateCreateInterceptor(
  code: CodeBuilder,
  middleware: MiddlewareConfig,
  hasRLS: boolean
): void {
  code.comment('Create an interceptor configuration for use with createClient()');
  code.comment('');
  code.comment('Example usage:');
  code.comment('  const interceptor = createInterceptor({');
  code.comment("    tokenStorage: 'authToken',");
  code.comment("    onUnauthorized: () => window.location.href = '/login',");
  code.comment('  });');
  code.comment('  const api = createClient(interceptor);');
  code.comment('');
  code.block('export function createInterceptor(config: InterceptorConfig = {}): ClientConfig {', () => {
    code.comment('Initialize middleware chain');
    code.line('const middlewareChain = createMiddlewareChain(config);');
    code.line();

    code.comment('Get token from storage');
    code.block('const getToken = async (): Promise<string | null> => {', () => {
      code.comment('If getToken is provided in config, use it');
      code.line('if (config.getToken) {');
      code.indent();
      code.line('return config.getToken();');
      code.dedent();
      code.line('}');
      code.line();
      code.comment('If tokenStorage is a function, call it');
      code.line("if (typeof config.tokenStorage === 'function') {");
      code.indent();
      code.line('return config.tokenStorage();');
      code.dedent();
      code.line('}');
      code.line();
      code.comment('If tokenStorage is a string, treat as localStorage key');
      code.line("if (typeof config.tokenStorage === 'string') {");
      code.indent();
      code.line("if (typeof localStorage !== 'undefined') {");
      code.indent();
      code.line('return localStorage.getItem(config.tokenStorage);');
      code.dedent();
      code.line('}');
      code.dedent();
      code.line('}');
      code.line();
      code.comment('Fall back to default headers');
      code.line("const auth = getDefaultHeaders()['Authorization'];");
      code.line("if (auth) return auth.replace(/^Bearer\\s+/i, '');");
      code.line('return null;');
    });
    code.line();

    code.block('return {', () => {
      // onRequest handler
      code.block('onRequest: async (ctx) => {', () => {
        code.comment('Add auth token if available');
        code.line('const token = await getToken();');
        code.line('if (token && !ctx.headers.Authorization) {');
        code.indent();
        code.line('ctx.headers.Authorization = `Bearer ${token}`;');
        code.dedent();
        code.line('}');
        code.line();

        code.comment('Merge default headers');
        code.line('const defaults = getDefaultHeaders();');
        code.line('ctx.headers = { ...defaults, ...ctx.headers };');
        code.line();

        code.comment('Log if debug mode');
        code.line('if (config.debug) {');
        code.indent();
        code.line("console.log(`[${ctx.operation}] Request`, ctx);");
        code.dedent();
        code.line('}');
        code.line();

        code.line('return ctx;');
      });
      code.line(',');

      // onError handler
      code.block('onError: async (error) => {', () => {
        code.comment('Log if debug mode');
        code.line('if (config.debug) {');
        code.indent();
        code.line("console.error(`[${error.operation}] Error:`, error);");
        code.dedent();
        code.line('}');
        code.line();

        code.comment('Handle 401 Unauthorized');
        code.line('if (error.status === 401 && config.onUnauthorized) {');
        code.indent();
        code.line('config.onUnauthorized(error);');
        code.line('return;');
        code.dedent();
        code.line('}');
        code.line();

        code.comment('Handle 403 Forbidden');
        code.line('if (error.status === 403 && config.onForbidden) {');
        code.indent();
        code.line('config.onForbidden(error);');
        code.line('return;');
        code.dedent();
        code.line('}');
        code.line();

        code.comment('Call global error handler');
        code.line('if (config.onError) {');
        code.indent();
        code.line('config.onError(error);');
        code.dedent();
        code.line('}');
      });
      code.line(',');
    }, '};');
  });
}

/**
 * Generate helper functions
 */
function generateHelpers(code: CodeBuilder, middleware: MiddlewareConfig): void {
  code.comment('Set auth token in default headers');
  code.block('export function setAuthToken(token: string | null): void {', () => {
    code.line('if (token) {');
    code.indent();
    code.line('setDefaultHeaders({');
    code.indent();
    code.line('...getDefaultHeaders(),');
    code.line('Authorization: `Bearer ${token}`,');
    code.dedent();
    code.line('});');
    code.dedent();
    code.line('} else {');
    code.indent();
    code.line('const headers = getDefaultHeaders();');
    code.line('delete headers.Authorization;');
    code.line('setDefaultHeaders(headers);');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Clear auth token from default headers');
  code.block('export function clearAuthToken(): void {', () => {
    code.line('setAuthToken(null);');
  });
  code.line();

  code.comment('Check if user is authenticated (has token in headers)');
  code.block('export function isAuthenticated(): boolean {', () => {
    code.line("return !!getDefaultHeaders()['Authorization'];");
  });
}

/**
 * Generate error handler
 */
function generateErrorHandler(code: CodeBuilder): void {
  code.comment('Create a standard API error');
  code.block('export function createApiError(', () => {
    code.line('message: string,');
    code.line('status: number,');
    code.line('code: string,');
    code.line('operation: string,');
    code.line('details?: unknown');
  });
  code.block('): ApiError {', () => {
    code.line('const error = new Error(message) as ApiError;');
    code.line('(error as any).status = status;');
    code.line('(error as any).code = code;');
    code.line('(error as any).operation = operation;');
    code.line('(error as any).details = details;');
    code.line('return error;');
  });
  code.line();

  code.comment('Error status code mapping');
  code.block('export const errorStatusMap: Record<string, number> = {', () => {
    code.comment('PostgreSQL error codes');
    code.line("'23505': 409, // Unique constraint violation");
    code.line("'23503': 400, // Foreign key violation");
    code.line("'23502': 400, // Not null violation");
    code.line("'23514': 400, // Check constraint violation");
    code.line("'42501': 403, // RLS policy violation");
    code.line("'42P01': 404, // Undefined table");
    code.line("'42703': 400, // Undefined column");
    code.line("'22P02': 400, // Invalid text representation");
    code.line();
    code.comment('Supabase/PostgREST error codes');
    code.line("'PGRST116': 404, // Row not found");
    code.line("'PGRST302': 401, // JWT expired");
    code.line("'PGRST303': 401, // Invalid JWT");
  }, '};');
}

/**
 * Generate pre-configured interceptor export
 */
function generateDefaultInterceptor(code: CodeBuilder, middleware: MiddlewareConfig): void {
  code.comment('Pre-configured interceptor with default settings');
  code.comment('Use createInterceptor() for custom configuration');
  code.line('export const defaultInterceptor = createInterceptor();');
  code.line();

  code.comment('Re-export middleware chain utilities');
  code.line("export { setDefaultHeaders, getDefaultHeaders, clearDefaultHeaders } from './middleware-chain';");
  code.line("export { createMiddlewareChain, middlewareOrder, isMiddlewareEnabled } from './middleware-chain';");
}
