/**
 * Frontend Middleware Chain Generator
 *
 * Generates middleware chain configuration for frontend adapters.
 * Uses the runtime middleware from schemock/middleware.
 *
 * @module cli/generators/frontend-middleware/middleware-chain
 * @category CLI
 */

import type {
  SchemockConfig,
  MiddlewareConfig,
  AnalyzedMiddleware,
  AnalyzedSchema,
  AuthMiddlewareConfig,
  RateLimitMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
} from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { hasAnyRLS } from '../shared/rls';

/**
 * Default middleware execution order for frontend
 */
const DEFAULT_FRONTEND_MIDDLEWARE_ORDER = [
  'auth',
  'logger',
  'context',
  'rls',
  'cache',
];

/**
 * Generate the frontend middleware chain file
 *
 * This creates a middleware-chain.ts file that can be imported by any
 * frontend adapter (mock, supabase, pglite) to configure middleware.
 */
export function generateFrontendMiddlewareChain(
  schemas: AnalyzedSchema[],
  config: SchemockConfig,
  customMiddleware: AnalyzedMiddleware[] = []
): string {
  const code = new CodeBuilder();
  const middleware = config.middleware ?? {};
  const hasRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Frontend middleware chain configuration');
  code.line();

  // Generate imports
  generateImports(code, middleware, hasRLS, customMiddleware);
  code.line();

  // Generate middleware config types
  generateConfigTypes(code);
  code.line();

  // Generate default headers storage
  generateDefaultHeadersStorage(code);
  code.line();

  // Generate middleware creation functions
  generateMiddlewareFactories(code, middleware, hasRLS, schemas);
  code.line();

  // Generate main createMiddlewareChain function
  generateCreateMiddlewareChain(code, middleware, hasRLS, customMiddleware);
  code.line();

  // Generate middleware order export
  generateMiddlewareOrderExport(code, middleware, customMiddleware);

  return code.toString();
}

/**
 * Generate import statements
 */
function generateImports(
  code: CodeBuilder,
  middleware: MiddlewareConfig,
  hasRLS: boolean,
  customMiddleware: AnalyzedMiddleware[]
): void {
  const imports: string[] = ['orderMiddleware'];

  if (middleware.auth) imports.push('createAuthMiddleware');
  if (middleware.logger) imports.push('createLoggerMiddleware');
  if (middleware.context !== false) imports.push('createContextMiddleware');
  if (middleware.rls && hasRLS) imports.push('createRLSMiddleware');
  if (middleware.cache) imports.push('createCacheMiddleware');

  code.line(`import {`);
  code.indent();
  for (const imp of imports) {
    code.line(`${imp},`);
  }
  code.dedent();
  code.line(`} from 'schemock/middleware';`);

  code.line("import type { Middleware, MiddlewareContext } from 'schemock/middleware';");

  // Import custom middleware
  for (const mw of customMiddleware) {
    if (mw.handlerImportPath) {
      const importName = `${mw.name}MiddlewareHandler`;
      code.line(`import { ${mw.handlerName || 'default'} as ${importName} } from '${mw.handlerImportPath}';`);
    }
  }
}

/**
 * Generate config types
 */
function generateConfigTypes(code: CodeBuilder): void {
  code.comment('Frontend middleware chain configuration');
  code.block('export interface FrontendMiddlewareChainConfig {', () => {
    code.comment('Get auth token (e.g., from localStorage, cookies)');
    code.line('getToken?: () => string | null | Promise<string | null>;');
    code.comment('Enable debug logging');
    code.line('debug?: boolean;');
    code.comment('Custom context extractor');
    code.line('extractContext?: (headers: Record<string, string>) => Record<string, unknown>;');
  });
  code.line();

  code.comment('Request context for frontend operations');
  code.block('export interface FrontendRequestContext {', () => {
    code.line('headers: Record<string, string>;');
    code.line('operation: string;');
    code.line('entity?: string;');
    code.line('id?: string;');
    code.line('[key: string]: unknown;');
  });
}

/**
 * Generate default headers storage
 */
function generateDefaultHeadersStorage(code: CodeBuilder): void {
  code.comment('Default headers storage');
  code.line('let defaultHeaders: Record<string, string> = {};');
  code.line();

  code.comment('Set default headers to include in all requests');
  code.block('export function setDefaultHeaders(headers: Record<string, string>): void {', () => {
    code.line('defaultHeaders = headers;');
  });
  code.line();

  code.comment('Get current default headers');
  code.block('export function getDefaultHeaders(): Record<string, string> {', () => {
    code.line('return { ...defaultHeaders };');
  });
  code.line();

  code.comment('Clear default headers');
  code.block('export function clearDefaultHeaders(): void {', () => {
    code.line('defaultHeaders = {};');
  });
}

/**
 * Generate middleware factory functions
 */
function generateMiddlewareFactories(
  code: CodeBuilder,
  middleware: MiddlewareConfig,
  hasRLS: boolean,
  schemas: AnalyzedSchema[]
): void {
  // Auth middleware factory
  if (middleware.auth) {
    const authConfig = normalizeAuthConfig(middleware.auth);
    generateAuthFactory(code, authConfig);
    code.line();
  }

  // Logger middleware factory
  if (middleware.logger) {
    const loggerConfig = normalizeLoggerConfig(middleware.logger);
    generateLoggerFactory(code, loggerConfig);
    code.line();
  }

  // Context middleware factory
  if (middleware.context !== false) {
    generateContextFactory(code);
    code.line();
  }

  // Cache middleware factory
  if (middleware.cache) {
    const cacheConfig = normalizeCacheConfig(middleware.cache);
    generateCacheFactory(code, cacheConfig);
    code.line();
  }

  // RLS middleware factory (if schemas have RLS)
  if (middleware.rls && hasRLS) {
    generateRLSFactory(code, schemas);
    code.line();
  }
}

/**
 * Generate auth middleware factory
 */
function generateAuthFactory(code: CodeBuilder, config: AuthMiddlewareConfig): void {
  code.comment('Create auth middleware with configuration');
  code.block('function createConfiguredAuthMiddleware(chainConfig: FrontendMiddlewareChainConfig): Middleware {', () => {
    code.block('return createAuthMiddleware({', () => {
      code.block('getToken: async () => {', () => {
        code.comment('First check if getToken is provided in chain config');
        code.line('if (chainConfig.getToken) {');
        code.indent();
        code.line('return chainConfig.getToken();');
        code.dedent();
        code.line('}');
        code.line();
        code.comment('Fall back to default headers');
        code.line("const auth = defaultHeaders['Authorization'] || defaultHeaders['authorization'];");
        code.line("if (!auth) return null;");
        code.line("return auth.replace(/^Bearer\\s+/i, '');");
      });
      code.line(',');
      if (config.required === false) {
        code.line('required: false,');
      }
    }, '});');
  });
}

/**
 * Generate logger middleware factory
 */
function generateLoggerFactory(code: CodeBuilder, config: LoggerMiddlewareConfig): void {
  code.comment('Create logger middleware with configuration');
  code.block('function createConfiguredLoggerMiddleware(chainConfig: FrontendMiddlewareChainConfig): Middleware {', () => {
    code.block('return createLoggerMiddleware({', () => {
      code.line("enabled: chainConfig.debug ?? process.env.NODE_ENV !== 'production',");
      if (config.level) {
        code.line(`level: '${config.level}',`);
      }
      if (config.includeBody) {
        code.line('includeBody: true,');
      }
      if (config.includeResponse) {
        code.line('includeResponse: true,');
      }
      if (config.redactFields?.length) {
        code.line(`redactFields: ${JSON.stringify(config.redactFields)},`);
      }
    }, '});');
  });
}

/**
 * Generate context middleware factory
 */
function generateContextFactory(code: CodeBuilder): void {
  code.comment('Create context middleware with configuration');
  code.block('function createConfiguredContextMiddleware(chainConfig: FrontendMiddlewareChainConfig): Middleware {', () => {
    code.block('return createContextMiddleware({', () => {
      code.line('mockMode: true, // Decode JWT without validation in frontend');
      code.line('extractContext: chainConfig.extractContext,');
    }, '});');
  });
}

/**
 * Generate cache middleware factory
 */
function generateCacheFactory(code: CodeBuilder, config: CacheMiddlewareConfig): void {
  code.comment('Create cache middleware with configuration');
  code.block('function createConfiguredCacheMiddleware(_chainConfig: FrontendMiddlewareChainConfig): Middleware {', () => {
    code.block('return createCacheMiddleware({', () => {
      code.line(`ttl: ${config.ttl},`);
      if (config.operations?.length) {
        code.line(`operations: ${JSON.stringify(config.operations)},`);
      }
    }, '});');
  });
}

/**
 * Generate RLS middleware factory
 */
function generateRLSFactory(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.comment('Create RLS middleware with schema configuration');
  code.comment('Note: RLS filters should be imported from the generated rls.ts file');
  code.block('function createConfiguredRLSMiddleware(_chainConfig: FrontendMiddlewareChainConfig): Middleware {', () => {
    code.comment('This will be connected to the RLS filters from the adapter');
    code.comment('The adapter should provide schemas and filters');
    code.block('return createRLSMiddleware({', () => {
      code.line('schemas: new Map(), // Will be set by adapter');
      code.line('getFilters: () => ({}), // Will be set by adapter');
    }, '});');
  });
}

/**
 * Generate the main createMiddlewareChain function
 */
function generateCreateMiddlewareChain(
  code: CodeBuilder,
  middleware: MiddlewareConfig,
  hasRLS: boolean,
  customMiddleware: AnalyzedMiddleware[]
): void {
  code.comment('Create and configure the middleware chain');
  code.comment('');
  code.comment('@param config - Chain configuration (optional)');
  code.comment('@returns Ordered array of middleware');
  code.block('export function createMiddlewareChain(config: FrontendMiddlewareChainConfig = {}): Middleware[] {', () => {
    code.line('const middlewares: Middleware[] = [];');
    code.line();

    // Add middleware in order
    if (middleware.auth) {
      code.comment('Auth middleware');
      code.line('middlewares.push(createConfiguredAuthMiddleware(config));');
      code.line();
    }

    if (middleware.logger) {
      code.comment('Logger middleware');
      code.line('middlewares.push(createConfiguredLoggerMiddleware(config));');
      code.line();
    }

    if (middleware.context !== false) {
      code.comment('Context middleware');
      code.line('middlewares.push(createConfiguredContextMiddleware(config));');
      code.line();
    }

    if (middleware.rls && hasRLS) {
      code.comment('RLS middleware');
      code.line('middlewares.push(createConfiguredRLSMiddleware(config));');
      code.line();
    }

    if (middleware.cache) {
      code.comment('Cache middleware');
      code.line('middlewares.push(createConfiguredCacheMiddleware(config));');
      code.line();
    }

    // Add custom middleware
    for (const mw of customMiddleware) {
      const handlerName = `${mw.name}MiddlewareHandler`;
      code.comment(`Custom middleware: ${mw.name}`);
      code.line(`// TODO: Integrate custom middleware: ${handlerName}`);
      code.line();
    }

    code.line('return orderMiddleware(middlewares);');
  });
}

/**
 * Generate middleware order export
 */
function generateMiddlewareOrderExport(
  code: CodeBuilder,
  middleware: MiddlewareConfig,
  customMiddleware: AnalyzedMiddleware[]
): void {
  const order: string[] = [];

  if (middleware.auth) order.push('auth');
  if (middleware.logger) order.push('logger');
  if (middleware.context !== false) order.push('context');
  if (middleware.rls) order.push('rls');
  if (middleware.cache) order.push('cache');

  // Add custom middleware names
  for (const mw of customMiddleware) {
    order.push(mw.name);
  }

  code.comment('Middleware execution order');
  code.line(`export const middlewareOrder = ${JSON.stringify(order)} as const;`);
  code.line();

  code.comment('Check if a specific middleware is enabled');
  code.block('export function isMiddlewareEnabled(name: string): boolean {', () => {
    code.line('return middlewareOrder.includes(name as typeof middlewareOrder[number]);');
  });
}

/**
 * Normalize auth config (handle boolean shorthand)
 */
function normalizeAuthConfig(config: AuthMiddlewareConfig | boolean): AuthMiddlewareConfig {
  if (config === true) {
    return { provider: 'jwt', required: true };
  }
  if (config === false) {
    // Disabled - return minimal config with required: false
    return { provider: 'jwt', required: false };
  }
  return config;
}

/**
 * Normalize logger config (handle boolean shorthand)
 */
function normalizeLoggerConfig(config: LoggerMiddlewareConfig | boolean): LoggerMiddlewareConfig {
  if (config === true) {
    return { level: 'info' };
  }
  if (config === false) {
    // Disabled - return minimal config (will be skipped in chain)
    return { level: 'error' };
  }
  return config;
}

/**
 * Normalize cache config (handle boolean shorthand)
 */
function normalizeCacheConfig(config: CacheMiddlewareConfig | boolean): CacheMiddlewareConfig {
  if (config === true) {
    return { ttl: 300000, operations: ['findOne', 'findMany'] };
  }
  if (config === false) {
    // Disabled - return minimal config with ttl: 0 (no caching)
    return { ttl: 0, operations: [] };
  }
  return config;
}
