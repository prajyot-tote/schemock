/**
 * PGlite API client generator
 *
 * Generates a TypeScript client with SQL-based CRUD operations,
 * interceptor pattern for auth, and standardized error handling.
 *
 * @module cli/generators/pglite/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import {
  generateRLSContextType,
  generateBypassCheck,
  generateRLSError,
  generateNotFoundError,
  collectBypassConditions,
  hasAnyRLS,
} from '../shared/rls';

/**
 * Generate PGlite API client
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generatePGliteClient(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();
  const schemasWithRLS = hasAnyRLS(schemas);
  const allBypassConditions = collectBypassConditions(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db, initDb, tables, setContext, withContext } from './db';");
  code.line("import type { RLSContext } from './db';");
  code.line("import type * as Types from './types';");
  code.line();

  // Generate interceptor infrastructure (always needed for consistency)
  generateInterceptorTypes(code);

  // Generate error wrapper for PostgreSQL errors
  generatePGliteErrorWrapper(code);

  // Always generate the not found error helper
  generateNotFoundError(code);

  // RLS support
  if (schemasWithRLS) {
    generateRLSError(code);
    generateBypassCheck(code, allBypassConditions);
    code.line();

    // Generate RLS filters for each entity
    const hasGlobalBypass = allBypassConditions.length > 0;
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityRLSFilters(code, schema, hasGlobalBypass);
    }
    code.line();
  }

  // Generate SQL query builder helpers
  generateQueryHelpers(code);
  code.line();

  // Generate the API type
  generateApiType(code, schemas);
  code.line();

  // Generate the createClient factory
  generateCreateClientFactory(code, schemas, schemasWithRLS);
  code.line();

  // Export default unconfigured client for simple usage
  code.multiDocComment([
    'Default API client (no interceptors configured).',
    'For production, use createClient() with interceptors instead.',
    '',
    '@example',
    '```typescript',
    "// Simple usage (no auth)",
    'const posts = await api.post.list();',
    '',
    '// For production with auth, use createClient instead:',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${getToken()}`;',
    '    return ctx;',
    '  }',
    '});',
    '```',
  ]);
  code.line('export const api = createClient();');

  return code.toString();
}

/**
 * Generate interceptor types (RequestContext, ApiError, ClientConfig)
 */
function generateInterceptorTypes(code: CodeBuilder): void {
  code.comment('=============================================================================');
  code.comment('Client Configuration & Error Handling');
  code.comment('');
  code.comment('Production-ready interceptor pattern for centralized auth and error handling.');
  code.comment('Configure once at app startup, auth headers are added to every request.');
  code.comment('=============================================================================');
  code.line();

  code.comment('Request context passed to onRequest interceptor');
  code.block('export interface RequestContext {', () => {
    code.line('headers: Record<string, string>;');
    code.line('operation: string;  // e.g., "post.list", "user.create"');
  }, '}');
  code.line();

  code.comment('API Error with HTTP-like status codes');
  code.block('export class ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line('readonly operation: string;');
    code.line('readonly details?: unknown;');
    code.line();
    code.block('constructor(message: string, status: number, code: string, operation: string, details?: unknown) {', () => {
      code.line('super(message);');
      code.line('this.name = "ApiError";');
      code.line('this.status = status;');
      code.line('this.code = code;');
      code.line('this.operation = operation;');
      code.line('this.details = details;');
    });
  }, '}');
  code.line();

  code.multiDocComment([
    'Client configuration for interceptors.',
    '',
    '@example',
    '```typescript',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("token");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      window.location.href = "/login";',
    '    }',
    '  }',
    '});',
    '```',
  ]);
  code.block('export interface ClientConfig {', () => {
    code.multiDocComment([
      'Called before each API operation.',
      'Use this to add auth headers, logging, etc.',
    ]);
    code.line('onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;');
    code.line();
    code.multiDocComment([
      'Called when an error occurs.',
      'Use this for centralized error handling (401 redirect, toast notifications, etc.)',
    ]);
    code.line('onError?: (error: ApiError) => void | Promise<void>;');
  }, '}');
  code.line();

  code.comment('Decode JWT payload without validation (mock mode trusts the token)');
  code.block('function decodeJwtPayload(token: string): RLSContext | null {', () => {
    code.block('try {', () => {
      code.line('const parts = token.split(".");');
      code.line('if (parts.length !== 3) return null;');
      code.line();
      code.line('const payload = parts[1].replace(/-/g, "+").replace(/_/g, "/");');
      code.line('const decoded = typeof atob === "function"');
      code.line('  ? atob(payload)');
      code.line('  : Buffer.from(payload, "base64").toString("utf-8");');
      code.line();
      code.line('return JSON.parse(decoded);');
    }, '} catch {');
    code.indent();
    code.line('return null;');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Extract RLS context from request headers');
  code.block('function extractContextFromHeaders(headers: Record<string, string>): RLSContext | null {', () => {
    code.line('const authHeader = headers["Authorization"] || headers["authorization"];');
    code.line('if (!authHeader) return null;');
    code.line();
    code.line('const token = authHeader.startsWith("Bearer ")');
    code.line('  ? authHeader.slice(7)');
    code.line('  : authHeader;');
    code.line();
    code.line('return token ? decodeJwtPayload(token) : null;');
  });
  code.line();
}

/**
 * Generate PostgreSQL error wrapper
 */
function generatePGliteErrorWrapper(code: CodeBuilder): void {
  code.comment('Map PostgreSQL error codes to HTTP status codes');
  code.block('function wrapPGliteError(error: unknown, operation: string): ApiError {', () => {
    code.line('const err = error as { code?: string; message?: string; detail?: string };');
    code.line('const pgCode = err.code || "UNKNOWN_ERROR";');
    code.line('const message = err.message || "An unknown error occurred";');
    code.line();
    code.line('let status = 500;');
    code.block('switch (pgCode) {', () => {
      code.comment('Unique violation');
      code.line("case '23505': status = 409; break;");
      code.comment('Foreign key violation');
      code.line("case '23503': status = 400; break;");
      code.comment('Not null violation');
      code.line("case '23502': status = 400; break;");
      code.comment('Check constraint violation');
      code.line("case '23514': status = 400; break;");
      code.comment('RLS violation');
      code.line("case '42501': status = 403; break;");
      code.comment('Undefined table');
      code.line("case '42P01': status = 404; break;");
      code.comment('Undefined column');
      code.line("case '42703': status = 400; break;");
      code.comment('Invalid text representation');
      code.line("case '22P02': status = 400; break;");
    }, '}');
    code.line();
    code.line('return new ApiError(message, status, pgCode, operation, err.detail);');
  });
  code.line();
}

/**
 * Generate the ApiClient type
 */
function generateApiType(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  code.comment('API client type');
  code.block('export interface ApiClient {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const { name, pascalName, relations } = schema;
      const hasRelations = relations.length > 0;
      const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

      code.block(`${name}: {`, () => {
        code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) => Promise<Types.ListResponse<Types.${pascalName}>>;`);
        code.line(`get: (id: string, options?: { include?: ${includeType}[] }) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`create: (input: Types.${pascalName}Create) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`update: (id: string, input: Types.${pascalName}Update) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line('delete: (id: string) => Promise<void>;');
      }, '};');
    }
  }, '}');
}

/**
 * Generate the createClient factory function
 */
function generateCreateClientFactory(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  hasRLS: boolean
): void {
  code.multiDocComment([
    'Create a configured API client with interceptors.',
    '',
    'Use this for production code to centralize auth and error handling.',
    '',
    '@param config - Client configuration with interceptors',
    '@returns Configured API client',
    '',
    '@example',
    '```typescript',
    "import { createClient } from './generated/pglite/client';",
    '',
    'const api = createClient({',
    '  // Add auth headers to every request',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("authToken");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '',
    '  // Centralized error handling',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      window.location.href = "/login";',
    '    }',
    '    if (error.status === 403) {',
    '      toast.error("Access denied");',
    '    }',
    '    if (error.status === 409) {',
    '      toast.error("Duplicate entry");',
    '    }',
    '  }',
    '});',
    '',
    '// Now use the API - auth is automatic',
    'const posts = await api.post.list();',
    '```',
  ]);
  code.block('export function createClient(config?: ClientConfig): ApiClient {', () => {
    code.line('const interceptors = config ?? {};');
    code.line();

    code.comment('Internal helper to run request through interceptors');
    code.block('async function executeRequest<T>(', () => {
      code.line('operation: string,');
      code.line('fn: (ctx: RLSContext | null) => T | Promise<T>');
    }, '): Promise<T> {');
    code.indent();

    code.comment('Build request context');
    code.line('let requestCtx: RequestContext = { headers: {}, operation };');
    code.line();

    code.comment('Run onRequest interceptor (user adds auth headers here)');
    code.block('if (interceptors.onRequest) {', () => {
      code.line('requestCtx = await interceptors.onRequest(requestCtx);');
    });
    code.line();

    code.comment('Extract RLS context from headers');
    code.line('const rlsCtx = extractContextFromHeaders(requestCtx.headers);');
    code.line();

    code.block('try {', () => {
      code.comment('Execute within RLS context transaction');
      code.line('return await withContext(rlsCtx ?? {}, () => fn(rlsCtx));');
    }, '} catch (err) {');
    code.indent();
    code.comment('Wrap error if not already ApiError');
    code.line('const error = err instanceof ApiError ? err : wrapPGliteError(err, operation);');
    code.line();
    code.comment('Run onError interceptor');
    code.block('if (interceptors.onError) {', () => {
      code.line('await interceptors.onError(error);');
    });
    code.line();
    code.line('throw error;');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();

    code.comment('Build API client with all entity methods');
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        generateEntityApiFactory(code, schema, schemas, hasRLS);
      }
    }, '};');
  });
}

/**
 * Generate RLS filter functions for an entity
 */
function generateEntityRLSFilters(code: CodeBuilder, schema: AnalyzedSchema, hasGlobalBypass: boolean): void {
  const { pascalName, rls } = schema;

  if (!rls.enabled) {
    // Generate passthrough functions
    code.comment(`RLS filters for ${pascalName} (disabled)`);
    code.line(`const rls${pascalName}Select = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Insert = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Update = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line(`const rls${pascalName}Delete = (_row: Record<string, unknown>, _ctx: RLSContext | null): boolean => true;`);
    code.line();
    return;
  }

  code.comment(`RLS filters for ${pascalName}`);

  // Map operation to source field
  const sourceFields = {
    Select: rls.selectSource,
    Insert: rls.insertSource,
    Update: rls.updateSource,
    Delete: rls.deleteSource,
  };

  // Generate each operation filter
  for (const op of ['Select', 'Insert', 'Update', 'Delete'] as const) {
    const hasPolicy = rls[`has${op}` as keyof typeof rls];
    const customSource = sourceFields[op];

    code.block(`const rls${pascalName}${op} = (row: Record<string, unknown>, ctx: RLSContext | null): boolean => {`, () => {
      // Check bypass conditions first
      if (hasGlobalBypass) {
        code.line('if (checkBypass(ctx)) return true;');
      }

      if (!hasPolicy) {
        code.line('return true;');
        return;
      }

      // If we have custom source code, embed it directly
      if (customSource) {
        for (const line of customSource.split('\n')) {
          code.line(line.trim());
        }
        return;
      }

      // Fallback: Apply scope mappings
      if (rls.scope.length > 0) {
        for (const mapping of rls.scope) {
          code.line(`// Scope: ${mapping.field} must match context.${mapping.contextKey}`);
          code.line(`if (!ctx || row.${mapping.field} !== ctx.${mapping.contextKey}) return false;`);
        }
      }

      code.line('return true;');
    }, '};');
  }
  code.line();
}

/**
 * Generate SQL query helper functions
 */
function generateQueryHelpers(code: CodeBuilder): void {
  // Filter to SQL WHERE clause builder
  code.comment('Build WHERE clause from filter object');
  code.block(
    'function buildWhere(filter: Record<string, unknown>, params: unknown[], startIndex = 1): { sql: string; nextIndex: number } {',
    () => {
      code.line('const conditions: string[] = [];');
      code.line('let paramIndex = startIndex;');
      code.line();
      code.block('for (const [key, value] of Object.entries(filter)) {', () => {
        code.block('if (typeof value === "object" && value !== null) {', () => {
          code.line('const f = value as Record<string, unknown>;');
          code.line();
          code.block("if ('equals' in f) {", () => {
            code.line('conditions.push(`"${key}" = $${paramIndex++}`);');
            code.line('params.push(f.equals);');
          });
          code.block("if ('not' in f) {", () => {
            code.line('conditions.push(`"${key}" != $${paramIndex++}`);');
            code.line('params.push(f.not);');
          });
          code.block("if ('in' in f) {", () => {
            code.line('const arr = f.in as unknown[];');
            code.line('const placeholders = arr.map(() => `$${paramIndex++}`).join(", ");');
            code.line('conditions.push(`"${key}" IN (${placeholders})`);');
            code.line('params.push(...arr);');
          });
          code.block("if ('notIn' in f) {", () => {
            code.line('const arr = f.notIn as unknown[];');
            code.line('const placeholders = arr.map(() => `$${paramIndex++}`).join(", ");');
            code.line('conditions.push(`"${key}" NOT IN (${placeholders})`);');
            code.line('params.push(...arr);');
          });
          code.block("if ('contains' in f) {", () => {
            code.line('conditions.push(`"${key}" ILIKE $${paramIndex++}`);');
            code.line("params.push(`%${f.contains}%`);");
          });
          code.block("if ('startsWith' in f) {", () => {
            code.line('conditions.push(`"${key}" ILIKE $${paramIndex++}`);');
            code.line("params.push(`${f.startsWith}%`);");
          });
          code.block("if ('endsWith' in f) {", () => {
            code.line('conditions.push(`"${key}" ILIKE $${paramIndex++}`);');
            code.line("params.push(`%${f.endsWith}`);");
          });
          code.block("if ('gt' in f) {", () => {
            code.line('conditions.push(`"${key}" > $${paramIndex++}`);');
            code.line('params.push(f.gt);');
          });
          code.block("if ('lt' in f) {", () => {
            code.line('conditions.push(`"${key}" < $${paramIndex++}`);');
            code.line('params.push(f.lt);');
          });
          code.block("if ('gte' in f) {", () => {
            code.line('conditions.push(`"${key}" >= $${paramIndex++}`);');
            code.line('params.push(f.gte);');
          });
          code.block("if ('lte' in f) {", () => {
            code.line('conditions.push(`"${key}" <= $${paramIndex++}`);');
            code.line('params.push(f.lte);');
          });
          code.block("if ('isNull' in f) {", () => {
            code.line('conditions.push(f.isNull ? `"${key}" IS NULL` : `"${key}" IS NOT NULL`);');
          });
        }, '} else {');
        code.indent();
        code.line('conditions.push(`"${key}" = $${paramIndex++}`);');
        code.line('params.push(value);');
        code.dedent();
        code.line('}');
      });
      code.line();
      code.line("return { sql: conditions.length ? conditions.join(' AND ') : '1=1', nextIndex: paramIndex };");
    }
  );
  code.line();

  // ORDER BY builder
  code.comment('Build ORDER BY clause');
  code.block('function buildOrderBy(orderBy?: Record<string, "asc" | "desc">): string {', () => {
    code.line('if (!orderBy) return "";');
    code.line('const clauses = Object.entries(orderBy).map(([key, dir]) => `"${key}" ${dir.toUpperCase()}`);');
    code.line('return clauses.length ? `ORDER BY ${clauses.join(", ")}` : "";');
  });
  code.line();

  // Parse JSONB fields
  code.comment('Parse JSONB fields in result');
  code.block(
    'function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {',
    () => {
      code.line('const result = { ...row };');
      code.block('for (const field of jsonFields) {', () => {
        code.block('if (result[field] && typeof result[field] === "string") {', () => {
          code.block('try {', () => {
            code.line('result[field] = JSON.parse(result[field] as string);');
          }, '} catch { /* keep as string */ }');
        });
      });
      code.line('return result as T;');
    }
  );
}

/**
 * Generate API methods for a single entity (factory version)
 */
function generateEntityApiFactory(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  hasRLS: boolean
): void {
  const { name, pascalName, tableName, relations, fields, rls } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  // Find JSONB fields for parsing
  const jsonFields = fields.filter((f) => f.isArray || f.isObject).map((f) => f.name);
  const hasJsonFields = jsonFields.length > 0;
  const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');

  code.block(`${name}: {`, () => {
    // LIST
    code.line(
      `list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) =>`
    );
    code.indent();
    code.line(`executeRequest('${name}.list', async (ctx) => {`);
    code.indent();
    code.line('await initDb();');
    code.line('const params: unknown[] = [];');
    code.line('let paramIndex = 1;');
    code.line();

    // Build WHERE clause
    code.line('let whereClause = "1=1";');
    code.block('if (options?.where) {', () => {
      code.line('const { sql, nextIndex } = buildWhere(options.where, params);');
      code.line('whereClause = sql;');
      code.line('paramIndex = nextIndex;');
    });
    code.line();

    // Count query
    code.line(`const countResult = await db.query<{ count: string }>(`);
    code.line(`  \`SELECT COUNT(*) as count FROM "${tableName}" WHERE \${whereClause}\`,`);
    code.line('  params');
    code.line(');');
    code.line('const total = parseInt(countResult.rows[0].count, 10);');
    code.line();

    // Main query
    code.line('const orderBy = buildOrderBy(options?.orderBy);');
    code.line('const limit = options?.limit ?? 20;');
    code.line('const offset = options?.offset ?? 0;');
    code.line();
    code.line(`const result = await db.query<Record<string, unknown>>(`);
    code.line(`  \`SELECT * FROM "${tableName}" WHERE \${whereClause} \${orderBy} LIMIT \${limit} OFFSET \${offset}\`,`);
    code.line('  params');
    code.line(');');
    code.line();

    // Parse JSONB fields
    if (hasJsonFields) {
      code.line(`let items = result.rows.map(row => parseRow<Types.${pascalName}>(row, [${jsonFieldsStr}]));`);
    } else {
      code.line(`let items = result.rows as Types.${pascalName}[];`);
    }
    code.line();

    // Apply RLS filter for select (client-side)
    if (hasRLS && rls.enabled) {
      code.comment('Apply RLS filter');
      code.line(`items = items.filter(item => rls${pascalName}Select(item as unknown as Record<string, unknown>, ctx));`);
      code.line();
    }

    // Load relations
    if (hasRelations) {
      code.block('if (options?.include?.length) {', () => {
        code.block('items = await Promise.all(items.map(async (item) => {', () => {
          code.line('const resultObj = { ...item } as Record<string, unknown>;');
          for (const rel of relations) {
            code.block(`if (options.include!.includes('${rel.name}')) {`, () => {
              generateRelationLoad(code, schema, rel, allSchemas, 'resultObj', 'item');
            });
          }
          code.line(`return resultObj as Types.${pascalName};`);
        }, '}));');
      });
      code.line();
    }

    code.line('return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };');
    code.dedent();
    code.line('}),');
    code.dedent();
    code.line();

    // GET
    code.line(`get: (id: string, options?: { include?: ${includeType}[] }) =>`);
    code.indent();
    code.line(`executeRequest('${name}.get', async (ctx) => {`);
    code.indent();
    code.line('await initDb();');
    code.line();
    code.line(`const result = await db.query<Record<string, unknown>>(`);
    code.line(`  \`SELECT * FROM "${tableName}" WHERE "id" = $1\`,`);
    code.line('  [id]');
    code.line(');');
    code.line();
    code.line(`if (result.rows.length === 0) throw createNotFoundError('${pascalName}', id);`);
    code.line();

    if (hasJsonFields) {
      code.line(`const item = parseRow<Types.${pascalName}>(result.rows[0], [${jsonFieldsStr}]);`);
    } else {
      code.line(`const item = result.rows[0] as Types.${pascalName};`);
    }
    code.line();

    // Apply RLS check for select
    if (hasRLS && rls.enabled) {
      code.comment('Apply RLS check');
      code.block(`if (!rls${pascalName}Select(item as unknown as Record<string, unknown>, ctx)) {`, () => {
        code.line(`throw createRLSError('select', '${pascalName}');`);
      });
      code.line();
    }

    if (hasRelations) {
      code.line('const resultObj = { ...item } as Record<string, unknown>;');
      code.line();
      code.block('if (options?.include?.length) {', () => {
        for (const rel of relations) {
          code.block(`if (options.include.includes('${rel.name}')) {`, () => {
            generateRelationLoad(code, schema, rel, allSchemas, 'resultObj', 'item');
          });
        }
      });
      code.line();
      code.line(`return { data: resultObj as Types.${pascalName} };`);
    } else {
      code.line('return { data: item };');
    }
    code.dedent();
    code.line('}),');
    code.dedent();
    code.line();

    // CREATE
    generateCreateMethodFactory(code, schema, allSchemas, hasJsonFields, jsonFieldsStr, hasRLS);
    code.line();

    // UPDATE
    code.line(`update: (id: string, input: Types.${pascalName}Update) =>`);
    code.indent();
    code.line(`executeRequest('${name}.update', async (ctx) => {`);
    code.indent();
    code.line('await initDb();');
    code.line();

    // Check RLS on existing item first
    if (hasRLS && rls.enabled) {
      code.comment('Check RLS before update');
      code.line(`const existing = await db.query<Record<string, unknown>>(`);
      code.line(`  \`SELECT * FROM "${tableName}" WHERE "id" = $1\`,`);
      code.line('  [id]');
      code.line(');');
      code.line(`if (existing.rows.length === 0) throw createNotFoundError('${pascalName}', id);`);
      code.block(`if (!rls${pascalName}Update(existing.rows[0], ctx)) {`, () => {
        code.line(`throw createRLSError('update', '${pascalName}');`);
      });
      code.line();
    }

    code.line("const data = { ...input, updatedAt: new Date() };");
    code.line('const fields = Object.keys(data);');
    code.line('const values = Object.values(data);');
    code.line();
    code.line('const setClauses = fields.map((f, i) => `"${f}" = $${i + 1}`).join(", ");');
    code.line();
    code.line(`const result = await db.query<Record<string, unknown>>(`);
    code.line(`  \`UPDATE "${tableName}" SET \${setClauses} WHERE "id" = $\${fields.length + 1} RETURNING *\`,`);
    code.line('  [...values, id]');
    code.line(');');
    code.line();
    if (!hasRLS || !rls.enabled) {
      code.line(`if (result.rows.length === 0) throw createNotFoundError('${pascalName}', id);`);
    }

    if (hasJsonFields) {
      code.line(`return { data: parseRow<Types.${pascalName}>(result.rows[0], [${jsonFieldsStr}]) };`);
    } else {
      code.line(`return { data: result.rows[0] as Types.${pascalName} };`);
    }
    code.dedent();
    code.line('}),');
    code.dedent();
    code.line();

    // DELETE
    code.line('delete: (id: string) =>');
    code.indent();
    code.line(`executeRequest('${name}.delete', async (ctx) => {`);
    code.indent();
    code.line('await initDb();');
    code.line();

    // Check RLS on existing item first
    if (hasRLS && rls.enabled) {
      code.comment('Check RLS before delete');
      code.line(`const existing = await db.query<Record<string, unknown>>(`);
      code.line(`  \`SELECT * FROM "${tableName}" WHERE "id" = $1\`,`);
      code.line('  [id]');
      code.line(');');
      code.line(`if (existing.rows.length === 0) throw createNotFoundError('${pascalName}', id);`);
      code.block(`if (!rls${pascalName}Delete(existing.rows[0], ctx)) {`, () => {
        code.line(`throw createRLSError('delete', '${pascalName}');`);
      });
      code.line();
    }

    code.line(`const result = await db.query(`);
    code.line(`  \`DELETE FROM "${tableName}" WHERE "id" = $1 RETURNING "id"\`,`);
    code.line('  [id]');
    code.line(');');
    code.line();
    if (!hasRLS || !rls.enabled) {
      code.line(`if (result.rows.length === 0) throw createNotFoundError('${pascalName}', id);`);
    }
    code.dedent();
    code.line('}),');
    code.dedent();
  }, '},');
  code.line();
}

/**
 * Generate code to load a relation
 */
function generateRelationLoad(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  rel: AnalyzedRelation,
  allSchemas: AnalyzedSchema[],
  resultVar = 'result',
  itemVar = 'item'
): void {
  const targetSchema = allSchemas.find((s) => s.name === rel.target);
  if (!targetSchema) return;

  if (rel.type === 'hasMany') {
    code.line(`const ${rel.name}Result = await db.query(`);
    code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "${rel.foreignKey}" = $1\`,`);
    code.line(`  [${itemVar}.id]`);
    code.line(');');
    code.line(`${resultVar}.${rel.name} = ${rel.name}Result.rows;`);
  } else if (rel.type === 'hasOne') {
    code.line(`const ${rel.name}Result = await db.query(`);
    code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "${rel.foreignKey}" = $1 LIMIT 1\`,`);
    code.line(`  [${itemVar}.id]`);
    code.line(');');
    code.line(`${resultVar}.${rel.name} = ${rel.name}Result.rows[0] ?? null;`);
  } else if (rel.type === 'belongsTo') {
    code.line(`const ${rel.name}Result = await db.query(`);
    code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "id" = $1 LIMIT 1\`,`);
    code.line(`  [(${itemVar} as Record<string, unknown>).${rel.localField}]`);
    code.line(');');
    code.line(`${resultVar}.${rel.name} = ${rel.name}Result.rows[0] ?? null;`);
  } else if (rel.type === 'manyToMany') {
    const throughSchema = allSchemas.find((s) => s.name === rel.through);
    if (throughSchema) {
      code.line(`const junctions = await db.query(`);
      code.line(`  \`SELECT "${rel.otherKey}" FROM "${throughSchema.tableName}" WHERE "${rel.foreignKey}" = $1\`,`);
      code.line(`  [${itemVar}.id]`);
      code.line(');');
      code.line(`const relatedIds = junctions.rows.map(j => (j as Record<string, unknown>).${rel.otherKey});`);
      code.block('if (relatedIds.length > 0) {', () => {
        code.line('const placeholders = relatedIds.map((_, i) => `$${i + 1}`).join(", ");');
        code.line(`const related = await db.query(`);
        code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "id" IN (\${placeholders})\`,`);
        code.line('  relatedIds');
        code.line(');');
        code.line(`${resultVar}.${rel.name} = related.rows;`);
      }, '} else {');
      code.indent();
      code.line(`${resultVar}.${rel.name} = [];`);
      code.dedent();
      code.line('}');
    }
  }
}

/**
 * Generate create method with nested relation support (factory version)
 */
function generateCreateMethodFactory(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  hasJsonFields: boolean,
  jsonFieldsStr: string,
  hasRLS: boolean
): void {
  const { name, pascalName, tableName, relations, fields, rls } = schema;
  const nestedRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');
  const jsonFields = fields.filter((f) => f.isArray || f.isObject).map((f) => f.name);

  code.line(`create: (input: Types.${pascalName}Create) =>`);
  code.indent();
  code.line(`executeRequest('${name}.create', async (ctx) => {`);
  code.indent();
  code.line('await initDb();');
  code.line();

  if (nestedRels.length > 0) {
    const relNames = nestedRels.map((r) => r.name).join(', ');
    code.line(`const { ${relNames}, ...data } = input;`);
  } else {
    code.line('const data = input;');
  }
  code.line();

  // Serialize JSONB fields
  if (jsonFields.length > 0) {
    code.line('const serialized = { ...data } as Record<string, unknown>;');
    for (const jf of jsonFields) {
      code.block(`if (serialized.${jf} !== undefined) {`, () => {
        code.line(`serialized.${jf} = JSON.stringify(serialized.${jf});`);
      });
    }
    code.line();
    code.line('const fields = Object.keys(serialized);');
    code.line('const values = Object.values(serialized);');
  } else {
    code.line('const fields = Object.keys(data);');
    code.line('const values = Object.values(data);');
  }
  code.line();
  code.line('const placeholders = fields.map((_, i) => `$${i + 1}`).join(", ");');
  code.line('const columns = fields.map(f => `"${f}"`).join(", ");');
  code.line();
  code.line(`const result = await db.query<Record<string, unknown>>(`);
  code.line(`  \`INSERT INTO "${tableName}" (\${columns}) VALUES (\${placeholders}) RETURNING *\`,`);
  code.line('  values');
  code.line(');');
  code.line();
  if (hasJsonFields) {
    code.line(`const item = parseRow<Types.${pascalName}>(result.rows[0], [${jsonFieldsStr}]);`);
  } else {
    code.line(`const item = result.rows[0] as Types.${pascalName};`);
  }

  // Check RLS on created item
  if (hasRLS && rls.enabled) {
    code.line();
    code.comment('Check RLS on created item');
    code.block(`if (!rls${pascalName}Insert(item as unknown as Record<string, unknown>, ctx)) {`, () => {
      code.comment('Rollback by deleting');
      code.line(`await db.query(\`DELETE FROM "${tableName}" WHERE "id" = $1\`, [item.id]);`);
      code.line(`throw createRLSError('insert', '${pascalName}');`);
    });
  }

  // Handle nested creates
  if (nestedRels.length > 0) {
    code.line();
    for (const rel of nestedRels) {
      const targetSchema = allSchemas.find((s) => s.name === rel.target);
      if (!targetSchema) continue;

      code.block(`if (${rel.name}) {`, () => {
        if (rel.type === 'hasMany') {
          code.block(`for (const nested of ${rel.name}) {`, () => {
            code.line(`const nestedData = { ...nested, ${rel.foreignKey}: item.id };`);
            code.line('const nestedFields = Object.keys(nestedData);');
            code.line('const nestedValues = Object.values(nestedData);');
            code.line('const nestedPlaceholders = nestedFields.map((_, i) => `$${i + 1}`).join(", ");');
            code.line('const nestedColumns = nestedFields.map(f => `"${f}"`).join(", ");');
            code.line('await db.query(');
            code.line(`  \`INSERT INTO "${targetSchema.tableName}" (\${nestedColumns}) VALUES (\${nestedPlaceholders})\`,`);
            code.line('  nestedValues');
            code.line(');');
          });
        } else {
          code.line(`const nestedData = { ...${rel.name}, ${rel.foreignKey}: item.id };`);
          code.line('const nestedFields = Object.keys(nestedData);');
          code.line('const nestedValues = Object.values(nestedData);');
          code.line('const nestedPlaceholders = nestedFields.map((_, i) => `$${i + 1}`).join(", ");');
          code.line('const nestedColumns = nestedFields.map(f => `"${f}"`).join(", ");');
          code.line('await db.query(');
          code.line(`  \`INSERT INTO "${targetSchema.tableName}" (\${nestedColumns}) VALUES (\${nestedPlaceholders})\`,`);
          code.line('  nestedValues');
          code.line(');');
        }
      });
    }
  }

  code.line();
  code.line('return { data: item };');

  code.dedent();
  code.line('}),');
  code.dedent();
}
