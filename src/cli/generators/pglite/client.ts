/**
 * PGlite API client generator
 *
 * Generates a TypeScript client with SQL-based CRUD operations
 *
 * @module cli/generators/pglite/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate PGlite API client
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generatePGliteClient(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db, initDb, tables } from './db';");
  code.line("import type * as Types from './types';");
  code.line();

  // Generate SQL query builder helpers
  generateQueryHelpers(code);
  code.line();

  // Generate the API object
  code.block('export const api = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityApi(code, schema, schemas);
    }
  }, '};');

  return code.toString();
}

/**
 * Generate SQL query helper functions
 */
function generateQueryHelpers(code: CodeBuilder): void {
  // Filter to SQL WHERE clause builder
  code.comment('Build WHERE clause from filter object');
  code.block(
    'function buildWhere(filter: Record<string, unknown>, params: unknown[], startIndex = 1): { sql: string; nextIndex: number } {',
    () => {
      code.line('const conditions: string[] = [];');
      code.line('let paramIndex = startIndex;');
      code.line();
      code.block('for (const [key, value] of Object.entries(filter)) {', () => {
        code.block('if (typeof value === "object" && value !== null) {', () => {
          code.line('const f = value as Record<string, unknown>;');
          code.line();
          code.block("if ('equals' in f) {", () => {
            code.line('conditions.push(`"${key}" = $${paramIndex++}`);');
            code.line('params.push(f.equals);');
          });
          code.block("if ('not' in f) {", () => {
            code.line('conditions.push(`"${key}" != $${paramIndex++}`);');
            code.line('params.push(f.not);');
          });
          code.block("if ('in' in f) {", () => {
            code.line('const arr = f.in as unknown[];');
            code.line('const placeholders = arr.map(() => `$${paramIndex++}`).join(", ");');
            code.line('conditions.push(`"${key}" IN (${placeholders})`);');
            code.line('params.push(...arr);');
          });
          code.block("if ('notIn' in f) {", () => {
            code.line('const arr = f.notIn as unknown[];');
            code.line('const placeholders = arr.map(() => `$${paramIndex++}`).join(", ");');
            code.line('conditions.push(`"${key}" NOT IN (${placeholders})`);');
            code.line('params.push(...arr);');
          });
          code.block("if ('contains' in f) {", () => {
            code.line('conditions.push(`"${key}" ILIKE $${paramIndex++}`);');
            code.line("params.push(`%${f.contains}%`);");
          });
          code.block("if ('startsWith' in f) {", () => {
            code.line('conditions.push(`"${key}" ILIKE $${paramIndex++}`);');
            code.line("params.push(`${f.startsWith}%`);");
          });
          code.block("if ('endsWith' in f) {", () => {
            code.line('conditions.push(`"${key}" ILIKE $${paramIndex++}`);');
            code.line("params.push(`%${f.endsWith}`);");
          });
          code.block("if ('gt' in f) {", () => {
            code.line('conditions.push(`"${key}" > $${paramIndex++}`);');
            code.line('params.push(f.gt);');
          });
          code.block("if ('lt' in f) {", () => {
            code.line('conditions.push(`"${key}" < $${paramIndex++}`);');
            code.line('params.push(f.lt);');
          });
          code.block("if ('gte' in f) {", () => {
            code.line('conditions.push(`"${key}" >= $${paramIndex++}`);');
            code.line('params.push(f.gte);');
          });
          code.block("if ('lte' in f) {", () => {
            code.line('conditions.push(`"${key}" <= $${paramIndex++}`);');
            code.line('params.push(f.lte);');
          });
          code.block("if ('isNull' in f) {", () => {
            code.line('conditions.push(f.isNull ? `"${key}" IS NULL` : `"${key}" IS NOT NULL`);');
          });
        }, '} else {');
        code.indent();
        code.line('conditions.push(`"${key}" = $${paramIndex++}`);');
        code.line('params.push(value);');
        code.dedent();
        code.line('}');
      });
      code.line();
      code.line("return { sql: conditions.length ? conditions.join(' AND ') : '1=1', nextIndex: paramIndex };");
    }
  );
  code.line();

  // ORDER BY builder
  code.comment('Build ORDER BY clause');
  code.block('function buildOrderBy(orderBy?: Record<string, "asc" | "desc">): string {', () => {
    code.line('if (!orderBy) return "";');
    code.line('const clauses = Object.entries(orderBy).map(([key, dir]) => `"${key}" ${dir.toUpperCase()}`);');
    code.line('return clauses.length ? `ORDER BY ${clauses.join(", ")}` : "";');
  });
  code.line();

  // Parse JSONB fields
  code.comment('Parse JSONB fields in result');
  code.block(
    'function parseRow<T>(row: Record<string, unknown>, jsonFields: string[]): T {',
    () => {
      code.line('const result = { ...row };');
      code.block('for (const field of jsonFields) {', () => {
        code.block('if (result[field] && typeof result[field] === "string") {', () => {
          code.block('try {', () => {
            code.line('result[field] = JSON.parse(result[field] as string);');
          }, '} catch { /* keep as string */ }');
        });
      });
      code.line('return result as T;');
    }
  );
}

/**
 * Generate API methods for a single entity
 */
function generateEntityApi(code: CodeBuilder, schema: AnalyzedSchema, allSchemas: AnalyzedSchema[]): void {
  const { name, pascalName, tableName, relations, fields } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  // Find JSONB fields for parsing
  const jsonFields = fields.filter((f) => f.isArray || f.isObject).map((f) => f.name);

  code.block(`${name}: {`, () => {
    // LIST
    code.block(
      `list: async (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>): Promise<Types.ListResponse<Types.${pascalName}>> => {`,
      () => {
        code.line('await initDb();');
        code.line('const params: unknown[] = [];');
        code.line('let paramIndex = 1;');
        code.line();

        // Build WHERE clause
        code.line('let whereClause = "1=1";');
        code.block('if (options?.where) {', () => {
          code.line('const { sql, nextIndex } = buildWhere(options.where, params);');
          code.line('whereClause = sql;');
          code.line('paramIndex = nextIndex;');
        });
        code.line();

        // Count query
        code.line(`const countResult = await db.query<{ count: string }>(`);
        code.line(`  \`SELECT COUNT(*) as count FROM "${tableName}" WHERE \${whereClause}\`,`);
        code.line('  params');
        code.line(');');
        code.line('const total = parseInt(countResult.rows[0].count, 10);');
        code.line();

        // Main query
        code.line('const orderBy = buildOrderBy(options?.orderBy);');
        code.line('const limit = options?.limit ?? 20;');
        code.line('const offset = options?.offset ?? 0;');
        code.line();
        code.line(`const result = await db.query<Types.${pascalName}>(`);
        code.line(`  \`SELECT * FROM "${tableName}" WHERE \${whereClause} \${orderBy} LIMIT \${limit} OFFSET \${offset}\`,`);
        code.line('  params');
        code.line(');');
        code.line();

        // Parse JSONB fields
        if (jsonFields.length > 0) {
          const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');
          code.line(`let items = result.rows.map(row => parseRow<Types.${pascalName}>(row as Record<string, unknown>, [${jsonFieldsStr}]));`);
        } else {
          code.line('let items = result.rows;');
        }
        code.line();

        // Load relations
        if (hasRelations) {
          code.block('if (options?.include?.length) {', () => {
            code.block('items = await Promise.all(items.map(async (item) => {', () => {
              code.line('const result = { ...item } as Record<string, unknown>;');
              for (const rel of relations) {
                code.block(`if (options.include!.includes('${rel.name}')) {`, () => {
                  generateRelationLoad(code, schema, rel, allSchemas);
                });
              }
              code.line(`return result as Types.${pascalName};`);
            }, '}));');
          });
          code.line();
        }

        code.line('return { data: items, meta: { total, limit, offset, hasMore: offset + limit < total } };');
      },
      '},'
    );
    code.line();

    // GET
    code.block(
      `get: async (id: string, options?: { include?: ${includeType}[] }): Promise<Types.ItemResponse<Types.${pascalName}>> => {`,
      () => {
        code.line('await initDb();');
        code.line();
        code.line(`const result = await db.query<Types.${pascalName}>(`);
        code.line(`  \`SELECT * FROM "${tableName}" WHERE "id" = $1\`,`);
        code.line('  [id]');
        code.line(');');
        code.line();
        code.line(`if (result.rows.length === 0) throw new Error('${pascalName} not found');`);
        code.line();

        if (jsonFields.length > 0) {
          const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');
          code.line(`let item = parseRow<Types.${pascalName}>(result.rows[0] as Record<string, unknown>, [${jsonFieldsStr}]);`);
        } else {
          code.line('let item = result.rows[0];');
        }
        code.line();

        if (hasRelations) {
          code.line('const resultObj = { ...item } as Record<string, unknown>;');
          code.line();
          code.block('if (options?.include?.length) {', () => {
            for (const rel of relations) {
              code.block(`if (options.include.includes('${rel.name}')) {`, () => {
                generateRelationLoad(code, schema, rel, allSchemas, 'resultObj', 'item');
              });
            }
          });
          code.line();
          code.line(`return { data: resultObj as Types.${pascalName} };`);
        } else {
          code.line('return { data: item };');
        }
      },
      '},'
    );
    code.line();

    // CREATE
    generateCreateMethod(code, schema, allSchemas);
    code.line();

    // UPDATE
    code.block(
      `update: async (id: string, input: Types.${pascalName}Update): Promise<Types.ItemResponse<Types.${pascalName}>> => {`,
      () => {
        code.line('await initDb();');
        code.line();
        code.line("const data = { ...input, updatedAt: new Date() };");
        code.line('const fields = Object.keys(data);');
        code.line('const values = Object.values(data);');
        code.line();
        code.line('const setClauses = fields.map((f, i) => `"${f}" = $${i + 1}`).join(", ");');
        code.line();
        code.line(`const result = await db.query<Types.${pascalName}>(`);
        code.line(`  \`UPDATE "${tableName}" SET \${setClauses} WHERE "id" = $\${fields.length + 1} RETURNING *\`,`);
        code.line('  [...values, id]');
        code.line(');');
        code.line();
        code.line(`if (result.rows.length === 0) throw new Error('${pascalName} not found');`);

        if (jsonFields.length > 0) {
          const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');
          code.line(`return { data: parseRow<Types.${pascalName}>(result.rows[0] as Record<string, unknown>, [${jsonFieldsStr}]) };`);
        } else {
          code.line('return { data: result.rows[0] };');
        }
      },
      '},'
    );
    code.line();

    // DELETE
    code.block('delete: async (id: string): Promise<void> => {', () => {
      code.line('await initDb();');
      code.line();
      code.line(`const result = await db.query(`);
      code.line(`  \`DELETE FROM "${tableName}" WHERE "id" = $1 RETURNING "id"\`,`);
      code.line('  [id]');
      code.line(');');
      code.line();
      code.line(`if (result.rows.length === 0) throw new Error('${pascalName} not found');`);
    }, '},');
  }, '},');
  code.line();
}

/**
 * Generate code to load a relation
 */
function generateRelationLoad(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  rel: AnalyzedRelation,
  allSchemas: AnalyzedSchema[],
  resultVar = 'result',
  itemVar = 'item'
): void {
  const targetSchema = allSchemas.find((s) => s.name === rel.target);
  if (!targetSchema) return;

  if (rel.type === 'hasMany') {
    code.line(`const ${rel.name}Result = await db.query(`);
    code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "${rel.foreignKey}" = $1\`,`);
    code.line(`  [${itemVar}.id]`);
    code.line(');');
    code.line(`${resultVar}.${rel.name} = ${rel.name}Result.rows;`);
  } else if (rel.type === 'hasOne') {
    code.line(`const ${rel.name}Result = await db.query(`);
    code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "${rel.foreignKey}" = $1 LIMIT 1\`,`);
    code.line(`  [${itemVar}.id]`);
    code.line(');');
    code.line(`${resultVar}.${rel.name} = ${rel.name}Result.rows[0] ?? null;`);
  } else if (rel.type === 'belongsTo') {
    code.line(`const ${rel.name}Result = await db.query(`);
    code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "id" = $1 LIMIT 1\`,`);
    code.line(`  [(${itemVar} as Record<string, unknown>).${rel.localField}]`);
    code.line(');');
    code.line(`${resultVar}.${rel.name} = ${rel.name}Result.rows[0] ?? null;`);
  } else if (rel.type === 'manyToMany') {
    const throughSchema = allSchemas.find((s) => s.name === rel.through);
    if (throughSchema) {
      // foreignKey is the FK on the junction table pointing to the source entity
      code.line(`const junctions = await db.query(`);
      code.line(`  \`SELECT "${rel.otherKey}" FROM "${throughSchema.tableName}" WHERE "${rel.foreignKey}" = $1\`,`);
      code.line(`  [${itemVar}.id]`);
      code.line(');');
      code.line(`const relatedIds = junctions.rows.map(j => (j as Record<string, unknown>).${rel.otherKey});`);
      code.block('if (relatedIds.length > 0) {', () => {
        code.line('const placeholders = relatedIds.map((_, i) => `$${i + 1}`).join(", ");');
        code.line(`const related = await db.query(`);
        code.line(`  \`SELECT * FROM "${targetSchema.tableName}" WHERE "id" IN (\${placeholders})\`,`);
        code.line('  relatedIds');
        code.line(');');
        code.line(`${resultVar}.${rel.name} = related.rows;`);
      }, '} else {');
      code.indent();
      code.line(`${resultVar}.${rel.name} = [];`);
      code.dedent();
      code.line('}');
    }
  }
}

/**
 * Generate create method with nested relation support
 */
function generateCreateMethod(code: CodeBuilder, schema: AnalyzedSchema, allSchemas: AnalyzedSchema[]): void {
  const { name, pascalName, tableName, relations, fields } = schema;
  const nestedRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');
  const jsonFields = fields.filter((f) => f.isArray || f.isObject).map((f) => f.name);

  code.block(
    `create: async (input: Types.${pascalName}Create): Promise<Types.ItemResponse<Types.${pascalName}>> => {`,
    () => {
      code.line('await initDb();');
      code.line();

      if (nestedRels.length > 0) {
        const relNames = nestedRels.map((r) => r.name).join(', ');
        code.line(`const { ${relNames}, ...data } = input;`);
      } else {
        code.line('const data = input;');
      }
      code.line();

      // Serialize JSONB fields
      if (jsonFields.length > 0) {
        code.line('const serialized = { ...data } as Record<string, unknown>;');
        for (const jf of jsonFields) {
          code.block(`if (serialized.${jf} !== undefined) {`, () => {
            code.line(`serialized.${jf} = JSON.stringify(serialized.${jf});`);
          });
        }
        code.line();
        code.line('const fields = Object.keys(serialized);');
        code.line('const values = Object.values(serialized);');
      } else {
        code.line('const fields = Object.keys(data);');
        code.line('const values = Object.values(data);');
      }
      code.line();
      code.line('const placeholders = fields.map((_, i) => `$${i + 1}`).join(", ");');
      code.line('const columns = fields.map(f => `"${f}"`).join(", ");');
      code.line();
      code.line(`const result = await db.query<Types.${pascalName}>(`);
      code.line(`  \`INSERT INTO "${tableName}" (\${columns}) VALUES (\${placeholders}) RETURNING *\`,`);
      code.line('  values');
      code.line(');');
      code.line();
      if (jsonFields.length > 0) {
        const jsonFieldsStr = jsonFields.map((f) => `'${f}'`).join(', ');
        code.line(`const item = parseRow<Types.${pascalName}>(result.rows[0] as Record<string, unknown>, [${jsonFieldsStr}]);`);
      } else {
        code.line('const item = result.rows[0];');
      }

      // Handle nested creates
      if (nestedRels.length > 0) {
        code.line();
        for (const rel of nestedRels) {
          const targetSchema = allSchemas.find((s) => s.name === rel.target);
          if (!targetSchema) continue;

          code.block(`if (${rel.name}) {`, () => {
            if (rel.type === 'hasMany') {
              code.block(`for (const nested of ${rel.name}) {`, () => {
                code.line(`const nestedData = { ...nested, ${rel.foreignKey}: item.id };`);
                code.line('const nestedFields = Object.keys(nestedData);');
                code.line('const nestedValues = Object.values(nestedData);');
                code.line('const nestedPlaceholders = nestedFields.map((_, i) => `$${i + 1}`).join(", ");');
                code.line('const nestedColumns = nestedFields.map(f => `"${f}"`).join(", ");');
                code.line('await db.query(');
                code.line(`  \`INSERT INTO "${targetSchema.tableName}" (\${nestedColumns}) VALUES (\${nestedPlaceholders})\`,`);
                code.line('  nestedValues');
                code.line(');');
              });
            } else {
              code.line(`const nestedData = { ...${rel.name}, ${rel.foreignKey}: item.id };`);
              code.line('const nestedFields = Object.keys(nestedData);');
              code.line('const nestedValues = Object.values(nestedData);');
              code.line('const nestedPlaceholders = nestedFields.map((_, i) => `$${i + 1}`).join(", ");');
              code.line('const nestedColumns = nestedFields.map(f => `"${f}"`).join(", ");');
              code.line('await db.query(');
              code.line(`  \`INSERT INTO "${targetSchema.tableName}" (\${nestedColumns}) VALUES (\${nestedPlaceholders})\`,`);
              code.line('  nestedValues');
              code.line(');');
            }
          });
        }
      }

      code.line();
      code.line('return { data: item };');
    },
    '},'
  );
}
