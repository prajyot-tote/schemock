/**
 * MSW handlers generator for PGlite adapter
 *
 * Generates MSW request handlers that route through the PGlite API client,
 * ensuring all requests go through the middleware chain (auth, context, RLS).
 *
 * This enables realistic frontend development:
 *   Frontend → HTTP API call → MSW intercepts → PGlite (PostgreSQL) → Response
 *
 * @module cli/generators/pglite/handlers
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedEndpoint, AnalyzedEndpointField } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { pluralize } from '../../utils/pluralize';
import { hasAnyRLS } from '../shared/rls';

/**
 * Generate MSW request handlers for all entities (PGlite version)
 *
 * @param schemas - Analyzed schemas
 * @param apiPrefix - API prefix for endpoints (default: '/api')
 * @returns Generated TypeScript code
 */
export function generatePGliteHandlers(schemas: AnalyzedSchema[], apiPrefix: string = '/api'): string {
  const code = new CodeBuilder();
  const hasRLS = hasAnyRLS(schemas);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { http, HttpResponse } from 'msw';");
  code.line("import { api } from './client';");
  code.line("import { routes } from './routes';");
  code.line("import type * as Types from './types';");
  code.line();

  // Define RLSError locally to avoid bundler issues with symlinked packages
  if (hasRLS) {
    code.comment('RLS error class for access denied responses');
    code.block('class RLSError extends Error {', () => {
      code.line('readonly code = "RLS_DENIED";');
      code.block('constructor(operation: string, entity: string) {', () => {
        code.line('super(`Access denied: ${operation} on ${entity}`);');
        code.line('this.name = "RLSError";');
      });
    });
    code.line();

    code.comment('Handle errors and return appropriate HTTP responses');
    code.block('function handleError(error: unknown): Response {', () => {
      code.block('if (error instanceof RLSError) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 403 });");
      });
      code.block('if (error instanceof Error && error.message.includes("not found")) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 404 });");
      });
      code.comment('Handle PGlite/PostgreSQL errors');
      code.block('if (error instanceof Error) {', () => {
        code.comment('Check for PostgreSQL error codes in the message');
        code.block('if (error.message.includes("23505")) {', () => {
          code.line("return HttpResponse.json({ error: 'Unique constraint violation' }, { status: 409 });");
        });
        code.block('if (error.message.includes("23503")) {', () => {
          code.line("return HttpResponse.json({ error: 'Foreign key constraint violation' }, { status: 400 });");
        });
        code.block('if (error.message.includes("42501")) {', () => {
          code.line("return HttpResponse.json({ error: 'Access denied' }, { status: 403 });");
        });
      });
      code.line('console.error(error);');
      code.line("return HttpResponse.json({ error: 'Internal server error' }, { status: 500 });");
    });
    code.line();
  } else {
    // Even without RLS, we need error handling for PGlite errors
    code.comment('Handle errors and return appropriate HTTP responses');
    code.block('function handleError(error: unknown): Response {', () => {
      code.block('if (error instanceof Error && error.message.includes("not found")) {', () => {
        code.line("return HttpResponse.json({ error: error.message }, { status: 404 });");
      });
      code.comment('Handle PGlite/PostgreSQL errors');
      code.block('if (error instanceof Error) {', () => {
        code.block('if (error.message.includes("23505")) {', () => {
          code.line("return HttpResponse.json({ error: 'Unique constraint violation' }, { status: 409 });");
        });
        code.block('if (error.message.includes("23503")) {', () => {
          code.line("return HttpResponse.json({ error: 'Foreign key constraint violation' }, { status: 400 });");
        });
      });
      code.line('console.error(error);');
      code.line("return HttpResponse.json({ error: 'Internal server error' }, { status: 500 });");
    });
    code.line();
  }

  code.block('export const handlers = [', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateEntityHandlers(code, schema);
    }
  }, '];');

  return code.toString();
}

/**
 * Generate handlers for a single entity
 */
function generateEntityHandlers(code: CodeBuilder, schema: AnalyzedSchema): void {
  const { name, pascalName } = schema;
  const pluralName = pluralize(name);

  code.comment(`${pascalName} handlers`);

  // GET list
  code.block(`http.get(routes.${pluralName}.list.path, async ({ request }) => {`, () => {
    code.line('const url = new URL(request.url);');
    code.line("const limit = parseInt(url.searchParams.get('limit') || '20');");
    code.line("const offset = parseInt(url.searchParams.get('offset') || '0');");
    code.line();
    code.block('try {', () => {
      code.line(`const response = await api.${name}.list({ limit, offset });`);
      code.line('return HttpResponse.json(response);');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();

  // GET single
  code.block(`http.get(routes.${pluralName}.get.path, async ({ params }) => {`, () => {
    code.block('try {', () => {
      code.line(`const response = await api.${name}.get(params.id as string);`);
      code.line('if (!response.data) {');
      code.line(`  return HttpResponse.json({ error: '${pascalName} not found' }, { status: 404 });`);
      code.line('}');
      code.line('return HttpResponse.json(response);');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();

  // POST create
  code.block(`http.post(routes.${pluralName}.create.path, async ({ request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Create;`);
    code.line();
    code.block('try {', () => {
      code.line(`const response = await api.${name}.create(body);`);
      code.line('return HttpResponse.json(response, { status: 201 });');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();

  // PUT update
  code.block(`http.put(routes.${pluralName}.update.path, async ({ params, request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Update;`);
    code.line();
    code.block('try {', () => {
      code.line(`const response = await api.${name}.update(params.id as string, body);`);
      code.line('return HttpResponse.json(response);');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();

  // PATCH update (partial)
  code.block(`http.patch(routes.${pluralName}.patch.path, async ({ params, request }) => {`, () => {
    code.line(`const body = await request.json() as Types.${pascalName}Update;`);
    code.line();
    code.block('try {', () => {
      code.line(`const response = await api.${name}.update(params.id as string, body);`);
      code.line('return HttpResponse.json(response);');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();

  // DELETE
  code.block(`http.delete(routes.${pluralName}.delete.path, async ({ params }) => {`, () => {
    code.block('try {', () => {
      code.line(`await api.${name}.delete(params.id as string);`);
      code.line('return new HttpResponse(null, { status: 204 });');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();
}

/**
 * Generate MSW handlers for custom endpoints (PGlite version)
 *
 * @param endpoints - Analyzed endpoints
 * @returns Generated TypeScript code for MSW handlers
 */
export function generatePGliteEndpointHandlers(endpoints: AnalyzedEndpoint[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('MSW handlers for custom endpoints (PGlite)');
  code.line();

  code.line("import { http, HttpResponse } from 'msw';");
  code.line("import { db, initDb, withContext } from './db';");
  code.line("import type { RLSContext } from './db';");
  code.line("import { endpointResolvers } from './endpoint-resolvers';");
  code.line("import type * as Types from './types';");
  code.line();

  // JWT decoding for RLS context extraction
  code.comment('Decode JWT payload for RLS context');
  code.block('function decodeJwtPayload(token: string): RLSContext | null {', () => {
    code.block('try {', () => {
      code.line('const parts = token.split(".");');
      code.line('if (parts.length !== 3) return null;');
      code.line('const payload = parts[1].replace(/-/g, "+").replace(/_/g, "/");');
      code.line('const decoded = typeof atob === "function"');
      code.line('  ? atob(payload)');
      code.line('  : Buffer.from(payload, "base64").toString("utf-8");');
      code.line('return JSON.parse(decoded);');
    }, '} catch {');
    code.indent();
    code.line('return null;');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Extract RLS context from request headers');
  code.block('function extractContextFromHeaders(request: Request): RLSContext | null {', () => {
    code.line('const authHeader = request.headers.get("Authorization") || request.headers.get("authorization");');
    code.line('if (!authHeader) return null;');
    code.line('const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : authHeader;');
    code.line('return token ? decodeJwtPayload(token) : null;');
  });
  code.line();

  code.comment('Convert Request headers to plain object');
  code.block('function headersToObject(request: Request): Record<string, string> {', () => {
    code.line('const headers: Record<string, string> = {};');
    code.line('request.headers.forEach((value, key) => { headers[key] = value; });');
    code.line('return headers;');
  });
  code.line();

  // Generate error handling infrastructure
  code.comment('Error classes for typed error handling');
  code.block('class ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line();
    code.block('constructor(message: string, status: number, code?: string) {', () => {
      code.line('super(message);');
      code.line('this.name = "ApiError";');
      code.line('this.status = status;');
      code.line('this.code = code ?? "API_ERROR";');
    });
  });
  code.line();

  code.block('class RLSError extends Error {', () => {
    code.block('constructor(message: string = "Access denied") {', () => {
      code.line('super(message);');
      code.line('this.name = "RLSError";');
    });
  });
  code.line();

  code.comment('Centralized error handler for endpoint handlers');
  code.block('function handleError(error: unknown): Response {', () => {
    code.block('if (error instanceof ApiError) {', () => {
      code.line('return HttpResponse.json({ error: error.message, code: error.code }, { status: error.status });');
    });
    code.block('if (error instanceof RLSError) {', () => {
      code.line('return HttpResponse.json({ error: error.message }, { status: 403 });');
    });
    code.block('if (error instanceof Error) {', () => {
      code.block('if (error.message.toLowerCase().includes("not found")) {', () => {
        code.line('return HttpResponse.json({ error: error.message }, { status: 404 });');
      });
      code.comment('Handle PostgreSQL error codes');
      code.block('if (error.message.includes("23505")) {', () => {
        code.line("return HttpResponse.json({ error: 'Unique constraint violation' }, { status: 409 });");
      });
      code.block('if (error.message.includes("23503")) {', () => {
        code.line("return HttpResponse.json({ error: 'Foreign key constraint violation' }, { status: 400 });");
      });
      code.block('if (error.message.includes("42501")) {', () => {
        code.line("return HttpResponse.json({ error: 'Access denied' }, { status: 403 });");
      });
      code.line('console.error("Endpoint error:", error);');
      code.line('return HttpResponse.json({ error: error.message }, { status: 500 });');
    });
    code.line('console.error("Unknown endpoint error:", error);');
    code.line('return HttpResponse.json({ error: "Internal server error" }, { status: 500 });');
  });
  code.line();

  code.block('export const endpointHandlers = [', () => {
    for (const endpoint of endpoints) {
      generateHandler(code, endpoint);
    }
  }, '];');

  return code.toString();
}

/**
 * Generate a single MSW handler for an endpoint
 */
function generateHandler(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { name, pascalName, method, path, params, body, pathParams } = endpoint;
  const httpMethod = method.toLowerCase();
  const hasBody = body.length > 0;
  const hasParams = params.length > 0 || pathParams.length > 0;

  code.comment(`${method} ${path}`);
  code.block(`http.${httpMethod}('${path}', async ({ request, params: pathParams }) => {`, () => {
    // Initialize database
    code.line('await initDb();');
    code.line();

    // Extract RLS context from headers
    code.line('const rlsContext = extractContextFromHeaders(request);');
    code.line('const headers = headersToObject(request);');
    code.line();

    // Parse query parameters for GET
    if (method === 'GET' && params.length > 0) {
      code.line('const url = new URL(request.url);');
      code.block('const params = {', () => {
        for (const param of params) {
          if (pathParams.includes(param.name)) {
            // Path parameter
            code.line(`${param.name}: pathParams.${param.name} as string,`);
          } else {
            // Query parameter
            generateParamParsing(code, param);
          }
        }
      }, '};');
      code.line();
    } else if (pathParams.length > 0) {
      // Only path params, no query params
      code.block('const params = {', () => {
        for (const paramName of pathParams) {
          code.line(`${paramName}: pathParams.${paramName} as string,`);
        }
      }, '};');
      code.line();
    } else {
      // No params - provide empty object for consistent context
      code.line('const params = {};');
      code.line();
    }

    // Parse body for POST/PUT/PATCH, or provide empty object for GET
    if (hasBody) {
      code.line('const body = await request.json();');
    } else {
      code.line('const body = {};');
    }
    code.line();

    // Call resolver with complete context within RLS context
    const paramsArg = hasParams ? `params as Types.${pascalName}Params` : 'params';
    const bodyArg = hasBody ? `body as Types.${pascalName}Body` : 'body';
    code.block('try {', () => {
      code.line(`const result = await withContext(rlsContext ?? {}, async () => {`);
      code.indent();
      code.line(`return endpointResolvers.${name}({`);
      code.line(`  db,`);
      code.line(`  params: ${paramsArg},`);
      code.line(`  body: ${bodyArg},`);
      code.line('  headers,');
      code.line('  rlsContext,');
      code.line('});');
      code.dedent();
      code.line('});');
      code.line('return HttpResponse.json(result);');
    }, '} catch (error) {');
    code.indent();
    code.line('return handleError(error);');
    code.dedent();
    code.line('}');
  }, '}),');
  code.line();
}

/**
 * Generate parameter parsing code
 */
function generateParamParsing(code: CodeBuilder, param: AnalyzedEndpointField): void {
  const { name, tsType, hasDefault } = param;
  const defaultVal = hasDefault ? JSON.stringify(param.default) : 'undefined';

  if (tsType === 'number' || tsType.includes('number')) {
    if (hasDefault) {
      code.line(`${name}: Number(url.searchParams.get('${name}') ?? ${defaultVal}),`);
    } else {
      code.line(`${name}: url.searchParams.has('${name}') ? Number(url.searchParams.get('${name}')) : undefined,`);
    }
  } else if (tsType === 'boolean' || tsType.includes('boolean')) {
    if (hasDefault) {
      code.line(`${name}: url.searchParams.has('${name}') ? url.searchParams.get('${name}') === 'true' : ${defaultVal},`);
    } else {
      code.line(`${name}: url.searchParams.has('${name}') ? url.searchParams.get('${name}') === 'true' : undefined,`);
    }
  } else {
    // String or enum
    if (hasDefault) {
      code.line(`${name}: url.searchParams.get('${name}') ?? ${defaultVal},`);
    } else {
      code.line(`${name}: url.searchParams.get('${name}') ?? undefined,`);
    }
  }
}

/**
 * Generate combined handlers export that includes endpoint handlers if they exist
 *
 * This is the same as the Mock adapter's generateAllHandlersExport - it's adapter-agnostic.
 *
 * @param hasEndpoints - Whether there are custom endpoints defined
 * @returns Generated TypeScript code for all handlers export
 */
export function generatePGliteAllHandlersExport(hasEndpoints: boolean): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Combined handlers for MSW setup (PGlite)');
  code.line();

  code.line("import { handlers } from './handlers';");

  if (hasEndpoints) {
    code.line("import { endpointHandlers } from './endpoint-handlers';");
    code.line();
    code.comment('All handlers: entity CRUD + custom endpoints');
    code.line('export const allHandlers = [...handlers, ...endpointHandlers];');
  } else {
    code.line();
    code.comment('All handlers (no custom endpoints defined)');
    code.line('export const allHandlers = handlers;');
  }

  code.line();
  code.comment('Re-export for convenience');
  code.line('export { handlers };');

  if (hasEndpoints) {
    code.line('export { endpointHandlers };');
  }

  return code.toString();
}
