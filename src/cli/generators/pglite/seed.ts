/**
 * PGlite seed generator
 *
 * Generates seed utilities for the PGlite adapter using raw SQL queries.
 * The db layer has no RLS enforcement, so seed operations naturally bypass RLS.
 *
 * @module cli/generators/pglite/seed
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedField, ProductionSeedConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSafePropertyName } from '../../utils/pluralize';

/**
 * Configuration for seed generation
 */
export interface SeedConfig {
  /** Default seed counts per entity */
  seed?: Record<string, number>;
  /** Faker seed for reproducible data */
  fakerSeed?: number;
  /** Production seed configuration */
  productionSeed?: ProductionSeedConfig;
}

/**
 * Generate seed and reset utilities using raw SQL
 *
 * The generated code uses `db.query()` directly, which bypasses RLS
 * naturally since RLS is only enforced at the api.* layer.
 *
 * @param schemas - Analyzed schemas (topologically sorted)
 * @param config - Seed configuration
 * @returns Generated TypeScript code
 */
export function generatePGliteSeed(schemas: AnalyzedSchema[], config: SeedConfig = {}): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db, initDb } from './db';");
  code.line("import { faker } from '@faker-js/faker';");
  code.line();

  // Set faker seed
  if (config.fakerSeed !== undefined) {
    code.line(`faker.seed(${config.fakerSeed});`);
  } else {
    code.line('faker.seed(Date.now());');
  }
  code.line();

  // Type for seed counts
  code.block('export interface SeedCounts {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      code.line(`${safeName}?: number;`);
    }
  });
  code.line();

  // Default counts
  code.block('const defaultCounts: Required<SeedCounts> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      const count = config.seed?.[schema.name] ?? 10;
      code.line(`${safeName}: ${count},`);
    }
  }, '};');
  code.line();

  // Helper to pick random item from array
  code.block('function pickRandom<T>(arr: T[]): T | undefined {', () => {
    code.line('if (arr.length === 0) return undefined;');
    code.line('return arr[Math.floor(Math.random() * arr.length)];');
  });
  code.line();

  // Helper to escape SQL strings
  code.comment('Escape SQL string values');
  code.block("function escapeSQL(value: unknown): string {", () => {
    code.line('if (value === null || value === undefined) return "NULL";');
    code.line('if (typeof value === "boolean") return value ? "TRUE" : "FALSE";');
    code.line('if (typeof value === "number") return String(value);');
    code.line("if (value instanceof Date) return `'${value.toISOString()}'`;");
    code.line("if (typeof value === \"object\") return `'${JSON.stringify(value).replace(/'/g, \"''\")}\'::jsonb`;");
    code.line("return `'${String(value).replace(/'/g, \"''\")}'`;");
  });
  code.line();

  // Generate entity data generator functions
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityGenerator(code, schema);
    code.line();
  }

  // Seed function - creates relational data with valid foreign keys
  code.multiDocComment([
    'Seed the database with fake data.',
    '',
    'Creates entities in dependency order to ensure valid foreign key references.',
    'Uses raw SQL via the db layer, which naturally bypasses RLS.',
    '',
    '@param counts - Optional count overrides per entity',
    '',
    '@example',
    '```typescript',
    '// Seed with defaults',
    'await seed();',
    '',
    '// Seed with custom counts',
    'await seed({ user: 5, post: 20 });',
    '```',
  ]);
  code.block('export async function seed(counts: SeedCounts = {}): Promise<void> {', () => {
    code.line('await initDb();');
    code.line('const merged = { ...defaultCounts, ...counts };');
    code.line();
    code.comment('Track created entity IDs for foreign key references');
    code.line('const ids: Record<string, string[]> = {};');
    code.line();

    // Generate in dependency order (schemas are already sorted)
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;

      const safeName = toSafePropertyName(schema.name);
      const { tableName } = schema;

      // Find FK fields from belongsTo relations (these need valid parent IDs)
      const belongsToRels = schema.relations.filter((r) => r.type === 'belongsTo');
      const fkFields = belongsToRels.map((r) => ({
        fieldName: r.localField || r.foreignKey,
        target: toSafePropertyName(r.target),
        nullable: schema.fields.find((f) => f.name === (r.localField || r.foreignKey))?.nullable ?? false,
      }));

      // Get non-auto fields for INSERT
      const insertFields = schema.fields.filter(
        (f) => f.name !== 'id' && !f.readOnly
      );
      const columns = insertFields.map((f) => `"${f.name}"`).join(', ');

      code.line(`ids.${safeName} = [];`);
      code.block(`for (let i = 0; i < merged.${safeName}; i++) {`, () => {
        code.line(`const data = generate${schema.pascalName}();`);

        // Set FK values from parent entities
        if (fkFields.length > 0) {
          for (const fk of fkFields) {
            if (fk.nullable) {
              code.line(`data.${fk.fieldName} = Math.random() > 0.3 ? pickRandom(ids.${fk.target}) ?? null : null;`);
            } else {
              code.line(`data.${fk.fieldName} = pickRandom(ids.${fk.target})!;`);
            }
          }
        }

        code.line();
        code.comment('Build INSERT query');
        const valuesPart = insertFields.map((f) => `\${escapeSQL(data.${f.name})}`).join(', ');
        code.line(`const result = await db.query<{ id: string }>(`);
        code.line(`  \`INSERT INTO "${tableName}" (${columns}) VALUES (${valuesPart}) RETURNING "id"\``);
        code.line(');');
        code.line(`ids.${safeName}.push(result.rows[0].id);`);
      });
      code.line();
    }

    code.line("console.log('\\u2713 Database seeded');");
  });
  code.line();

  // Reset function - delete all data
  code.multiDocComment([
    'Reset the database by deleting all data.',
    '',
    'Deletes entities in reverse dependency order to respect foreign key constraints.',
    '',
    '@example',
    '```typescript',
    'await reset();',
    '```',
  ]);
  code.block('export async function reset(): Promise<void> {', () => {
    code.line('await initDb();');
    code.line();

    // Delete in reverse order (dependents first)
    for (const schema of [...schemas].reverse()) {
      if (schema.isJunctionTable) continue;
      code.line(`await db.query(\`DELETE FROM "${schema.tableName}"\`);`);
    }
    code.line();

    code.line("console.log('\\u2713 Database reset');");
  });
  code.line();

  // Get all function (for debugging)
  code.multiDocComment([
    'Get all data from the database.',
    '',
    'Useful for debugging and testing.',
    '',
    '@returns Record of entity name to array of items',
    '',
    '@example',
    '```typescript',
    'const data = await getAll();',
    'console.log(data.user); // All users',
    '```',
  ]);
  code.block('export async function getAll(): Promise<Record<string, unknown[]>> {', () => {
    code.line('await initDb();');
    code.line();
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        const safeName = toSafePropertyName(schema.name);
        code.line(`${safeName}: (await db.query(\`SELECT * FROM "${schema.tableName}"\`)).rows,`);
      }
    }, '};');
  });
  code.line();

  // Count function
  code.multiDocComment([
    'Get the count of each entity in the database.',
    '',
    '@returns Record of entity name to count',
    '',
    '@example',
    '```typescript',
    'const counts = await count();',
    'console.log(counts.user); // Number of users',
    '```',
  ]);
  code.block('export async function count(): Promise<Record<string, number>> {', () => {
    code.line('await initDb();');
    code.line();
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        const safeName = toSafePropertyName(schema.name);
        code.line(`${safeName}: parseInt((await db.query<{ count: string }>(\`SELECT COUNT(*) as count FROM "${schema.tableName}"\`)).rows[0].count, 10),`);
      }
    }, '};');
  });
  code.line();

  // Production seed utilities
  generateProductionSeedUtils(code, schemas, config.productionSeed);

  return code.toString();
}

/**
 * Generate a function that creates fake entity data
 */
function generateEntityGenerator(code: CodeBuilder, schema: AnalyzedSchema): void {
  // Build the return type shape for fields (excluding id and readOnly)
  const fieldTypes: string[] = [];
  for (const field of schema.fields) {
    if (field.name === 'id') continue;
    if (field.readOnly) continue;
    if (field.isRef) {
      fieldTypes.push(`${field.name}: string${field.nullable ? ' | null' : ''}`);
    } else {
      fieldTypes.push(`${field.name}: ${field.tsType}${field.nullable ? ' | null' : ''}`);
    }
  }

  code.block(`function generate${schema.pascalName}(): { ${fieldTypes.join('; ')} } {`, () => {
    code.block('return {', () => {
      for (const field of schema.fields) {
        if (field.name === 'id') continue;
        if (field.readOnly) continue;
        if (field.isRef) {
          if (field.nullable) {
            code.line(`${field.name}: null,`);
          } else {
            code.line(`${field.name}: '',`);
          }
        } else {
          generateFieldValue(code, field);
        }
      }
    }, '};');
  });
}

/**
 * Generate faker call for a field
 */
function generateFieldValue(code: CodeBuilder, field: AnalyzedField): void {
  if (field.nullable) {
    code.line(`${field.name}: Math.random() > 0.1 ? ${field.fakerCall} : null,`);
  } else {
    code.line(`${field.name}: ${field.fakerCall},`);
  }
}

/**
 * Generate production seed utilities with kill switch
 *
 * For PGlite, uses a _schemock_meta table instead of localStorage
 * to store the kill switch state.
 */
function generateProductionSeedUtils(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  productionSeedConfig?: ProductionSeedConfig
): void {
  code.comment('='.repeat(70));
  code.comment('Production Seed Utilities');
  code.comment('='.repeat(70));
  code.line();

  // Import seed config from user's file (conditionally)
  code.comment('Import production seed configuration');
  code.comment('Create a seed-data.ts file in your project root with:');
  code.comment('export const seedConfig = { secret: "your-secret", data: { users: [...], products: [...] } };');
  code.line();

  // SeedResult type
  code.multiDocComment([
    'Result of a production seed operation.',
  ]);
  code.block('export interface SeedResult {', () => {
    code.line('success: boolean;');
    code.line("error?: 'INVALID_SECRET' | 'ALREADY_SEEDED';");
    code.line('seededAt?: Date;');
  });
  code.line();

  // SeedConfig type
  code.multiDocComment([
    'Configuration for production seed data.',
    '',
    'Define this in your seed-data.ts file:',
    '```typescript',
    "export const seedConfig = {",
    "  secret: 'my-production-secret-123',",
    "  data: {",
    "    users: [{ id: 'admin-uuid', name: 'Super Admin', email: 'admin@example.com' }],",
    "    products: [{ id: 'prod-1', name: 'Default Product', price: 9.99 }],",
    "  },",
    "};",
    '```',
  ]);
  code.block('export interface ProductionSeedData {', () => {
    code.line('secret: string;');
    code.line('data: Record<string, Record<string, unknown>[]>;');
  });
  code.line();

  // Table-to-entity mapping
  code.comment('Table name to entity name mapping for production seed');
  code.block('const tableNameMap: Record<string, string> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      code.line(`${schema.name}: '${schema.tableName}',`);
    }
  }, '};');
  code.line();

  // Ensure meta table exists
  code.comment('Ensure _schemock_meta table exists');
  code.block('async function ensureMetaTable(): Promise<void> {', () => {
    code.line('await initDb();');
    code.line('await db.query(`');
    code.raw('    CREATE TABLE IF NOT EXISTS "_schemock_meta" (');
    code.raw('      "key" TEXT PRIMARY KEY,');
    code.raw('      "value" TEXT NOT NULL,');
    code.raw('      "created_at" TIMESTAMPTZ DEFAULT NOW()');
    code.raw('    )');
    code.line('`);');
  });
  code.line();

  // isSeeded function
  code.multiDocComment([
    'Check if production data has already been seeded.',
    '',
    '@returns true if production seed has already run',
    '',
    '@example',
    '```typescript',
    'if (!(await isSeeded())) {',
    "  await runProductionSeed('my-secret');",
    '}',
    '```',
  ]);
  code.block('export async function isSeeded(): Promise<boolean> {', () => {
    code.line('await ensureMetaTable();');
    code.line("const result = await db.query<{ value: string }>(`");
    code.raw('    SELECT "value" FROM "_schemock_meta" WHERE "key" = \'seeded_at\'');
    code.line('`);');
    code.line('return result.rows.length > 0;');
  });
  code.line();

  // resetProductionSeed function
  code.multiDocComment([
    'Reset the production seed kill switch.',
    '',
    'Call this if you need to re-seed production data.',
    '',
    '@example',
    '```typescript',
    'await resetProductionSeed();',
    "await runProductionSeed('my-secret');",
    '```',
  ]);
  code.block('export async function resetProductionSeed(): Promise<void> {', () => {
    code.line('await ensureMetaTable();');
    code.line("await db.query(`DELETE FROM \"_schemock_meta\" WHERE \"key\" = 'seeded_at'`);");
  });
  code.line();

  // getSeededAt function
  code.multiDocComment([
    'Get the timestamp when production data was seeded.',
    '',
    '@returns Date when seeded, or null if not seeded',
  ]);
  code.block('export async function getSeededAt(): Promise<Date | null> {', () => {
    code.line('await ensureMetaTable();');
    code.line("const result = await db.query<{ value: string }>(`");
    code.raw('    SELECT "value" FROM "_schemock_meta" WHERE "key" = \'seeded_at\'');
    code.line('`);');
    code.line('if (result.rows.length === 0) return null;');
    code.line('return new Date(parseInt(result.rows[0].value, 10));');
  });
  code.line();

  // runProductionSeed function
  code.multiDocComment([
    'Run the production seed with secret validation and kill switch.',
    '',
    'This function:',
    '1. Validates the provided secret against seedConfig.secret',
    '2. Checks if data has already been seeded (kill switch)',
    '3. Inserts the seed data into the database',
    '4. Sets the kill switch to prevent re-seeding',
    '',
    '@param secretKey - The secret key to validate against seedConfig.secret',
    '@param seedConfig - The seed configuration with secret and data',
    '@returns SeedResult indicating success or failure',
    '',
    '@example',
    '```typescript',
    '// First, import your seed config',
    "import { seedConfig } from './seed-data';",
    '',
    '// Run the seed',
    "const result = await runProductionSeed('my-secret', seedConfig);",
    '',
    'if (result.success) {',
    '  console.log("Seeded at:", result.seededAt);',
    '} else if (result.error === "ALREADY_SEEDED") {',
    '  console.log("Already seeded at:", result.seededAt);',
    '} else if (result.error === "INVALID_SECRET") {',
    '  console.error("Invalid secret key");',
    '}',
    '```',
  ]);
  code.line('export async function runProductionSeed(');
  code.line('  secretKey: string,');
  code.line('  seedConfig: ProductionSeedData');
  code.line('): Promise<SeedResult> {');
  code.indent();

  // Step 1: Validate secret
  code.comment('1. Validate secret');
  code.block('if (secretKey !== seedConfig.secret) {', () => {
    code.line("return { success: false, error: 'INVALID_SECRET' };");
  });
  code.line();

  // Step 2: Check kill switch
  code.comment('2. Check kill switch');
  code.block('if (await isSeeded()) {', () => {
    code.line('return {');
    code.line('  success: false,');
    code.line("  error: 'ALREADY_SEEDED',");
    code.line('  seededAt: (await getSeededAt()) ?? undefined,');
    code.line('};');
  });
  code.line();

  // Step 3: Insert data
  code.comment('3. Insert data for each entity');
  code.block('for (const [entity, items] of Object.entries(seedConfig.data)) {', () => {
    code.line('const tableName = tableNameMap[entity];');
    code.block('if (!tableName) {', () => {
      code.line('console.warn(`Unknown entity in seed data: ${entity}`);');
      code.line('continue;');
    });
    code.line();
    code.block('for (const item of items) {', () => {
      code.comment('Build column names and values');
      code.line('const columns = Object.keys(item).map(k => `"${k}"`).join(", ");');
      code.line('const values = Object.values(item).map(v => escapeSQL(v)).join(", ");');
      code.line();
      code.block('try {', () => {
        code.line('await db.query(`INSERT INTO "${tableName}" (${columns}) VALUES (${values})`);');
      }, '} catch (e) {');
      code.indent();
      code.comment('Ignore duplicate key errors, log others');
      code.line('const error = e as Error;');
      code.line("if (!error.message?.includes('duplicate') && !error.message?.includes('23505')) {");
      code.line('  console.warn(`Failed to seed ${entity}:`, error.message);');
      code.line('}');
      code.dedent();
      code.line('}');
    });
  });
  code.line();

  // Step 4: Set kill switch
  code.comment('4. Set kill switch in database');
  code.line('const seededAt = new Date();');
  code.line("await db.query(`");
  code.raw('    INSERT INTO "_schemock_meta" ("key", "value") VALUES (\'seeded_at\', \'${seededAt.getTime()}\')');
  code.raw('    ON CONFLICT ("key") DO UPDATE SET "value" = \'${seededAt.getTime()}\'');
  code.line('`);');
  code.line();

  code.line("console.log('\\u2713 Production data seeded');");
  code.line('return { success: true, seededAt };');
  code.dedent();
  code.line('}');
}
