/**
 * PGlite seed utilities generator
 *
 * Generates seed data and utility functions for PGlite database
 *
 * @module cli/generators/pglite/seed
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedField, PGliteAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate seed and utility functions for PGlite database
 *
 * @param schemas - Analyzed schemas
 * @param config - PGlite adapter configuration
 * @returns Generated TypeScript code
 */
export function generatePGliteSeed(schemas: AnalyzedSchema[], config: PGliteAdapterConfig): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { db, initDb, resetDb, tables } from './db';");
  code.line("import { faker } from '@faker-js/faker';");
  code.line();

  // Set faker seed
  if (config.fakerSeed !== undefined) {
    code.line(`faker.seed(${config.fakerSeed});`);
  } else {
    code.line('faker.seed(Date.now());');
  }
  code.line();

  // Type for seed counts
  code.block('export interface SeedCounts {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      code.line(`${schema.name}?: number;`);
    }
  });
  code.line();

  // Default counts
  code.block('const defaultCounts: Required<SeedCounts> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const count = config.seed?.[schema.name] ?? 10;
      code.line(`${schema.name}: ${count},`);
    }
  }, '};');
  code.line();

  // Helper to pick random item from array
  code.block('function pickRandom<T>(arr: T[]): T | undefined {', () => {
    code.line('if (arr.length === 0) return undefined;');
    code.line('return arr[Math.floor(Math.random() * arr.length)];');
  });
  code.line();

  // Generate entity data function
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityGenerator(code, schema);
    code.line();
  }

  // Seed function
  code.block('export async function seed(counts: SeedCounts = {}): Promise<void> {', () => {
    code.line('await initDb();');
    code.line('const merged = { ...defaultCounts, ...counts };');
    code.line();
    code.comment('Track created entity IDs for foreign key references');
    code.line('const ids: Record<string, string[]> = {};');
    code.line();

    // Generate in dependency order
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;

      const belongsToRels = schema.relations.filter((r) => r.type === 'belongsTo');

      code.line(`ids.${schema.name} = [];`);
      code.block(`for (let i = 0; i < merged.${schema.name}; i++) {`, () => {
        // Generate data
        if (belongsToRels.length > 0) {
          code.line(`const data = generate${schema.pascalName}();`);
          // Set FK values from parent entities
          for (const rel of belongsToRels) {
            const localField = rel.localField || rel.foreignKey;
            const field = schema.fields.find((f) => f.name === localField);
            if (field?.nullable) {
              code.line(`data.${localField} = Math.random() > 0.3 ? pickRandom(ids.${rel.target}) ?? null : null;`);
            } else {
              // Non-nullable FK: use non-null assertion (parent entities must exist)
              code.line(`data.${localField} = pickRandom(ids.${rel.target})!;`);
            }
          }
        } else {
          code.line(`const data = generate${schema.pascalName}();`);
        }
        code.line();

        // Build INSERT query
        code.line('const fields = Object.keys(data).filter(k => data[k as keyof typeof data] !== undefined);');
        code.line('const values = fields.map(k => data[k as keyof typeof data]);');
        code.line('const placeholders = fields.map((_, i) => `$${i + 1}`).join(", ");');
        code.line('const columns = fields.map(f => `"${f}"`).join(", ");');
        code.line();
        code.line(`const result = await db.query<{ id: string }>(`);
        code.line(`  \`INSERT INTO "${schema.tableName}" (\${columns}) VALUES (\${placeholders}) RETURNING "id"\`,`);
        code.line('  values');
        code.line(');');
        code.line(`ids.${schema.name}.push(result.rows[0].id);`);
      });
      code.line();
    }

    code.line("console.log('✓ Database seeded');");
  });
  code.line();

  // Reset function
  code.block('export async function reset(): Promise<void> {', () => {
    code.line('await resetDb();');
    code.line("console.log('✓ Database reset');");
  });
  code.line();

  // Get all function (for debugging)
  code.block('export async function getAll(): Promise<Record<string, unknown[]>> {', () => {
    code.line('await initDb();');
    code.block('return {', () => {
      for (const schema of schemas) {
        code.line(`${schema.name}: (await db.query(\`SELECT * FROM "${schema.tableName}"\`)).rows,`);
      }
    }, '};');
  });
  code.line();

  // Count function
  code.block('export async function count(): Promise<Record<string, number>> {', () => {
    code.line('await initDb();');
    code.block('return {', () => {
      for (const schema of schemas) {
        code.line(
          `${schema.name}: parseInt((await db.query<{ count: string }>(\`SELECT COUNT(*) as count FROM "${schema.tableName}"\`)).rows[0].count, 10),`
        );
      }
    }, '};');
  });

  return code.toString();
}

/**
 * Generate a function that creates fake entity data
 */
function generateEntityGenerator(code: CodeBuilder, schema: AnalyzedSchema): void {
  // Build the return type shape for fields
  const fieldTypes: string[] = [];
  for (const field of schema.fields) {
    if (field.name === 'id') continue; // UUID auto-generated by DB
    if (field.isRef) {
      // FK fields - respect nullable property
      fieldTypes.push(`${field.name}: string${field.nullable ? ' | null' : ''}`);
    } else {
      fieldTypes.push(`${field.name}: ${field.tsType}${field.nullable ? ' | null' : ''}`);
    }
  }

  code.block(`function generate${schema.pascalName}(): { ${fieldTypes.join('; ')} } {`, () => {
    code.block('return {', () => {
      for (const field of schema.fields) {
        if (field.name === 'id') continue; // UUID auto-generated by DB
        if (field.isRef) {
          // FK fields - placeholder, will be set by seed function
          if (field.nullable) {
            code.line(`${field.name}: null,`);
          } else {
            // Non-nullable FK: use empty string as placeholder (will be overwritten)
            code.line(`${field.name}: '',`);
          }
        } else {
          generateFieldValue(code, field);
        }
      }
    }, '};');
  });
}

/**
 * Generate faker call for a field
 */
function generateFieldValue(code: CodeBuilder, field: AnalyzedField): void {
  // Handle nullable fields
  if (field.nullable) {
    code.line(`${field.name}: Math.random() > 0.1 ? ${field.fakerCall} : null,`);
  } else {
    code.line(`${field.name}: ${field.fakerCall},`);
  }
}
