/**
 * Unified API Client Generator
 *
 * Generates a pure fetch()-based API client that works identically
 * with both MSW handlers (mock) and real backends (production).
 *
 * Key features:
 * - NO db imports - all operations go through HTTP
 * - Interceptors for auth headers and error handling
 * - Unified client for entity CRUD + custom endpoints
 * - Configurable baseUrl
 * - Same code works for mock AND production
 *
 * @module cli/generators/unified/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedEndpoint, SchemockConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Configuration for unified client generation
 */
export interface UnifiedClientConfig {
  /** API prefix for routes (default: '/api') */
  apiPrefix?: string;
  /** Whether to include custom endpoints */
  includeEndpoints?: boolean;
}

/**
 * Generate unified API client (fetch-only)
 *
 * @param schemas - Analyzed schemas
 * @param endpoints - Analyzed endpoints (optional)
 * @param config - Generation configuration
 * @returns Generated TypeScript code
 */
export function generateUnifiedClient(
  schemas: AnalyzedSchema[],
  endpoints: AnalyzedEndpoint[] = [],
  config: UnifiedClientConfig = {}
): string {
  const code = new CodeBuilder();
  const apiPrefix = config.apiPrefix ?? '/api';
  const hasEndpoints = endpoints.length > 0;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import type * as Types from './types';");
  code.line();

  // Generate infrastructure
  generateApiError(code);
  generateRequestContext(code);
  generateClientConfig(code);
  generateQueryHelper(code);

  // Generate API type interface
  generateApiType(code, schemas, endpoints);

  // Generate createClient factory
  generateCreateClientFactory(code, schemas, endpoints, apiPrefix);

  // Export default client
  code.multiDocComment([
    'Default API client (no interceptors configured).',
    'For production, use createClient() with interceptors instead.',
    '',
    '@example',
    '```typescript',
    '// Simple usage (no auth)',
    'const posts = await api.post.list();',
    '',
    '// For production with auth, use createClient instead:',
    'const api = createClient({',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${getToken()}`;',
    '    return ctx;',
    '  }',
    '});',
    '```',
  ]);
  code.line('export const api = createClient();');

  return code.toString();
}

/**
 * Generate ApiError class
 */
function generateApiError(code: CodeBuilder): void {
  code.multiDocComment([
    'API Error class with status code and error code',
    '',
    '@example',
    '```typescript',
    'try {',
    '  await api.user.get(id);',
    '} catch (err) {',
    '  if (err instanceof ApiError && err.status === 404) {',
    '    // Handle not found',
    '  }',
    '}',
    '```',
  ]);
  code.block('export class ApiError extends Error {', () => {
    code.line('readonly status: number;');
    code.line('readonly code: string;');
    code.line('readonly operation?: string;');
    code.line('readonly details?: Record<string, unknown>;');
    code.line();
    code.block('constructor(', () => {
      code.line('message: string,');
      code.line('status: number,');
      code.line("code: string = 'API_ERROR',");
      code.line('operation?: string,');
      code.line('details?: Record<string, unknown>');
    }, ') {');
    code.indent();
    code.line('super(message);');
    code.line("this.name = 'ApiError';");
    code.line('this.status = status;');
    code.line('this.code = code;');
    code.line('this.operation = operation;');
    code.line('this.details = details;');
    code.dedent();
    code.line('}');
  });
  code.line();
}

/**
 * Generate RequestContext type
 */
function generateRequestContext(code: CodeBuilder): void {
  code.multiDocComment([
    'Request context passed to onRequest interceptor',
    'Modify headers here to add authentication',
  ]);
  code.block('export interface RequestContext {', () => {
    code.line('/** HTTP method */');
    code.line('method: string;');
    code.line('/** Request path */');
    code.line('path: string;');
    code.line('/** Request headers (mutable) */');
    code.line('headers: Record<string, string>;');
    code.line('/** Request body (if any) */');
    code.line('body?: unknown;');
    code.line('/** Operation name (e.g., "user.list", "user.create") */');
    code.line('operation: string;');
  });
  code.line();
}

/**
 * Generate ClientConfig type
 */
function generateClientConfig(code: CodeBuilder): void {
  code.multiDocComment([
    'Client configuration with interceptors',
    '',
    '@example',
    '```typescript',
    'const api = createClient({',
    '  baseUrl: "https://api.example.com",',
    '  onRequest: (ctx) => {',
    '    ctx.headers.Authorization = `Bearer ${token}`;',
    '    return ctx;',
    '  },',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      // Handle unauthorized',
    '    }',
    '  }',
    '});',
    '```',
  ]);
  code.block('export interface ClientConfig {', () => {
    code.line('/** Base URL for API requests */');
    code.line('baseUrl?: string;');
    code.line('/** Interceptor called before each request - use to add auth headers */');
    code.line('onRequest?: (ctx: RequestContext) => RequestContext | Promise<RequestContext>;');
    code.line('/** Error handler called when requests fail */');
    code.line('onError?: (error: ApiError) => void | Promise<void>;');
  });
  code.line();
}

/**
 * Generate query string builder helper
 */
function generateQueryHelper(code: CodeBuilder): void {
  code.comment('Build query string from options object');
  code.block('function buildQuery(options?: Record<string, unknown>): string {', () => {
    code.line("if (!options) return '';");
    code.line('const params = new URLSearchParams();');
    code.block('for (const [key, value] of Object.entries(options)) {', () => {
      code.block('if (value !== undefined && value !== null) {', () => {
        code.line("params.set(key, typeof value === 'object' ? JSON.stringify(value) : String(value));");
      });
    });
    code.line('const str = params.toString();');
    code.line("return str ? `?${str}` : '';");
  });
  code.line();
}

/**
 * Generate the ApiClient type interface
 */
function generateApiType(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  endpoints: AnalyzedEndpoint[]
): void {
  code.comment('API client type interface');
  code.block('export interface ApiClient {', () => {
    // Entity CRUD operations
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const { name, pascalName, relations } = schema;
      const hasRelations = relations.length > 0;
      const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

      code.block(`${name}: {`, () => {
        code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) => Promise<Types.ListResponse<Types.${pascalName}>>;`);
        code.line(`get: (id: string, options?: { include?: ${includeType}[] }) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`create: (input: Types.${pascalName}Create) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line(`update: (id: string, input: Types.${pascalName}Update) => Promise<Types.ItemResponse<Types.${pascalName}>>;`);
        code.line('delete: (id: string) => Promise<void>;');
      }, '};');
    }

    // Custom endpoints
    if (endpoints.length > 0) {
      code.line();
      code.comment('Custom endpoints');
      for (const endpoint of endpoints) {
        const hasParams = endpoint.params && endpoint.params.length > 0;
        const hasBody = endpoint.body && endpoint.body.length > 0;
        const paramType = hasParams ? `Types.${endpoint.pascalName}Params` : 'void';
        const bodyType = hasBody ? `Types.${endpoint.pascalName}Body` : 'void';
        const responseType = `Types.${endpoint.pascalName}Response`;

        if (hasBody && hasParams) {
          code.line(`${endpoint.name}: (params: ${paramType}, body: ${bodyType}) => Promise<${responseType}>;`);
        } else if (hasBody) {
          code.line(`${endpoint.name}: (body: ${bodyType}) => Promise<${responseType}>;`);
        } else if (hasParams) {
          code.line(`${endpoint.name}: (params: ${paramType}) => Promise<${responseType}>;`);
        } else {
          code.line(`${endpoint.name}: () => Promise<${responseType}>;`);
        }
      }
    }
  });
  code.line();
}

/**
 * Generate the createClient factory function
 */
function generateCreateClientFactory(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  endpoints: AnalyzedEndpoint[],
  apiPrefix: string
): void {
  code.multiDocComment([
    'Create a configured API client with interceptors.',
    '',
    'Use this for production code to centralize auth and error handling.',
    '',
    '@param config - Client configuration with interceptors',
    '@returns Configured API client',
    '',
    '@example',
    '```typescript',
    "import { createClient } from './generated/client';",
    '',
    'const api = createClient({',
    '  baseUrl: "https://api.example.com",',
    '',
    '  // Add auth headers to every request',
    '  onRequest: (ctx) => {',
    '    const token = localStorage.getItem("authToken");',
    '    if (token) {',
    '      ctx.headers.Authorization = `Bearer ${token}`;',
    '    }',
    '    return ctx;',
    '  },',
    '',
    '  // Centralized error handling',
    '  onError: (error) => {',
    '    if (error.status === 401) {',
    '      window.location.href = "/login";',
    '    }',
    '    if (error.status === 403) {',
    '      toast.error("Access denied");',
    '    }',
    '  }',
    '});',
    '',
    '// Now use the API - auth is automatic',
    'const posts = await api.post.list();',
    '```',
  ]);
  code.block('export function createClient(config?: ClientConfig): ApiClient {', () => {
    code.line('const baseUrl = config?.baseUrl ?? "";');
    code.line();

    // Generate the internal request function
    code.comment('Internal helper to make HTTP requests through interceptors');
    code.block('async function request<T>(', () => {
      code.line('method: string,');
      code.line('path: string,');
      code.line('operation: string,');
      code.line('options?: { query?: Record<string, unknown>; body?: unknown }');
    }, '): Promise<T> {');
    code.indent();

    code.comment('Build request context');
    code.line('let ctx: RequestContext = {');
    code.line('  method,');
    code.line('  path,');
    code.line('  headers: {},');
    code.line('  body: options?.body,');
    code.line('  operation,');
    code.line('};');
    code.line();

    code.comment('Run onRequest interceptor (user adds auth headers here)');
    code.block('if (config?.onRequest) {', () => {
      code.line('ctx = await config.onRequest(ctx);');
    });
    code.line();

    code.comment('Build URL');
    code.line('let url = `${baseUrl}${path}`;');
    code.block('if (options?.query) {', () => {
      code.line('url += buildQuery(options.query);');
    });
    code.line();

    code.block('try {', () => {
      code.comment('Make the fetch request');
      code.line('const response = await fetch(url, {');
      code.line('  method,');
      code.line("  headers: { 'Content-Type': 'application/json', ...ctx.headers },");
      code.line('  body: ctx.body ? JSON.stringify(ctx.body) : undefined,');
      code.line('});');
      code.line();

      code.comment('Handle error responses');
      code.block('if (!response.ok) {', () => {
        code.line('let errorBody: Record<string, unknown> = {};');
        code.block('try {', () => {
          code.line('errorBody = await response.json();');
        }, '} catch { /* ignore parse errors */ }');
        code.line();
        code.line('const error = new ApiError(');
        code.line("  (errorBody.message as string) || (errorBody.error as string) || `HTTP ${response.status}`,");
        code.line('  response.status,');
        code.line("  (errorBody.code as string) || 'HTTP_ERROR',");
        code.line('  operation,');
        code.line('  errorBody');
        code.line(');');
        code.line();
        code.comment('Run onError interceptor');
        code.block('if (config?.onError) {', () => {
          code.line('await config.onError(error);');
        });
        code.line();
        code.line('throw error;');
      });
      code.line();

      code.comment('Handle 204 No Content');
      code.line('if (response.status === 204) return undefined as T;');
      code.line();
      code.line('return response.json();');
    }, '} catch (err) {');
    code.indent();
    code.comment('Re-throw ApiError as-is');
    code.line('if (err instanceof ApiError) throw err;');
    code.line();
    code.comment('Wrap network errors');
    code.line('const error = new ApiError(');
    code.line("  err instanceof Error ? err.message : 'Network error',");
    code.line('  0,');
    code.line("  'NETWORK_ERROR',");
    code.line('  operation');
    code.line(');');
    code.block('if (config?.onError) {', () => {
      code.line('await config.onError(error);');
    });
    code.line('throw error;');
    code.dedent();
    code.line('}');

    code.dedent();
    code.line('}');
    code.line();

    // Generate the API client object
    code.comment('Build API client with all entity methods');
    code.block('return {', () => {
      // Entity CRUD operations
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        generateEntityApi(code, schema, apiPrefix);
      }

      // Custom endpoints
      if (endpoints.length > 0) {
        code.line();
        code.comment('Custom endpoints');
        for (const endpoint of endpoints) {
          generateEndpointApi(code, endpoint);
        }
      }
    }, '};');
  });
  code.line();
}

/**
 * Generate API methods for a single entity
 */
function generateEntityApi(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  apiPrefix: string
): void {
  const { name, pascalName, pluralName, relations, endpoint } = schema;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';
  // Use schema's endpoint if valid, otherwise build from apiPrefix
  const entityEndpoint = (endpoint && !endpoint.includes('undefined'))
    ? endpoint
    : `${apiPrefix}/${pluralName}`;

  code.block(`${name}: {`, () => {
    // LIST
    code.line(`list: (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>) =>`);
    code.indent();
    code.line(`request<Types.ListResponse<Types.${pascalName}>>('GET', '${entityEndpoint}', '${name}.list', { query: options as Record<string, unknown> }),`);
    code.dedent();
    code.line();

    // GET
    code.line(`get: (id: string, options?: { include?: ${includeType}[] }) =>`);
    code.indent();
    code.line(`request<Types.ItemResponse<Types.${pascalName}>>('GET', \`${entityEndpoint}/\${id}\`, '${name}.get', { query: options as Record<string, unknown> }),`);
    code.dedent();
    code.line();

    // CREATE
    code.line(`create: (input: Types.${pascalName}Create) =>`);
    code.indent();
    code.line(`request<Types.ItemResponse<Types.${pascalName}>>('POST', '${entityEndpoint}', '${name}.create', { body: input }),`);
    code.dedent();
    code.line();

    // UPDATE
    code.line(`update: (id: string, input: Types.${pascalName}Update) =>`);
    code.indent();
    code.line(`request<Types.ItemResponse<Types.${pascalName}>>('PATCH', \`${entityEndpoint}/\${id}\`, '${name}.update', { body: input }),`);
    code.dedent();
    code.line();

    // DELETE
    code.line('delete: (id: string) =>');
    code.indent();
    code.line(`request<void>('DELETE', \`${entityEndpoint}/\${id}\`, '${name}.delete'),`);
    code.dedent();
  }, '},');
  code.line();
}

/**
 * Generate API method for a custom endpoint
 */
function generateEndpointApi(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { name, pascalName, path, method } = endpoint;
  const hasParams = endpoint.params && endpoint.params.length > 0;
  const hasBody = endpoint.body && endpoint.body.length > 0;
  const responseType = `Types.${pascalName}Response`;

  // Replace path params with template literals
  const pathWithParams = path.replace(/:(\w+)/g, '${params.$1}');
  const hasPathParams = path.includes(':');

  if (hasBody && hasParams) {
    code.line(`${name}: (params: Types.${pascalName}Params, body: Types.${pascalName}Body) =>`);
    code.indent();
    if (hasPathParams) {
      code.line(`request<${responseType}>('${method}', \`${pathWithParams}\`, '${name}', { body }),`);
    } else {
      code.line(`request<${responseType}>('${method}', '${path}', '${name}', { query: params as Record<string, unknown>, body }),`);
    }
    code.dedent();
  } else if (hasBody) {
    code.line(`${name}: (body: Types.${pascalName}Body) =>`);
    code.indent();
    code.line(`request<${responseType}>('${method}', '${path}', '${name}', { body }),`);
    code.dedent();
  } else if (hasParams) {
    code.line(`${name}: (params: Types.${pascalName}Params) =>`);
    code.indent();
    if (hasPathParams) {
      code.line(`request<${responseType}>('${method}', \`${pathWithParams}\`, '${name}'),`);
    } else {
      code.line(`request<${responseType}>('${method}', '${path}', '${name}', { query: params as Record<string, unknown> }),`);
    }
    code.dedent();
  } else {
    code.line(`${name}: () =>`);
    code.indent();
    code.line(`request<${responseType}>('${method}', '${path}', '${name}'),`);
    code.dedent();
  }
}
