/**
 * Unified Handler Generator
 *
 * Generates route handlers that use the service layer and middleware chain.
 * Supports multiple targets: MSW, Next.js, Express, Supabase Edge.
 *
 * Key principle: Handlers orchestrate, services do the work.
 * Middleware is applied per-operation, not globally.
 *
 * @module cli/generators/unified/handler
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedEndpoint } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { pluralize } from '../../utils/pluralize';

/**
 * Handler generator target types
 */
export type HandlerTarget = 'msw' | 'nextjs' | 'express' | 'supabase-edge';

/**
 * Configuration for handler generation
 */
export interface HandlerGeneratorConfig {
  /** Target type determines output format */
  target: HandlerTarget;

  /** Path to import services from */
  servicesImport?: string;

  /** Path to import middleware from */
  middlewareImport?: string;

  /** Path to import types from */
  typesImport?: string;

  /** Operations to skip generating */
  skip?: string[];

  /** Whether to include custom endpoints */
  includeEndpoints?: boolean;

  /** API prefix for routes */
  apiPrefix?: string;
}

/**
 * Generate unified handlers for all entities
 *
 * @param schemas - Analyzed schemas
 * @param endpoints - Custom endpoints (optional)
 * @param config - Handler generation configuration
 * @returns Generated TypeScript code
 */
export function generateUnifiedHandlers(
  schemas: AnalyzedSchema[],
  endpoints: AnalyzedEndpoint[] = [],
  config: HandlerGeneratorConfig
): string {
  switch (config.target) {
    case 'msw':
      return generateMswHandlers(schemas, endpoints, config);
    case 'nextjs':
      return generateNextjsHandlers(schemas, config);
    case 'express':
      return generateExpressHandlers(schemas, config);
    case 'supabase-edge':
      return generateEdgeHandlers(schemas, config);
    default:
      throw new Error(`Unsupported handler target: ${config.target}`);
  }
}

/**
 * Generate MSW handlers using services and middleware
 */
function generateMswHandlers(
  schemas: AnalyzedSchema[],
  endpoints: AnalyzedEndpoint[],
  config: HandlerGeneratorConfig
): string {
  const code = new CodeBuilder();
  const {
    servicesImport = './services',
    middlewareImport = './middleware',
    typesImport = './types',
    apiPrefix = '/api',
    skip = [],
    includeEndpoints = true,
  } = config;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('MSW handlers using service layer with middleware');
  code.line();

  // Imports
  code.line("import { http, HttpResponse } from 'msw';");
  code.line(`import { withMiddleware, getMiddleware, type MiddlewareContext } from '${middlewareImport}';`);

  // Import services
  const serviceImports = schemas
    .filter((s) => !s.isJunctionTable)
    .map((s) => `${s.singularName}Service`);
  code.line(`import { ${serviceImports.join(', ')} } from '${servicesImport}';`);

  // Import types
  const typeImports: string[] = [];
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    typeImports.push(`${schema.pascalName}Create`, `${schema.pascalName}Update`);
  }
  code.line(`import type { ${typeImports.join(', ')} } from '${typesImport}';`);
  code.line();

  // Query options parser
  generateQueryOptionsParser(code);

  // Generate handlers array
  code.block('export const handlers = [', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateMswEntityHandlers(code, schema, apiPrefix, skip);
    }

    // Generate endpoint handlers if configured
    if (includeEndpoints && endpoints.length > 0) {
      code.comment('Custom endpoint handlers');
      for (const endpoint of endpoints) {
        generateMswEndpointHandler(code, endpoint, apiPrefix);
      }
    }
  }, '];');

  return code.toString();
}

/**
 * Generate MSW handlers for a single entity
 */
function generateMswEntityHandlers(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  apiPrefix: string,
  skip: string[]
): void {
  const { name, pascalName, singularName } = schema;
  const pluralName = pluralize(name);
  const basePath = `${apiPrefix}/${pluralName}`;

  code.comment(`${pascalName} handlers`);

  // LIST
  if (!skip.includes(`${name}.list`)) {
    code.block(`http.get('${basePath}', async ({ request }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'list'), request, async (ctx) => {`);
      code.indent();
      code.line('const options = parseQueryOptions(new URL(request.url));');
      code.line(`const data = await ${singularName}Service.list(ctx, options);`);
      code.line('return HttpResponse.json({');
      code.line('  data,');
      code.line('  meta: { limit: options.limit ?? 20, offset: options.offset ?? 0 },');
      code.line('});');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // GET
  if (!skip.includes(`${name}.get`)) {
    code.block(`http.get('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'get'), request, async (ctx) => {`);
      code.indent();
      code.line(`const data = await ${singularName}Service.get(ctx, params.id as string);`);
      code.line('return HttpResponse.json({ data });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // CREATE
  if (!skip.includes(`${name}.create`)) {
    code.block(`http.post('${basePath}', async ({ request }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'create'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Create;`);
      code.line(`const data = await ${singularName}Service.create(ctx, body);`);
      code.line('return HttpResponse.json({ data }, { status: 201 });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // UPDATE (PUT)
  if (!skip.includes(`${name}.update`)) {
    code.block(`http.put('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, params.id as string, body);`);
      code.line('return HttpResponse.json({ data });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();

    // UPDATE (PATCH) - same as PUT
    code.block(`http.patch('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, params.id as string, body);`);
      code.line('return HttpResponse.json({ data });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.block(`http.delete('${basePath}/:id', async ({ request, params }) => {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'delete'), request, async (ctx) => {`);
      code.indent();
      code.line(`await ${singularName}Service.delete(ctx, params.id as string);`);
      code.line('return new HttpResponse(null, { status: 204 });');
      code.dedent();
      code.line('});');
    }, '}),');
    code.line();
  }
}

/**
 * Generate MSW handler for custom endpoint
 */
function generateMswEndpointHandler(
  code: CodeBuilder,
  endpoint: AnalyzedEndpoint,
  apiPrefix: string
): void {
  const method = endpoint.method.toLowerCase();
  const path = endpoint.path.startsWith('/') ? endpoint.path : `/${endpoint.path}`;

  // Convert :param to path params pattern for MSW
  const mswPath = path.replace(/:([^/]+)/g, ':$1');

  code.block(`http.${method}('${apiPrefix}${mswPath}', async ({ request, params }) => {`, () => {
    code.comment(`Custom endpoint: ${endpoint.name}`);

    // Check if endpoint has middleware
    const hasMiddleware = endpoint.middleware && endpoint.middleware.length > 0;

    if (hasMiddleware) {
      code.line(`return withMiddleware([], request, async (ctx) => { // TODO: Wire up middleware`);
    } else {
      code.line('const ctx: MiddlewareContext = {}; // No middleware configured');
    }

    code.indent();
    code.comment('TODO: Import and call endpoint service');
    code.line('return HttpResponse.json({ message: "Not implemented" }, { status: 501 });');
    code.dedent();

    if (hasMiddleware) {
      code.line('});');
    }
  }, '}),');
  code.line();
}

/**
 * Generate Next.js route handlers (as a module with named exports)
 */
function generateNextjsHandlers(
  schemas: AnalyzedSchema[],
  config: HandlerGeneratorConfig
): string {
  const code = new CodeBuilder();
  const {
    servicesImport = '../services',
    middlewareImport = '../middleware',
    typesImport = '../types',
    skip = [],
  } = config;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Next.js API routes using service layer with middleware');
  code.line();

  // Imports
  code.line("import { NextRequest, NextResponse } from 'next/server';");
  code.line(`import { withMiddleware, getMiddleware, type MiddlewareContext } from '${middlewareImport}';`);

  // Import services
  const serviceImports = schemas
    .filter((s) => !s.isJunctionTable)
    .map((s) => `${s.singularName}Service`);
  code.line(`import { ${serviceImports.join(', ')} } from '${servicesImport}';`);

  // Import types
  const typeImports: string[] = [];
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    typeImports.push(`${schema.pascalName}Create`, `${schema.pascalName}Update`);
  }
  code.line(`import type { ${typeImports.join(', ')} } from '${typesImport}';`);
  code.line();

  // Query options parser
  generateQueryOptionsParser(code);

  // Generate handlers for each entity
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateNextjsEntityHandlers(code, schema, skip);
  }

  return code.toString();
}

/**
 * Generate Next.js handlers for a single entity
 */
function generateNextjsEntityHandlers(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  skip: string[]
): void {
  const { name, pascalName, singularName, pluralName } = schema;

  code.comment(`${'='.repeat(60)}`);
  code.comment(`${pascalName} Handlers`);
  code.comment(`${'='.repeat(60)}`);
  code.line();

  // LIST
  if (!skip.includes(`${name}.list`)) {
    code.multiDocComment([
      `GET /api/${pluralName}`,
      `List ${pluralName} with pagination`,
    ]);
    code.block(`export async function list${pascalName}(request: NextRequest): Promise<NextResponse> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'list'), request, async (ctx) => {`);
      code.indent();
      code.line('const options = parseQueryOptions(request.nextUrl);');
      code.line(`const data = await ${singularName}Service.list(ctx, options);`);
      code.line('return NextResponse.json({');
      code.line('  data,');
      code.line('  meta: { limit: options.limit ?? 20, offset: options.offset ?? 0 },');
      code.line('});');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // GET
  if (!skip.includes(`${name}.get`)) {
    code.multiDocComment([
      `GET /api/${pluralName}/[id]`,
      `Get single ${singularName} by ID`,
    ]);
    code.block(`export async function get${pascalName}(request: NextRequest, id: string): Promise<NextResponse> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'get'), request, async (ctx) => {`);
      code.indent();
      code.line(`const data = await ${singularName}Service.get(ctx, id);`);
      code.line('return NextResponse.json({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // CREATE
  if (!skip.includes(`${name}.create`)) {
    code.multiDocComment([
      `POST /api/${pluralName}`,
      `Create new ${singularName}`,
    ]);
    code.block(`export async function create${pascalName}(request: NextRequest): Promise<NextResponse> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'create'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Create;`);
      code.line(`const data = await ${singularName}Service.create(ctx, body);`);
      code.line('return NextResponse.json({ data }, { status: 201 });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // UPDATE
  if (!skip.includes(`${name}.update`)) {
    code.multiDocComment([
      `PUT /api/${pluralName}/[id]`,
      `Update ${singularName}`,
    ]);
    code.block(`export async function update${pascalName}(request: NextRequest, id: string): Promise<NextResponse> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
      code.line('return NextResponse.json({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.multiDocComment([
      `DELETE /api/${pluralName}/[id]`,
      `Delete ${singularName}`,
    ]);
    code.block(`export async function delete${pascalName}(request: NextRequest, id: string): Promise<NextResponse> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'delete'), request, async (ctx) => {`);
      code.indent();
      code.line(`await ${singularName}Service.delete(ctx, id);`);
      code.line('return new NextResponse(null, { status: 204 });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }
}

/**
 * Generate Express handlers
 */
function generateExpressHandlers(
  schemas: AnalyzedSchema[],
  config: HandlerGeneratorConfig
): string {
  const code = new CodeBuilder();
  const {
    servicesImport = '../services',
    middlewareImport = '../middleware',
    typesImport = '../types',
    skip = [],
  } = config;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Express handlers using service layer with middleware');
  code.line();

  // Imports
  code.line("import type { Request, Response, NextFunction } from 'express';");
  code.line(`import { withMiddleware, getMiddleware, type MiddlewareContext } from '${middlewareImport}';`);

  // Import services
  const serviceImports = schemas
    .filter((s) => !s.isJunctionTable)
    .map((s) => `${s.singularName}Service`);
  code.line(`import { ${serviceImports.join(', ')} } from '${servicesImport}';`);

  // Import types
  const typeImports: string[] = [];
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    typeImports.push(`${schema.pascalName}Create`, `${schema.pascalName}Update`);
  }
  code.line(`import type { ${typeImports.join(', ')} } from '${typesImport}';`);
  code.line();

  // Generate handlers for each entity
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateExpressEntityHandlers(code, schema, skip);
  }

  return code.toString();
}

/**
 * Generate Express handlers for a single entity
 */
function generateExpressEntityHandlers(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  skip: string[]
): void {
  const { name, pascalName, singularName, pluralName } = schema;

  code.comment(`${'='.repeat(60)}`);
  code.comment(`${pascalName} Handlers`);
  code.comment(`${'='.repeat(60)}`);
  code.line();

  // LIST
  if (!skip.includes(`${name}.list`)) {
    code.multiDocComment([
      `GET /${pluralName}`,
      `List ${pluralName} with pagination`,
    ]);
    code.block(`export async function list${pascalName}(req: Request, res: Response, next: NextFunction): Promise<void> {`, () => {
      code.block('try {', () => {
        code.line(`await withMiddleware(getMiddleware('${name}', 'list'), req, res, async (ctx) => {`);
        code.indent();
        code.line("const limit = parseInt(req.query.limit as string || '20', 10);");
        code.line("const offset = parseInt(req.query.offset as string || '0', 10);");
        code.line(`const data = await ${singularName}Service.list(ctx, { limit, offset });`);
        code.line('res.json({ data, meta: { limit, offset } });');
        code.dedent();
        code.line('});');
      }, '} catch (error) {');
      code.indent();
      code.line('next(error);');
      code.dedent();
      code.line('}');
    });
    code.line();
  }

  // GET
  if (!skip.includes(`${name}.get`)) {
    code.multiDocComment([
      `GET /${pluralName}/:id`,
      `Get single ${singularName} by ID`,
    ]);
    code.block(`export async function get${pascalName}(req: Request, res: Response, next: NextFunction): Promise<void> {`, () => {
      code.block('try {', () => {
        code.line(`await withMiddleware(getMiddleware('${name}', 'get'), req, res, async (ctx) => {`);
        code.indent();
        code.line(`const data = await ${singularName}Service.get(ctx, req.params.id);`);
        code.line('res.json({ data });');
        code.dedent();
        code.line('});');
      }, '} catch (error) {');
      code.indent();
      code.line('next(error);');
      code.dedent();
      code.line('}');
    });
    code.line();
  }

  // CREATE
  if (!skip.includes(`${name}.create`)) {
    code.multiDocComment([
      `POST /${pluralName}`,
      `Create new ${singularName}`,
    ]);
    code.block(`export async function create${pascalName}(req: Request, res: Response, next: NextFunction): Promise<void> {`, () => {
      code.block('try {', () => {
        code.line(`await withMiddleware(getMiddleware('${name}', 'create'), req, res, async (ctx) => {`);
        code.indent();
        code.line(`const body = req.body as ${pascalName}Create;`);
        code.line(`const data = await ${singularName}Service.create(ctx, body);`);
        code.line('res.status(201).json({ data });');
        code.dedent();
        code.line('});');
      }, '} catch (error) {');
      code.indent();
      code.line('next(error);');
      code.dedent();
      code.line('}');
    });
    code.line();
  }

  // UPDATE
  if (!skip.includes(`${name}.update`)) {
    code.multiDocComment([
      `PUT /${pluralName}/:id`,
      `Update ${singularName}`,
    ]);
    code.block(`export async function update${pascalName}(req: Request, res: Response, next: NextFunction): Promise<void> {`, () => {
      code.block('try {', () => {
        code.line(`await withMiddleware(getMiddleware('${name}', 'update'), req, res, async (ctx) => {`);
        code.indent();
        code.line(`const body = req.body as ${pascalName}Update;`);
        code.line(`const data = await ${singularName}Service.update(ctx, req.params.id, body);`);
        code.line('res.json({ data });');
        code.dedent();
        code.line('});');
      }, '} catch (error) {');
      code.indent();
      code.line('next(error);');
      code.dedent();
      code.line('}');
    });
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.multiDocComment([
      `DELETE /${pluralName}/:id`,
      `Delete ${singularName}`,
    ]);
    code.block(`export async function delete${pascalName}(req: Request, res: Response, next: NextFunction): Promise<void> {`, () => {
      code.block('try {', () => {
        code.line(`await withMiddleware(getMiddleware('${name}', 'delete'), req, res, async (ctx) => {`);
        code.indent();
        code.line(`await ${singularName}Service.delete(ctx, req.params.id);`);
        code.line('res.status(204).send();');
        code.dedent();
        code.line('});');
      }, '} catch (error) {');
      code.indent();
      code.line('next(error);');
      code.dedent();
      code.line('}');
    });
    code.line();
  }
}

/**
 * Generate Supabase Edge handlers
 */
function generateEdgeHandlers(
  schemas: AnalyzedSchema[],
  config: HandlerGeneratorConfig
): string {
  const code = new CodeBuilder();
  const {
    servicesImport = '../services',
    middlewareImport = '../middleware',
    typesImport = '../types',
    skip = [],
  } = config;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Supabase Edge Function handlers using service layer with middleware');
  code.line();

  // Imports
  code.line(`import { withMiddleware, getMiddleware, type MiddlewareContext } from '${middlewareImport}';`);

  // Import services
  const serviceImports = schemas
    .filter((s) => !s.isJunctionTable)
    .map((s) => `${s.singularName}Service`);
  code.line(`import { ${serviceImports.join(', ')} } from '${servicesImport}';`);

  // Import types
  const typeImports: string[] = [];
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    typeImports.push(`${schema.pascalName}Create`, `${schema.pascalName}Update`);
  }
  code.line(`import type { ${typeImports.join(', ')} } from '${typesImport}';`);
  code.line();

  // Query options parser
  generateQueryOptionsParser(code);

  // Helper for JSON responses
  code.block('function jsonResponse(data: unknown, status = 200): Response {', () => {
    code.line('return new Response(JSON.stringify(data), {');
    code.line('  status,');
    code.line("  headers: { 'Content-Type': 'application/json' },");
    code.line('});');
  });
  code.line();

  // Generate handlers for each entity
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEdgeEntityHandlers(code, schema, skip);
  }

  return code.toString();
}

/**
 * Generate Edge handlers for a single entity
 */
function generateEdgeEntityHandlers(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  skip: string[]
): void {
  const { name, pascalName, singularName, pluralName } = schema;

  code.comment(`${'='.repeat(60)}`);
  code.comment(`${pascalName} Handlers`);
  code.comment(`${'='.repeat(60)}`);
  code.line();

  // LIST
  if (!skip.includes(`${name}.list`)) {
    code.multiDocComment([
      `List ${pluralName} with pagination`,
    ]);
    code.block(`export async function list${pascalName}(request: Request): Promise<Response> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'list'), request, async (ctx) => {`);
      code.indent();
      code.line('const options = parseQueryOptions(new URL(request.url));');
      code.line(`const data = await ${singularName}Service.list(ctx, options);`);
      code.line('return jsonResponse({');
      code.line('  data,');
      code.line('  meta: { limit: options.limit ?? 20, offset: options.offset ?? 0 },');
      code.line('});');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // GET
  if (!skip.includes(`${name}.get`)) {
    code.multiDocComment([
      `Get single ${singularName} by ID`,
    ]);
    code.block(`export async function get${pascalName}(request: Request, id: string): Promise<Response> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'get'), request, async (ctx) => {`);
      code.indent();
      code.line(`const data = await ${singularName}Service.get(ctx, id);`);
      code.line('return jsonResponse({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // CREATE
  if (!skip.includes(`${name}.create`)) {
    code.multiDocComment([
      `Create new ${singularName}`,
    ]);
    code.block(`export async function create${pascalName}(request: Request): Promise<Response> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'create'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Create;`);
      code.line(`const data = await ${singularName}Service.create(ctx, body);`);
      code.line('return jsonResponse({ data }, 201);');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // UPDATE
  if (!skip.includes(`${name}.update`)) {
    code.multiDocComment([
      `Update ${singularName}`,
    ]);
    code.block(`export async function update${pascalName}(request: Request, id: string): Promise<Response> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
      code.line('return jsonResponse({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.multiDocComment([
      `Delete ${singularName}`,
    ]);
    code.block(`export async function delete${pascalName}(request: Request, id: string): Promise<Response> {`, () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'delete'), request, async (ctx) => {`);
      code.indent();
      code.line(`await ${singularName}Service.delete(ctx, id);`);
      code.line("return new Response(null, { status: 204 });");
      code.dedent();
      code.line('});');
    });
    code.line();
  }
}

/**
 * Generate query options parser helper
 */
function generateQueryOptionsParser(code: CodeBuilder): void {
  code.multiDocComment([
    'Parse query options from URL search params',
  ]);
  code.block('function parseQueryOptions(url: URL | { searchParams: URLSearchParams }): { limit?: number; offset?: number; where?: Record<string, unknown> } {', () => {
    code.line('const searchParams = url instanceof URL ? url.searchParams : url.searchParams;');
    code.line("const limit = searchParams.get('limit');");
    code.line("const offset = searchParams.get('offset');");
    code.line();
    code.line('return {');
    code.line('  limit: limit ? parseInt(limit, 10) : undefined,');
    code.line('  offset: offset ? parseInt(offset, 10) : undefined,');
    code.line('};');
  });
  code.line();
}

/**
 * Generate a single Next.js route file for an entity collection
 *
 * @param schema - Analyzed schema
 * @param config - Handler configuration
 * @returns Generated route.ts content
 */
export function generateNextjsRouteFile(
  schema: AnalyzedSchema,
  config: HandlerGeneratorConfig
): string {
  const code = new CodeBuilder();
  const {
    servicesImport = '../_lib/services',
    middlewareImport = '../_lib/middleware',
    typesImport = '../_lib/types',
  } = config;

  const { name, pascalName, singularName, pluralName } = schema;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  code.line("import { NextRequest, NextResponse } from 'next/server';");
  code.line(`import { withMiddleware, getMiddleware } from '${middlewareImport}';`);
  code.line(`import { ${singularName}Service } from '${servicesImport}';`);
  code.line(`import type { ${pascalName}Create } from '${typesImport}';`);
  code.line();

  // Query options parser
  generateQueryOptionsParser(code);

  // GET - List
  code.multiDocComment([
    `GET /api/${pluralName}`,
    `List all ${pluralName}`,
  ]);
  code.block('export async function GET(request: NextRequest) {', () => {
    code.line(`return withMiddleware(getMiddleware('${name}', 'list'), request, async (ctx) => {`);
    code.indent();
    code.line('const options = parseQueryOptions(request.nextUrl);');
    code.line(`const data = await ${singularName}Service.list(ctx, options);`);
    code.line('return NextResponse.json({');
    code.line('  data,');
    code.line('  meta: { limit: options.limit ?? 20, offset: options.offset ?? 0 },');
    code.line('});');
    code.dedent();
    code.line('});');
  });
  code.line();

  // POST - Create
  code.multiDocComment([
    `POST /api/${pluralName}`,
    `Create new ${singularName}`,
  ]);
  code.block('export async function POST(request: NextRequest) {', () => {
    code.line(`return withMiddleware(getMiddleware('${name}', 'create'), request, async (ctx) => {`);
    code.indent();
    code.line(`const body = await request.json() as ${pascalName}Create;`);
    code.line(`const data = await ${singularName}Service.create(ctx, body);`);
    code.line('return NextResponse.json({ data }, { status: 201 });');
    code.dedent();
    code.line('});');
  });

  return code.toString();
}

/**
 * Generate a single Next.js dynamic route file for an entity
 *
 * @param schema - Analyzed schema
 * @param config - Handler configuration
 * @returns Generated route.ts content for [id] route
 */
export function generateNextjsDynamicRouteFile(
  schema: AnalyzedSchema,
  config: HandlerGeneratorConfig
): string {
  const code = new CodeBuilder();
  const {
    servicesImport = '../../_lib/services',
    middlewareImport = '../../_lib/middleware',
    typesImport = '../../_lib/types',
  } = config;

  const { name, pascalName, singularName, pluralName } = schema;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  code.line("import { NextRequest, NextResponse } from 'next/server';");
  code.line(`import { withMiddleware, getMiddleware } from '${middlewareImport}';`);
  code.line(`import { ${singularName}Service } from '${servicesImport}';`);
  code.line(`import type { ${pascalName}Update } from '${typesImport}';`);
  code.line();

  // Route params type
  code.block('interface RouteParams {', () => {
    code.line('params: Promise<{ id: string }>;');
  });
  code.line();

  // GET - Single
  code.multiDocComment([
    `GET /api/${pluralName}/[id]`,
    `Get single ${singularName} by ID`,
  ]);
  code.block('export async function GET(request: NextRequest, { params }: RouteParams) {', () => {
    code.line('const { id } = await params;');
    code.line(`return withMiddleware(getMiddleware('${name}', 'get'), request, async (ctx) => {`);
    code.indent();
    code.line(`const data = await ${singularName}Service.get(ctx, id);`);
    code.line('return NextResponse.json({ data });');
    code.dedent();
    code.line('});');
  });
  code.line();

  // PUT - Update
  code.multiDocComment([
    `PUT /api/${pluralName}/[id]`,
    `Update ${singularName}`,
  ]);
  code.block('export async function PUT(request: NextRequest, { params }: RouteParams) {', () => {
    code.line('const { id } = await params;');
    code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
    code.indent();
    code.line(`const body = await request.json() as ${pascalName}Update;`);
    code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
    code.line('return NextResponse.json({ data });');
    code.dedent();
    code.line('});');
  });
  code.line();

  // PATCH - Partial update
  code.multiDocComment([
    `PATCH /api/${pluralName}/[id]`,
    `Partial update ${singularName}`,
  ]);
  code.block('export async function PATCH(request: NextRequest, { params }: RouteParams) {', () => {
    code.line('const { id } = await params;');
    code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
    code.indent();
    code.line(`const body = await request.json() as ${pascalName}Update;`);
    code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
    code.line('return NextResponse.json({ data });');
    code.dedent();
    code.line('});');
  });
  code.line();

  // DELETE
  code.multiDocComment([
    `DELETE /api/${pluralName}/[id]`,
    `Delete ${singularName}`,
  ]);
  code.block('export async function DELETE(request: NextRequest, { params }: RouteParams) {', () => {
    code.line('const { id } = await params;');
    code.line(`return withMiddleware(getMiddleware('${name}', 'delete'), request, async (ctx) => {`);
    code.indent();
    code.line(`await ${singularName}Service.delete(ctx, id);`);
    code.line('return new NextResponse(null, { status: 204 });');
    code.dedent();
    code.line('});');
  });

  return code.toString();
}
