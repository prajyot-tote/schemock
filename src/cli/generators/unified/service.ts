/**
 * Service Layer Generator
 *
 * Generates service files that contain business logic and RLS enforcement.
 * Services are used by route handlers (Next.js, Express, MSW, etc.) to
 * perform CRUD operations with proper authorization.
 *
 * Key features:
 * - RLS enforcement in service methods
 * - Filtering, sorting, pagination logic
 * - Configurable DB import path
 * - MiddlewareContext for auth/tenant data
 *
 * @module cli/generators/unified/service
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedEndpoint, AnalyzedField } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Configuration for service generation
 */
export interface ServiceGeneratorConfig {
  /** Path to import db from (e.g., '@/lib/db', '../db') */
  dbImport?: string;
  /** Path to import types from (e.g., '../types') */
  typesImport?: string;
  /** Whether to generate RLS enforcement */
  includeRLS?: boolean;
}

/**
 * Generate service file for a single entity
 *
 * @param schema - Analyzed schema for the entity
 * @param allSchemas - All schemas (for relation lookups)
 * @param config - Service generator configuration
 * @returns Generated TypeScript code
 */
export function generateEntityService(
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  config: ServiceGeneratorConfig = {}
): string {
  const code = new CodeBuilder();
  const dbImport = config.dbImport ?? './db';
  const typesImport = config.typesImport ?? '../types';
  const includeRLS = config.includeRLS ?? true;

  const { pascalName, name, fields, rls } = schema;
  const hasRLS = includeRLS && rls.enabled;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment(`Service layer for ${pascalName} entity`);
  code.line();

  // Imports
  code.line(`import { db } from '${dbImport}';`);
  code.line(`import type { ${pascalName}, ${pascalName}Create, ${pascalName}Update, QueryOptions, ${pascalName}Filter } from '${typesImport}';`);
  code.line();

  // Generate MiddlewareContext type
  generateMiddlewareContext(code, schema);

  // Generate errors
  generateServiceErrors(code);

  // Generate service object
  generateServiceMethods(code, schema, allSchemas, hasRLS);

  return code.toString();
}

/**
 * Generate MiddlewareContext type
 */
function generateMiddlewareContext(code: CodeBuilder, schema: AnalyzedSchema): void {
  const { rls } = schema;

  code.multiDocComment([
    'Context from middleware chain (auth, tenant, etc.)',
    'Contains user/tenant info extracted by middleware handlers',
  ]);
  code.block('export interface MiddlewareContext {', () => {
    code.line('/** Authenticated user ID */');
    code.line('userId?: string;');
    code.line('/** User role for authorization */');
    code.line('role?: string;');

    // Add context keys from RLS scope
    if (rls.enabled) {
      const contextKeys = new Set<string>();
      for (const scope of rls.scope) {
        if (scope.contextKey && scope.contextKey !== 'userId' && scope.contextKey !== 'role') {
          contextKeys.add(scope.contextKey);
        }
      }
      for (const key of contextKeys) {
        code.line(`/** ${key} from RLS scope */`);
        code.line(`${key}?: string;`);
      }
    }

    code.line('/** Additional context data */');
    code.line('[key: string]: unknown;');
  });
  code.line();
}

/**
 * Generate service error classes
 */
function generateServiceErrors(code: CodeBuilder): void {
  code.multiDocComment(['Error thrown when entity is not found']);
  code.block('export class NotFoundError extends Error {', () => {
    code.line('readonly status = 404;');
    code.line("readonly code = 'NOT_FOUND';");
    code.line();
    code.line('constructor(entity: string, id: string) {');
    code.line('  super(`${entity} with id ${id} not found`);');
    code.line("  this.name = 'NotFoundError';");
    code.line('}');
  });
  code.line();

  code.multiDocComment(['Error thrown when RLS policy denies access']);
  code.block('export class RLSError extends Error {', () => {
    code.line('readonly status = 403;');
    code.line("readonly code = 'RLS_VIOLATION';");
    code.line();
    code.line('constructor(operation: string, entity: string) {');
    code.line('  super(`Access denied: ${operation} on ${entity}`);');
    code.line("  this.name = 'RLSError';");
    code.line('}');
  });
  code.line();
}

/**
 * Generate service methods for CRUD operations
 */
function generateServiceMethods(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  allSchemas: AnalyzedSchema[],
  hasRLS: boolean
): void {
  const { pascalName, name, singularName, rls } = schema;

  code.multiDocComment([
    `Service for ${pascalName} entity`,
    '',
    'Contains business logic and RLS enforcement for CRUD operations.',
    'Use this service from route handlers to ensure consistent authorization.',
  ]);
  code.block(`export const ${singularName}Service = {`, () => {
    // LIST method
    generateListMethod(code, schema, hasRLS);

    // GET method
    generateGetMethod(code, schema, hasRLS);

    // CREATE method
    generateCreateMethod(code, schema, hasRLS);

    // UPDATE method
    generateUpdateMethod(code, schema, hasRLS);

    // DELETE method
    generateDeleteMethod(code, schema, hasRLS);
  }, '};');
  code.line();

  // Export default
  code.line(`export default ${singularName}Service;`);
}

/**
 * Generate list method
 */
function generateListMethod(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { pascalName, name, rls } = schema;

  code.multiDocComment([
    `List ${pascalName} records with filtering, sorting, and pagination`,
    '',
    '@param ctx - Middleware context with auth info',
    '@param options - Query options (where, orderBy, limit, offset)',
    `@returns Array of ${pascalName} records`,
  ]);
  code.block(`async list(ctx: MiddlewareContext, options?: QueryOptions<${pascalName}Filter>): Promise<${pascalName}[]> {`, () => {
    // Build where clause with RLS
    if (hasRLS && rls.scope.length > 0) {
      code.comment('Apply RLS scope to filter');
      code.line('const rlsFilter: Record<string, unknown> = {};');
      for (const scope of rls.scope) {
        code.line(`if (ctx.${scope.contextKey}) {`);
        code.line(`  rlsFilter.${scope.field} = ctx.${scope.contextKey};`);
        code.line('}');
      }
      code.line();
      code.line('const where = { ...rlsFilter, ...options?.where };');
    } else {
      code.line('const where = options?.where ?? {};');
    }
    code.line();

    code.line(`return db.${name}.findMany({`);
    code.line('  where,');
    code.line('  orderBy: options?.orderBy,');
    code.line('  take: options?.limit ?? 20,');
    code.line('  skip: options?.offset ?? 0,');
    code.line('});');
  }, '},');
  code.line();
}

/**
 * Generate get method
 */
function generateGetMethod(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { pascalName, name, rls } = schema;

  code.multiDocComment([
    `Get a single ${pascalName} by ID`,
    '',
    '@param ctx - Middleware context with auth info',
    '@param id - Record ID',
    `@returns ${pascalName} record`,
    '@throws NotFoundError if record not found',
    '@throws RLSError if access denied',
  ]);
  code.block(`async get(ctx: MiddlewareContext, id: string): Promise<${pascalName}> {`, () => {
    code.line(`const record = await db.${name}.findUnique({ where: { id } });`);
    code.line();
    code.line('if (!record) {');
    code.line(`  throw new NotFoundError('${pascalName}', id);`);
    code.line('}');

    // RLS check
    if (hasRLS && rls.scope.length > 0) {
      code.line();
      code.comment('Check RLS scope');
      for (const scope of rls.scope) {
        code.line(`if (ctx.${scope.contextKey} && record.${scope.field} !== ctx.${scope.contextKey}) {`);
        code.line(`  throw new RLSError('read', '${pascalName}');`);
        code.line('}');
      }
    }
    code.line();
    code.line('return record;');
  }, '},');
  code.line();
}

/**
 * Generate create method
 */
function generateCreateMethod(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { pascalName, name, rls } = schema;

  code.multiDocComment([
    `Create a new ${pascalName} record`,
    '',
    '@param ctx - Middleware context with auth info',
    '@param data - Record data',
    `@returns Created ${pascalName} record`,
  ]);
  code.block(`async create(ctx: MiddlewareContext, data: ${pascalName}Create): Promise<${pascalName}> {`, () => {
    // Inject RLS scope values
    if (hasRLS && rls.scope.length > 0) {
      code.comment('Inject RLS scope values from context');
      code.line('const createData = {');
      code.line('  ...data,');
      for (const scope of rls.scope) {
        code.line(`  ${scope.field}: ctx.${scope.contextKey} ?? data.${scope.field},`);
      }
      code.line('};');
      code.line();
      code.line(`return db.${name}.create({ data: createData });`);
    } else {
      code.line(`return db.${name}.create({ data });`);
    }
  }, '},');
  code.line();
}

/**
 * Generate update method
 */
function generateUpdateMethod(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { pascalName, name, rls } = schema;

  code.multiDocComment([
    `Update an existing ${pascalName} record`,
    '',
    '@param ctx - Middleware context with auth info',
    '@param id - Record ID',
    '@param data - Fields to update',
    `@returns Updated ${pascalName} record`,
    '@throws NotFoundError if record not found',
    '@throws RLSError if access denied',
  ]);
  code.block(`async update(ctx: MiddlewareContext, id: string, data: ${pascalName}Update): Promise<${pascalName}> {`, () => {
    code.comment('Verify access before update');
    code.line('const existing = await this.get(ctx, id);');
    code.line();
    code.line(`return db.${name}.update({`);
    code.line('  where: { id },');
    code.line('  data,');
    code.line('});');
  }, '},');
  code.line();
}

/**
 * Generate delete method
 */
function generateDeleteMethod(code: CodeBuilder, schema: AnalyzedSchema, hasRLS: boolean): void {
  const { pascalName, name, rls } = schema;

  code.multiDocComment([
    `Delete a ${pascalName} record`,
    '',
    '@param ctx - Middleware context with auth info',
    '@param id - Record ID',
    '@throws NotFoundError if record not found',
    '@throws RLSError if access denied',
  ]);
  code.block('async delete(ctx: MiddlewareContext, id: string): Promise<void> {', () => {
    code.comment('Verify access before delete');
    code.line('await this.get(ctx, id);');
    code.line();
    code.line(`await db.${name}.delete({ where: { id } });`);
  }, '},');
}

/**
 * Generate all entity services
 *
 * @param schemas - Analyzed schemas
 * @param config - Service generator configuration
 * @returns Map of entity name to generated service code
 */
export function generateServices(
  schemas: AnalyzedSchema[],
  config: ServiceGeneratorConfig = {}
): Map<string, string> {
  const services = new Map<string, string>();

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    const code = generateEntityService(schema, schemas, config);
    services.set(schema.singularName, code);
  }

  return services;
}

/**
 * Generate services index file (barrel export)
 *
 * @param schemas - Analyzed schemas
 * @returns Generated index.ts code
 */
export function generateServicesIndex(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Service layer exports');
  code.line();

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    code.line(`export { ${schema.singularName}Service } from './${schema.singularName}.service';`);
    code.line(`export type { MiddlewareContext as ${schema.pascalName}Context } from './${schema.singularName}.service';`);
  }

  return code.toString();
}

/**
 * Configuration for endpoint service generation
 */
export interface EndpointServiceConfig extends ServiceGeneratorConfig {
  /**
   * Generate stub services (placeholder for manual implementation) or
   * resolver-based services (delegate to mockResolver)
   */
  mode?: 'stub' | 'resolver';
}

/**
 * Generate service for custom endpoint
 *
 * @param endpoint - Analyzed endpoint
 * @param config - Service generator configuration
 * @returns Generated TypeScript code
 */
export function generateEndpointService(
  endpoint: AnalyzedEndpoint,
  config: EndpointServiceConfig = {}
): string {
  const code = new CodeBuilder();
  const dbImport = config.dbImport ?? './db';
  const typesImport = config.typesImport ?? '../types';
  const mode = config.mode ?? 'resolver';

  const { name, pascalName, params, body, response } = endpoint;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment(`Service for ${pascalName} endpoint`);
  code.line();

  // Imports
  code.line(`import { db } from '${dbImport}';`);

  const typeImports: string[] = [];
  if (params && params.length > 0) typeImports.push(`${pascalName}Params`);
  if (body && body.length > 0) typeImports.push(`${pascalName}Body`);
  if (response && response.length > 0) typeImports.push(`${pascalName}Response`);

  if (typeImports.length > 0) {
    code.line(`import type { ${typeImports.join(', ')} } from '${typesImport}';`);
  }
  code.line();

  // Import shared MiddlewareContext
  code.line("import type { MiddlewareContext } from './index';");
  code.line();

  // Import resolver dependencies if in resolver mode
  if (mode === 'resolver' && endpoint.resolverDependencies && endpoint.resolverDependencies.length > 0) {
    for (const dep of endpoint.resolverDependencies) {
      if (dep.isDefault) {
        code.line(`import ${dep.name} from '${dep.from}';`);
      } else {
        code.line(`import { ${dep.name} } from '${dep.from}';`);
      }
    }
    code.line();
  }

  // Generate local functions used by resolver
  if (mode === 'resolver' && endpoint.localFunctions && endpoint.localFunctions.length > 0) {
    code.comment('Local helper functions for the resolver');
    for (const fn of endpoint.localFunctions) {
      code.line(fn.source);
      code.line();
    }
  }

  // Generate the resolver function (if in resolver mode and has source)
  if (mode === 'resolver' && endpoint.mockResolverSource) {
    generateResolverFunction(code, endpoint);
  }

  // Generate service
  code.multiDocComment([
    `Service for ${name} endpoint`,
    '',
    mode === 'resolver'
      ? 'Delegates to the mockResolver defined in the endpoint.'
      : 'Implement the business logic for this custom endpoint.',
    'Called by the route handler after middleware processing.',
  ]);

  const hasParams = params && params.length > 0;
  const hasBody = body && body.length > 0;
  const responseType = response && response.length > 0 ? `${pascalName}Response` : 'void';

  code.block(`export const ${name}Service = {`, () => {
    code.multiDocComment([
      `Execute the ${name} endpoint logic`,
      '',
      '@param ctx - Middleware context with auth info',
      hasParams ? `@param params - Request parameters` : null,
      hasBody ? `@param body - Request body` : null,
      '@returns Response data',
    ].filter(Boolean) as string[]);

    const methodParams: string[] = ['ctx: MiddlewareContext'];
    if (hasParams) methodParams.push(`params: ${pascalName}Params`);
    if (hasBody) methodParams.push(`body: ${pascalName}Body`);

    code.block(`async execute(${methodParams.join(', ')}): Promise<${responseType}> {`, () => {
      if (mode === 'resolver' && endpoint.mockResolverSource) {
        // Call the resolver function
        const resolverArgs: string[] = [];
        if (hasParams) resolverArgs.push('params');
        if (hasBody) resolverArgs.push('body');
        resolverArgs.push('db');
        resolverArgs.push('ctx');

        code.line(`return ${name}Resolver({ ${resolverArgs.join(', ')} });`);
      } else {
        // Stub mode - generate placeholder
        code.comment('TODO: Implement endpoint logic');
        code.comment('Access database via: db.entityName.findMany/findUnique/create/update/delete');
        code.comment('Access auth context via: ctx.userId, ctx.role, ctx.tenantId, etc.');
        if (responseType !== 'void') {
          code.line(`throw new Error('Not implemented: ${name}');`);
        }
      }
    }, '},');
  }, '};');
  code.line();

  code.line(`export default ${name}Service;`);

  return code.toString();
}

/**
 * Generate the resolver function from endpoint mockResolverSource
 */
function generateResolverFunction(code: CodeBuilder, endpoint: AnalyzedEndpoint): void {
  const { name, pascalName, params, body, response, mockResolverSource } = endpoint;

  // Build the resolver context type
  const contextFields: string[] = [];
  if (params && params.length > 0) contextFields.push(`params: ${pascalName}Params`);
  if (body && body.length > 0) contextFields.push(`body: ${pascalName}Body`);
  contextFields.push('db: typeof db');
  contextFields.push('ctx: MiddlewareContext');

  const responseType = response && response.length > 0 ? `${pascalName}Response` : 'void';

  code.multiDocComment([
    `Resolver context type for ${name} endpoint`,
  ]);
  code.block(`interface ${pascalName}ResolverContext {`, () => {
    for (const field of contextFields) {
      code.line(`${field};`);
    }
  });
  code.line();

  code.multiDocComment([
    `Resolver function for ${name} endpoint`,
    'This is the mockResolver converted to a callable function.',
  ]);

  // Determine if the resolver is an arrow function or regular function
  const isArrowFunction = mockResolverSource.trim().startsWith('async') && mockResolverSource.includes('=>');

  if (isArrowFunction) {
    // Arrow function: convert to named function
    // Pattern: async ({ params, body, db }) => { ... }
    // or: async (ctx) => { ... }
    code.line(`const ${name}Resolver = ${mockResolverSource.trim()};`);
  } else if (endpoint.mockResolverName) {
    // Named function reference - import or use directly
    code.line(`const ${name}Resolver = ${endpoint.mockResolverName};`);
  } else {
    // Regular function - wrap in a variable
    code.line(`const ${name}Resolver: (ctx: ${pascalName}ResolverContext) => Promise<${responseType}> = ${mockResolverSource.trim()};`);
  }
  code.line();
}
