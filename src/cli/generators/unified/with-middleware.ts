/**
 * Middleware Helper Generator
 *
 * Generates the withMiddleware() helper and related utilities
 * for running middleware chains in handlers.
 *
 * Key features:
 * - MiddlewareContext type for auth/tenant info
 * - extractContextFromHeaders() for JWT parsing
 * - withMiddleware() wrapper for handlers
 * - getMiddlewareForOperation() for per-operation resolution
 *
 * @module cli/generators/unified/with-middleware
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedMiddlewareRef, AnalyzedEndpointMiddleware } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Configuration for middleware helper generation
 */
export interface WithMiddlewareConfig {
  /** Target platform */
  target: 'msw' | 'nextjs' | 'express' | 'supabase-edge';
  /** Path to import services from */
  servicesImport?: string;
  /** Include JWT extraction logic */
  includeJwtExtraction?: boolean;
  /** Custom headers to extract */
  customHeaders?: string[];
}

/**
 * Middleware operation types
 */
export type MiddlewareOperation = 'list' | 'get' | 'create' | 'update' | 'delete';

/**
 * Generate the middleware helper file
 *
 * @param schemas - Analyzed schemas (for middleware configuration)
 * @param config - Generation configuration
 * @returns Generated TypeScript code
 */
export function generateWithMiddleware(
  schemas: AnalyzedSchema[],
  config: WithMiddlewareConfig = { target: 'msw' }
): string {
  const code = new CodeBuilder();
  const { target, includeJwtExtraction = true, customHeaders = [] } = config;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Middleware helper for route handlers');
  code.line();

  // Generate imports based on target
  generateImports(code, target);

  // Generate MiddlewareContext interface
  generateMiddlewareContext(code, schemas, customHeaders);

  // Generate error classes
  generateMiddlewareErrors(code);

  // Generate JWT extraction if needed
  if (includeJwtExtraction) {
    generateJwtExtraction(code);
  }

  // Generate context extraction from headers
  generateContextExtraction(code, target, customHeaders);

  // Generate middleware handler type
  generateMiddlewareHandlerType(code, target);

  // Generate withMiddleware function
  generateWithMiddlewareFunction(code, target);

  // Generate middleware resolution helper
  generateMiddlewareResolution(code, schemas);

  return code.toString();
}

/**
 * Generate imports based on target platform
 */
function generateImports(code: CodeBuilder, target: string): void {
  switch (target) {
    case 'msw':
      code.line("import { HttpResponse } from 'msw';");
      break;
    case 'nextjs':
      code.line("import { NextResponse, type NextRequest } from 'next/server';");
      break;
    case 'express':
      code.line("import type { Request, Response, NextFunction } from 'express';");
      break;
    case 'supabase-edge':
      code.comment('Supabase Edge Functions use standard Request/Response');
      break;
  }
  code.line();
}

/**
 * Generate MiddlewareContext interface
 */
function generateMiddlewareContext(
  code: CodeBuilder,
  schemas: AnalyzedSchema[],
  customHeaders: string[]
): void {
  // Collect all unique context keys from RLS scope
  const contextKeys = new Set<string>(['userId', 'role']);

  for (const schema of schemas) {
    if (schema.rls.enabled) {
      for (const scope of schema.rls.scope) {
        if (scope.contextKey) {
          contextKeys.add(scope.contextKey);
        }
      }
    }
  }

  // Add custom headers as context keys
  for (const header of customHeaders) {
    const key = headerToContextKey(header);
    contextKeys.add(key);
  }

  code.multiDocComment([
    'Context extracted from request headers and middleware chain.',
    'Contains auth/tenant info passed to services.',
  ]);
  code.block('export interface MiddlewareContext {', () => {
    code.line('/** Authenticated user ID (from JWT sub claim) */');
    code.line('userId?: string;');
    code.line('/** User role for authorization */');
    code.line('role?: string;');

    // Add other context keys
    for (const key of contextKeys) {
      if (key !== 'userId' && key !== 'role') {
        code.line(`/** ${key} extracted from headers or JWT */`);
        code.line(`${key}?: string;`);
      }
    }

    code.line('/** Additional context data */');
    code.line('[key: string]: unknown;');
  });
  code.line();
}

/**
 * Generate middleware error classes
 */
function generateMiddlewareErrors(code: CodeBuilder): void {
  code.multiDocComment(['Error thrown when authentication fails']);
  code.block('export class AuthError extends Error {', () => {
    code.line('readonly status = 401;');
    code.line("readonly code = 'AUTH_REQUIRED';");
    code.line();
    code.block('constructor(message: string = "Authentication required") {', () => {
      code.line('super(message);');
      code.line("this.name = 'AuthError';");
    });
  });
  code.line();

  code.multiDocComment(['Error thrown when authorization fails']);
  code.block('export class ForbiddenError extends Error {', () => {
    code.line('readonly status = 403;');
    code.line("readonly code = 'FORBIDDEN';");
    code.line();
    code.block('constructor(message: string = "Access denied") {', () => {
      code.line('super(message);');
      code.line("this.name = 'ForbiddenError';");
    });
  });
  code.line();
}

/**
 * Generate JWT extraction helper
 */
function generateJwtExtraction(code: CodeBuilder): void {
  code.multiDocComment([
    'Decode JWT payload without verification (verification should happen at edge/API gateway).',
    'For local development/mocking, we just decode the payload.',
    '',
    '@param token - JWT token string',
    '@returns Decoded payload or null if invalid',
  ]);
  code.block('function decodeJwtPayload(token: string): Record<string, unknown> | null {', () => {
    code.block('try {', () => {
      code.line("const parts = token.split('.');");
      code.line('if (parts.length !== 3) return null;');
      code.line();
      code.comment('Decode base64url payload');
      code.line("const payload = parts[1].replace(/-/g, '+').replace(/_/g, '/');");
      code.line("const decoded = typeof atob !== 'undefined'");
      code.line('  ? atob(payload)');
      code.line("  : Buffer.from(payload, 'base64').toString('utf-8');");
      code.line();
      code.line('return JSON.parse(decoded);');
    }, '} catch {');
    code.indent();
    code.line('return null;');
    code.dedent();
    code.line('}');
  });
  code.line();
}

/**
 * Generate context extraction from headers
 */
function generateContextExtraction(
  code: CodeBuilder,
  target: string,
  customHeaders: string[]
): void {
  code.multiDocComment([
    'Extract middleware context from request headers.',
    'Parses JWT from Authorization header and extracts custom headers.',
    '',
    '@param headers - Request headers (Headers object or plain object)',
    '@returns Extracted MiddlewareContext',
  ]);

  code.block('export function extractContextFromHeaders(headers: Headers | Record<string, string>): MiddlewareContext {', () => {
    code.line('const ctx: MiddlewareContext = {};');
    code.line();

    code.comment('Helper to get header value');
    code.block('const getHeader = (name: string): string | null => {', () => {
      code.line("if (headers instanceof Headers) return headers.get(name);");
      code.line('return headers[name] ?? headers[name.toLowerCase()] ?? null;');
    });
    code.line();

    code.comment('Extract JWT from Authorization header');
    code.line("const authHeader = getHeader('Authorization');");
    code.block("if (authHeader?.startsWith('Bearer ')) {", () => {
      code.line('const token = authHeader.slice(7);');
      code.line('const payload = decodeJwtPayload(token);');
      code.block('if (payload) {', () => {
        code.line("ctx.userId = payload.sub as string ?? payload.userId as string;");
        code.line("ctx.role = payload.role as string ?? payload.user_role as string;");
        code.line();
        code.comment('Extract other common JWT claims');
        code.line("if (payload.tenant_id) ctx.tenantId = payload.tenant_id as string;");
        code.line("if (payload.org_id) ctx.orgId = payload.org_id as string;");
      });
    });
    code.line();

    // Extract custom headers
    if (customHeaders.length > 0) {
      code.comment('Extract custom headers');
      for (const header of customHeaders) {
        const key = headerToContextKey(header);
        code.line(`const ${key}Header = getHeader('${header}');`);
        code.line(`if (${key}Header) ctx.${key} = ${key}Header;`);
      }
      code.line();
    }

    code.line('return ctx;');
  });
  code.line();
}

/**
 * Generate middleware handler type
 */
function generateMiddlewareHandlerType(code: CodeBuilder, target: string): void {
  code.multiDocComment([
    'Middleware handler function type.',
    'Can modify context or return early with a Response.',
  ]);

  switch (target) {
    case 'msw':
      code.line('export type MiddlewareHandler = (');
      code.line('  ctx: MiddlewareContext,');
      code.line('  request: Request');
      code.line(') => Promise<MiddlewareContext | Response>;');
      break;
    case 'nextjs':
      code.line('export type MiddlewareHandler = (');
      code.line('  ctx: MiddlewareContext,');
      code.line('  request: NextRequest');
      code.line(') => Promise<MiddlewareContext | NextResponse>;');
      break;
    case 'express':
      code.line('export type MiddlewareHandler = (');
      code.line('  ctx: MiddlewareContext,');
      code.line('  req: Request,');
      code.line('  res: Response');
      code.line(') => Promise<MiddlewareContext | void>;');
      break;
    case 'supabase-edge':
      code.line('export type MiddlewareHandler = (');
      code.line('  ctx: MiddlewareContext,');
      code.line('  request: Request');
      code.line(') => Promise<MiddlewareContext | Response>;');
      break;
  }
  code.line();
}

/**
 * Generate withMiddleware wrapper function
 */
function generateWithMiddlewareFunction(code: CodeBuilder, target: string): void {
  code.multiDocComment([
    'Run middleware chain and execute handler.',
    'Extracts context from headers, runs middleware, passes context to handler.',
    '',
    '@param middleware - Array of middleware handlers to run',
    '@param request - The incoming request',
    '@param handler - Final handler function that receives the context',
    '@returns Response from middleware or handler',
  ]);

  switch (target) {
    case 'msw':
      generateMswWithMiddleware(code);
      break;
    case 'nextjs':
      generateNextjsWithMiddleware(code);
      break;
    case 'express':
      generateExpressWithMiddleware(code);
      break;
    case 'supabase-edge':
      generateEdgeWithMiddleware(code);
      break;
  }
}

function generateMswWithMiddleware(code: CodeBuilder): void {
  code.block('export async function withMiddleware(', () => {
    code.line('middleware: MiddlewareHandler[],');
    code.line('request: Request,');
    code.line('handler: (ctx: MiddlewareContext) => Promise<Response>');
  }, '): Promise<Response> {');
  code.indent();

  code.comment('Extract initial context from headers');
  code.line('let ctx = extractContextFromHeaders(request.headers);');
  code.line();

  code.comment('Run middleware chain');
  code.block('for (const mw of middleware) {', () => {
    code.block('try {', () => {
      code.line('const result = await mw(ctx, request);');
      code.block('if (result instanceof Response) {', () => {
        code.comment('Middleware returned early (e.g., 401, 403)');
        code.line('return result;');
      });
      code.comment('Middleware returned updated context');
      code.line('ctx = result;');
    }, '} catch (error) {');
    code.indent();
    code.comment('Handle middleware errors');
    code.line('if (error instanceof AuthError) {');
    code.line("  return HttpResponse.json({ error: error.message }, { status: 401 });");
    code.line('}');
    code.line('if (error instanceof ForbiddenError) {');
    code.line("  return HttpResponse.json({ error: error.message }, { status: 403 });");
    code.line('}');
    code.line('throw error;');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Run handler with final context');
  code.block('try {', () => {
    code.line('return await handler(ctx);');
  }, '} catch (error) {');
  code.indent();
  code.comment('Handle service errors');
  code.line("if (error instanceof Error && 'status' in error) {");
  code.line('  const status = (error as { status: number }).status;');
  code.line('  return HttpResponse.json({ error: error.message }, { status });');
  code.line('}');
  code.line('throw error;');
  code.dedent();
  code.line('}');

  code.dedent();
  code.line('}');
  code.line();
}

function generateNextjsWithMiddleware(code: CodeBuilder): void {
  code.block('export async function withMiddleware(', () => {
    code.line('middleware: MiddlewareHandler[],');
    code.line('request: NextRequest,');
    code.line('handler: (ctx: MiddlewareContext) => Promise<NextResponse>');
  }, '): Promise<NextResponse> {');
  code.indent();

  code.comment('Extract initial context from headers');
  code.line('let ctx = extractContextFromHeaders(request.headers);');
  code.line();

  code.comment('Run middleware chain');
  code.block('for (const mw of middleware) {', () => {
    code.block('try {', () => {
      code.line('const result = await mw(ctx, request);');
      code.block('if (result instanceof NextResponse) {', () => {
        code.comment('Middleware returned early (e.g., 401, 403)');
        code.line('return result;');
      });
      code.comment('Middleware returned updated context');
      code.line('ctx = result;');
    }, '} catch (error) {');
    code.indent();
    code.comment('Handle middleware errors');
    code.line('if (error instanceof AuthError) {');
    code.line("  return NextResponse.json({ error: error.message }, { status: 401 });");
    code.line('}');
    code.line('if (error instanceof ForbiddenError) {');
    code.line("  return NextResponse.json({ error: error.message }, { status: 403 });");
    code.line('}');
    code.line('throw error;');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Run handler with final context');
  code.block('try {', () => {
    code.line('return await handler(ctx);');
  }, '} catch (error) {');
  code.indent();
  code.comment('Handle service errors');
  code.line("if (error instanceof Error && 'status' in error) {");
  code.line('  const status = (error as { status: number }).status;');
  code.line('  return NextResponse.json({ error: error.message }, { status });');
  code.line('}');
  code.line('throw error;');
  code.dedent();
  code.line('}');

  code.dedent();
  code.line('}');
  code.line();
}

function generateExpressWithMiddleware(code: CodeBuilder): void {
  code.block('export async function withMiddleware(', () => {
    code.line('middleware: MiddlewareHandler[],');
    code.line('req: Request,');
    code.line('res: Response,');
    code.line('handler: (ctx: MiddlewareContext) => Promise<void>');
  }, '): Promise<void> {');
  code.indent();

  code.comment('Extract initial context from headers');
  code.line('let ctx = extractContextFromHeaders(req.headers as Record<string, string>);');
  code.line();

  code.comment('Run middleware chain');
  code.block('for (const mw of middleware) {', () => {
    code.block('try {', () => {
      code.line('const result = await mw(ctx, req, res);');
      code.block('if (result === undefined && res.headersSent) {', () => {
        code.comment('Middleware already sent response');
        code.line('return;');
      });
      code.block('if (result !== undefined) {', () => {
        code.comment('Middleware returned updated context');
        code.line('ctx = result;');
      });
    }, '} catch (error) {');
    code.indent();
    code.comment('Handle middleware errors');
    code.line('if (error instanceof AuthError) {');
    code.line("  res.status(401).json({ error: error.message });");
    code.line('  return;');
    code.line('}');
    code.line('if (error instanceof ForbiddenError) {');
    code.line("  res.status(403).json({ error: error.message });");
    code.line('  return;');
    code.line('}');
    code.line('throw error;');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Run handler with final context');
  code.block('try {', () => {
    code.line('await handler(ctx);');
  }, '} catch (error) {');
  code.indent();
  code.comment('Handle service errors');
  code.line("if (error instanceof Error && 'status' in error) {");
  code.line('  const status = (error as { status: number }).status;');
  code.line("  res.status(status).json({ error: error.message });");
  code.line('  return;');
  code.line('}');
  code.line('throw error;');
  code.dedent();
  code.line('}');

  code.dedent();
  code.line('}');
  code.line();
}

function generateEdgeWithMiddleware(code: CodeBuilder): void {
  code.block('export async function withMiddleware(', () => {
    code.line('middleware: MiddlewareHandler[],');
    code.line('request: Request,');
    code.line('handler: (ctx: MiddlewareContext) => Promise<Response>');
  }, '): Promise<Response> {');
  code.indent();

  code.comment('Extract initial context from headers');
  code.line('let ctx = extractContextFromHeaders(request.headers);');
  code.line();

  code.comment('Run middleware chain');
  code.block('for (const mw of middleware) {', () => {
    code.block('try {', () => {
      code.line('const result = await mw(ctx, request);');
      code.block('if (result instanceof Response) {', () => {
        code.comment('Middleware returned early (e.g., 401, 403)');
        code.line('return result;');
      });
      code.comment('Middleware returned updated context');
      code.line('ctx = result;');
    }, '} catch (error) {');
    code.indent();
    code.comment('Handle middleware errors');
    code.line('if (error instanceof AuthError) {');
    code.line("  return new Response(JSON.stringify({ error: error.message }), {");
    code.line('    status: 401,');
    code.line("    headers: { 'Content-Type': 'application/json' },");
    code.line('  });');
    code.line('}');
    code.line('if (error instanceof ForbiddenError) {');
    code.line("  return new Response(JSON.stringify({ error: error.message }), {");
    code.line('    status: 403,');
    code.line("    headers: { 'Content-Type': 'application/json' },");
    code.line('  });');
    code.line('}');
    code.line('throw error;');
    code.dedent();
    code.line('}');
  });
  code.line();

  code.comment('Run handler with final context');
  code.block('try {', () => {
    code.line('return await handler(ctx);');
  }, '} catch (error) {');
  code.indent();
  code.comment('Handle service errors');
  code.line("if (error instanceof Error && 'status' in error) {");
  code.line('  const status = (error as { status: number }).status;');
  code.line("  return new Response(JSON.stringify({ error: error.message }), {");
  code.line('    status,');
  code.line("    headers: { 'Content-Type': 'application/json' },");
  code.line('  });');
  code.line('}');
  code.line('throw error;');
  code.dedent();
  code.line('}');

  code.dedent();
  code.line('}');
  code.line();
}

/**
 * Generate middleware resolution helper
 */
function generateMiddlewareResolution(code: CodeBuilder, schemas: AnalyzedSchema[]): void {
  // Collect all middleware configs from schemas
  const entityConfigs = new Map<string, {
    default: AnalyzedMiddlewareRef[];
    perOperation: AnalyzedEndpointMiddleware;
  }>();

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    entityConfigs.set(schema.name, {
      default: schema.middleware ?? [],
      perOperation: schema.endpointMiddleware ?? {},
    });
  }

  code.multiDocComment([
    'Operation type for middleware resolution',
  ]);
  code.line("export type Operation = 'list' | 'get' | 'create' | 'update' | 'delete';");
  code.line();

  code.multiDocComment([
    'Get middleware handlers for a specific entity and operation.',
    'Checks for per-operation overrides, falls back to default middleware.',
    '',
    '@param entity - Entity name (e.g., "user")',
    '@param operation - CRUD operation',
    '@returns Array of middleware handlers to run',
  ]);
  code.block('export function getMiddleware(entity: string, operation: Operation): MiddlewareHandler[] {', () => {
    code.comment('Look up entity-specific middleware configuration');
    code.line('const config = middlewareConfig[entity];');
    code.line('if (!config) return [];');
    code.line();

    code.comment('Check for per-operation override');
    code.line('const override = config.operations[operation];');
    code.block('if (override !== undefined) {', () => {
      code.comment('Explicit override (could be empty array for public endpoints)');
      code.line('return override;');
    });
    code.line();

    code.comment('Fall back to default middleware');
    code.line('return config.default;');
  });
  code.line();

  // Generate middleware configuration map
  code.comment('Entity middleware configuration (generated from schema definitions)');
  code.block('const middlewareConfig: Record<string, {', () => {
    code.line('default: MiddlewareHandler[];');
    code.line('operations: Partial<Record<Operation, MiddlewareHandler[]>>;');
  }, '}> = {');
  code.indent();

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    const config = entityConfigs.get(schema.name)!;
    const hasDefault = config.default.length > 0;
    const hasOperations = Object.keys(config.perOperation).some(
      (op) => config.perOperation[op as keyof AnalyzedEndpointMiddleware]
    );

    code.block(`${schema.name}: {`, () => {
      code.line(`default: [], // TODO: Wire up ${hasDefault ? 'defined' : 'no'} default middleware`);
      code.block('operations: {', () => {
        if (hasOperations) {
          for (const op of ['list', 'get', 'create', 'update', 'delete'] as const) {
            const opMiddleware = config.perOperation[op];
            if (opMiddleware && opMiddleware.length > 0) {
              code.line(`${op}: [], // TODO: Wire up ${opMiddleware.length} middleware`);
            }
          }
        }
        code.comment('Empty means use default');
      }, '},');
    }, '},');
  }

  code.dedent();
  code.line('};');
}

/**
 * Convert header name to context key
 * e.g., "X-Tenant-ID" -> "tenantId"
 */
function headerToContextKey(header: string): string {
  return header
    .replace(/^X-/i, '')
    .replace(/-([a-z])/gi, (_, char) => char.toUpperCase())
    .replace(/^([A-Z])/, (char) => char.toLowerCase());
}
