/**
 * Firebase Security Rules generator
 *
 * Generates Firestore security rules from Schemock RLS configuration
 *
 * @module cli/generators/firebase/rules
 * @category CLI
 */

import type { AnalyzedSchema, FirebaseAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Firestore security rules from schemas
 *
 * @param schemas - Analyzed schemas with RLS config
 * @param config - Firebase adapter configuration
 * @returns Generated Firestore rules as string
 */
export function generateFirebaseRules(
  schemas: AnalyzedSchema[],
  config: FirebaseAdapterConfig
): string {
  const code = new CodeBuilder();

  code.raw('// Generated by Schemock - Firestore Security Rules');
  code.raw('// Copy this to your firestore.rules file');
  code.raw('');
  code.raw('rules_version = \'2\';');
  code.raw('');

  code.raw('service cloud.firestore {');
  code.raw('  match /databases/{database}/documents {');
  code.raw('');

  // Helper functions
  generateHelperFunctions(code);

  // Generate rules for each collection
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateCollectionRules(code, schema, config);
  }

  code.raw('  }');
  code.raw('}');

  return code.toString();
}

/**
 * Generate helper functions for rules
 */
function generateHelperFunctions(code: CodeBuilder): void {
  code.raw('    // Helper functions');
  code.raw('    function isSignedIn() {');
  code.raw('      return request.auth != null;');
  code.raw('    }');
  code.raw('');
  code.raw('    function isOwner(userId) {');
  code.raw('      return isSignedIn() && request.auth.uid == userId;');
  code.raw('    }');
  code.raw('');
  code.raw('    function hasRole(role) {');
  code.raw('      return isSignedIn() && request.auth.token.role == role;');
  code.raw('    }');
  code.raw('');
  code.raw('    function hasAnyRole(roles) {');
  code.raw('      return isSignedIn() && request.auth.token.role in roles;');
  code.raw('    }');
  code.raw('');
  code.raw('    function isInOrg(orgId) {');
  code.raw('      return isSignedIn() && request.auth.token.org_id == orgId;');
  code.raw('    }');
  code.raw('');
}

/**
 * Generate rules for a single collection
 */
function generateCollectionRules(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: FirebaseAdapterConfig
): void {
  const collectionName = config.collectionMap?.[schema.name] ?? schema.pluralName;
  const { rls } = schema;

  code.raw(`    // ${schema.pascalName} collection`);
  code.raw(`    match /${collectionName}/{docId} {`);

  if (!rls.enabled) {
    // Default: allow authenticated users
    code.raw('      // No RLS configured - default to authenticated access');
    code.raw('      allow read, write: if isSignedIn();');
  } else {
    // Generate read rule (covers get and list)
    const readCondition = generateCondition(rls, 'select', schema);
    code.raw(`      allow read: if ${readCondition};`);
    code.raw('');

    // Generate create rule
    const createCondition = generateCondition(rls, 'insert', schema);
    code.raw(`      allow create: if ${createCondition};`);
    code.raw('');

    // Generate update rule
    const updateCondition = generateCondition(rls, 'update', schema);
    code.raw(`      allow update: if ${updateCondition};`);
    code.raw('');

    // Generate delete rule
    const deleteCondition = generateCondition(rls, 'delete', schema);
    code.raw(`      allow delete: if ${deleteCondition};`);
  }

  code.raw('    }');
  code.raw('');
}

/**
 * Generate a condition expression for an operation (generic context-based)
 */
function generateCondition(
  rls: AnalyzedSchema['rls'],
  operation: 'select' | 'insert' | 'update' | 'delete',
  schema: AnalyzedSchema
): string {
  const conditions: string[] = [];

  // Bypass conditions check
  for (const bypass of rls.bypass) {
    const rolesArray = bypass.values.map((r) => `'${r}'`).join(', ');
    // Check against auth token custom claims
    conditions.push(`request.auth.token.${bypass.contextKey} in [${rolesArray}]`);
  }

  // Scope mappings
  for (const mapping of rls.scope) {
    if (operation === 'insert') {
      // For create, check request.resource.data
      if (mapping.contextKey === 'userId') {
        conditions.push(`request.resource.data.${mapping.field} == request.auth.uid`);
      } else {
        conditions.push(`request.resource.data.${mapping.field} == request.auth.token.${mapping.contextKey}`);
      }
    } else {
      // For read/update/delete, check existing resource
      if (mapping.contextKey === 'userId') {
        conditions.push(`resource.data.${mapping.field} == request.auth.uid`);
      } else {
        conditions.push(`resource.data.${mapping.field} == request.auth.token.${mapping.contextKey}`);
      }
    }
  }

  // If no specific conditions, require authentication
  if (conditions.length === 0) {
    return 'isSignedIn()';
  }

  // Join with OR for bypass + specific conditions
  if (rls.bypass.length > 0 && conditions.length > rls.bypass.length) {
    // First N conditions are bypass, rest are specific rules
    const bypassConditions = conditions.slice(0, rls.bypass.length);
    const scopeConditions = conditions.slice(rls.bypass.length);
    return `(${bypassConditions.join(' || ')}) || (${scopeConditions.join(' && ')})`;
  }

  return conditions.join(' && ');
}

/**
 * Generate TypeScript helper with rules as string export
 */
export function generateFirebaseRulesHelper(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Firebase Security Rules Helper');
  code.line();

  code.comment('Export rules as string for programmatic use');
  code.block('export const firestoreRules = `', () => {
    // Just add a placeholder - actual rules should be from generateFirebaseRules
    code.raw('// See firestore.rules file for generated rules');
  });
  code.line('`;');
  code.line();

  code.comment('Generic context type for client-side RLS checks');
  code.block('export interface RLSContext {', () => {
    code.line('[key: string]: unknown;');
  }, '}');
  code.line();

  code.comment('Helper to check if context can perform an action (for client-side validation)');

  // Generate client-side RLS check functions
  for (const schema of schemas) {
    if (schema.isJunctionTable || !schema.rls.enabled) continue;

    const { pascalName, rls } = schema;

    code.block(`export function can${pascalName}(`, () => {
      code.line('action: "read" | "create" | "update" | "delete",');
      code.line('ctx: RLSContext | null,');
      code.line('resource?: Record<string, unknown>,');
    });
    code.line('): boolean {');
    code.indent();

    // Bypass conditions
    for (const bypass of rls.bypass) {
      const values = bypass.values.map((v) => `'${v}'`).join(', ');
      code.line(`if (ctx && [${values}].includes(ctx.${bypass.contextKey} as string)) return true;`);
    }

    code.line('if (!ctx) return false;');
    code.line();

    // Scope checks
    for (const mapping of rls.scope) {
      code.line(`// Check ${mapping.field} matches context.${mapping.contextKey}`);
      code.line(`if (resource && resource.${mapping.field} !== ctx.${mapping.contextKey}) return false;`);
    }

    code.line('return true;');
    code.dedent();
    code.line('}');
    code.line();
  }

  return code.toString();
}
