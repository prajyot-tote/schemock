/**
 * Firebase client generator
 *
 * @module cli/generators/firebase/client
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation, FirebaseAdapterConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate Firebase API client
 *
 * @param schemas - Analyzed schemas
 * @param config - Firebase adapter configuration
 * @returns Generated TypeScript code
 */
export function generateFirebaseClient(schemas: AnalyzedSchema[], config: FirebaseAdapterConfig): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line('import {');
  code.line('  collection,');
  code.line('  doc,');
  code.line('  getDoc,');
  code.line('  getDocs,');
  code.line('  addDoc,');
  code.line('  updateDoc,');
  code.line('  deleteDoc,');
  code.line('  query,');
  code.line('  where,');
  code.line('  orderBy,');
  code.line('  limit as fbLimit,');
  code.line("} from 'firebase/firestore';");
  code.line("import type * as Types from './types';");
  code.line();

  code.comment('Import your Firebase instance');
  code.line("import { db as firestore } from '../lib/firebase';");
  code.line();

  code.block('export const api = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      generateFirebaseEntityApi(code, schema, config, schemas);
    }
  }, '};');

  return code.toString();
}

/**
 * Generate Firebase API methods for a single entity
 */
function generateFirebaseEntityApi(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  config: FirebaseAdapterConfig,
  allSchemas: AnalyzedSchema[]
): void {
  const { name, pascalName, relations } = schema;
  const collectionName = config.collectionMap?.[name] ?? schema.pluralName;
  const hasRelations = relations.length > 0;
  const includeType = hasRelations ? `Types.${pascalName}Include` : 'never';

  // Create schema map for looking up target collections
  const schemaMap = new Map(allSchemas.map((s) => [s.name, s]));

  // Helper to get collection name for a target schema
  const getTargetCollection = (targetName: string): string => {
    const targetSchema = schemaMap.get(targetName);
    return config.collectionMap?.[targetName] ?? targetSchema?.pluralName ?? targetName + 's';
  };

  code.block(`${name}: {`, () => {
    // LIST
    code.block(
      `list: async (options?: Types.QueryOptions<Types.${pascalName}Filter, ${includeType}>): Promise<Types.ListResponse<Types.${pascalName}>> => {`,
      () => {
        code.line(`let q = query(collection(firestore, '${collectionName}'));`);
        code.line();

        // Filters (Firebase supports many operators)
        code.block('if (options?.where) {', () => {
          code.block('for (const [key, value] of Object.entries(options.where)) {', () => {
            code.block('if (typeof value === "object" && value !== null) {', () => {
              code.line('const f = value as Record<string, unknown>;');
              code.line("if ('equals' in f) q = query(q, where(key, '==', f.equals));");
              code.line("if ('not' in f) q = query(q, where(key, '!=', f.not));");
              code.line("if ('gt' in f) q = query(q, where(key, '>', f.gt));");
              code.line("if ('gte' in f) q = query(q, where(key, '>=', f.gte));");
              code.line("if ('lt' in f) q = query(q, where(key, '<', f.lt));");
              code.line("if ('lte' in f) q = query(q, where(key, '<=', f.lte));");
              code.line("if ('in' in f) q = query(q, where(key, 'in', f.in));");
              code.line("if ('notIn' in f) q = query(q, where(key, 'not-in', f.notIn));");
              code.comment('Note: contains/startsWith/endsWith require compound indexes in Firebase');
              code.line("if ('contains' in f) q = query(q, where(key, '>=', f.contains), where(key, '<=', f.contains + '\\uf8ff'));");
              code.line("if ('startsWith' in f) q = query(q, where(key, '>=', f.startsWith), where(key, '<=', f.startsWith + '\\uf8ff'));");
            }, '} else {');
            code.indent();
            code.line("q = query(q, where(key, '==', value));");
            code.dedent();
            code.line('}');
          });
        });
        code.line();

        // Ordering
        code.block('if (options?.orderBy) {', () => {
          code.block('for (const [field, dir] of Object.entries(options.orderBy)) {', () => {
            code.line("q = query(q, orderBy(field, dir as 'asc' | 'desc'));");
          });
        });
        code.line();

        // Pagination (Firebase doesn't support offset natively, so we fetch extra and slice)
        code.line('const queryLimit = options?.limit ?? 20;');
        code.line('const queryOffset = options?.offset ?? 0;');
        code.comment('Fetch limit + offset to enable client-side offset');
        code.line('q = query(q, fbLimit(queryLimit + queryOffset));');
        code.line();

        code.line('const snapshot = await getDocs(q);');
        code.line(`let allItems = snapshot.docs.map(d => ({ id: d.id, ...d.data() })) as Types.${pascalName}[];`);
        code.line('const total = allItems.length;');
        code.comment('Apply client-side offset');
        code.line('let items = allItems.slice(queryOffset, queryOffset + queryLimit);');
        code.line();

        // Load relations
        if (hasRelations) {
          code.block('if (options?.include?.length) {', () => {
            code.block('items = await Promise.all(items.map(async (item) => {', () => {
              code.line('const result = { ...item } as Record<string, unknown>;');

              for (const rel of relations) {
                code.block(`if (options.include!.includes('${rel.name}')) {`, () => {
                  generateFirebaseRelationLoad(code, schema, rel, config);
                });
              }

              code.line(`return result as Types.${pascalName};`);
            }, '}));');
          });
        }
        code.line();

        code.line('return {');
        code.line('  data: items,');
        code.line('  meta: { total, limit: queryLimit, offset: queryOffset, hasMore: queryOffset + queryLimit < total },');
        code.line('};');
      },
      '},'
    );
    code.line();

    // GET
    code.block(`get: async (id: string, options?: { include?: ${includeType}[] }): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`const docRef = doc(firestore, '${collectionName}', id);`);
      code.line('const snapshot = await getDoc(docRef);');
      code.line(`if (!snapshot.exists()) throw new Error('${pascalName} not found');`);
      code.line(`let item = { id: snapshot.id, ...snapshot.data() } as Types.${pascalName};`);

      if (hasRelations) {
        code.line();
        code.block('if (options?.include?.length) {', () => {
          code.line('const result = { ...item } as Record<string, unknown>;');

          for (const rel of relations) {
            code.block(`if (options.include.includes('${rel.name}')) {`, () => {
              generateFirebaseRelationLoad(code, schema, rel, config);
            });
          }

          code.line(`item = result as Types.${pascalName};`);
        });
      }

      code.line();
      code.line('return { data: item };');
    }, '},');
    code.line();

    // CREATE (with nested relation support)
    generateFirebaseCreateMethod(code, schema, collectionName, config, allSchemas);
    code.line();

    // UPDATE
    code.block(`update: async (id: string, input: Types.${pascalName}Update): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
      code.line(`const docRef = doc(firestore, '${collectionName}', id);`);
      code.line('await updateDoc(docRef, { ...input, updatedAt: new Date() });');
      code.line('const snapshot = await getDoc(docRef);');
      code.line(`return { data: { id: snapshot.id, ...snapshot.data() } as Types.${pascalName} };`);
    }, '},');
    code.line();

    // DELETE
    code.block('delete: async (id: string): Promise<void> => {', () => {
      code.line(`await deleteDoc(doc(firestore, '${collectionName}', id));`);
    }, '},');
  }, '},');
  code.line();
}

/**
 * Generate Firebase create method with nested relation support
 */
function generateFirebaseCreateMethod(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  collectionName: string,
  config: FirebaseAdapterConfig,
  allSchemas: AnalyzedSchema[]
): void {
  const { pascalName, relations } = schema;
  const nestedRels = relations.filter((r) => r.type === 'hasMany' || r.type === 'hasOne');

  // Create schema map for looking up target collections
  const schemaMap = new Map(allSchemas.map((s) => [s.name, s]));

  // Helper to get collection name for a target schema
  const getTargetCollection = (targetName: string): string => {
    const targetSchema = schemaMap.get(targetName);
    return config.collectionMap?.[targetName] ?? targetSchema?.pluralName ?? targetName + 's';
  };

  code.block(`create: async (input: Types.${pascalName}Create): Promise<Types.ItemResponse<Types.${pascalName}>> => {`, () => {
    if (nestedRels.length > 0) {
      const relNames = nestedRels.map((r) => r.name).join(', ');
      code.line(`const { ${relNames}, ...data } = input;`);
      code.line('const withTimestamps = { ...data, createdAt: new Date(), updatedAt: new Date() };');
      code.line(`const docRef = await addDoc(collection(firestore, '${collectionName}'), withTimestamps);`);
      code.line(`const item = { id: docRef.id, ...withTimestamps } as Types.${pascalName};`);
      code.line();

      for (const rel of nestedRels) {
        const targetCollection = getTargetCollection(rel.target);
        code.block(`if (${rel.name}) {`, () => {
          if (rel.type === 'hasMany') {
            code.block(`for (const nested of ${rel.name}) {`, () => {
              code.line(`const nestedData = { ...nested, ${rel.foreignKey}: item.id, createdAt: new Date(), updatedAt: new Date() };`);
              code.line(`await addDoc(collection(firestore, '${targetCollection}'), nestedData);`);
            });
          } else {
            code.line(`const nestedData = { ...${rel.name}, ${rel.foreignKey}: item.id, createdAt: new Date(), updatedAt: new Date() };`);
            code.line(`await addDoc(collection(firestore, '${targetCollection}'), nestedData);`);
          }
        });
      }

      code.line();
      code.line('return { data: item };');
    } else {
      code.line('const data = { ...input, createdAt: new Date(), updatedAt: new Date() };');
      code.line(`const docRef = await addDoc(collection(firestore, '${collectionName}'), data);`);
      code.line(`return { data: { id: docRef.id, ...data } as Types.${pascalName} };`);
    }
  }, '},');
}

/**
 * Generate code to load a relation in Firebase
 */
function generateFirebaseRelationLoad(
  code: CodeBuilder,
  schema: AnalyzedSchema,
  rel: AnalyzedRelation,
  config: FirebaseAdapterConfig,
  allSchemas?: AnalyzedSchema[]
): void {
  // Create schema map for looking up target collections
  const schemaMap = allSchemas ? new Map(allSchemas.map((s) => [s.name, s])) : new Map();

  // Helper to get collection name for a target schema
  const getCollection = (targetName: string): string => {
    const targetSchema = schemaMap.get(targetName);
    return config.collectionMap?.[targetName] ?? targetSchema?.pluralName ?? targetName + 's';
  };

  const targetCollection = getCollection(rel.target);

  if (rel.type === 'hasMany') {
    code.line(`const ${rel.name}Query = query(`);
    code.line(`  collection(firestore, '${targetCollection}'),`);
    code.line(`  where('${rel.foreignKey}', '==', item.id)`);
    code.line(');');
    code.line(`const ${rel.name}Snapshot = await getDocs(${rel.name}Query);`);
    code.line(`result.${rel.name} = ${rel.name}Snapshot.docs.map(d => ({ id: d.id, ...d.data() }));`);
  } else if (rel.type === 'hasOne') {
    code.line(`const ${rel.name}Query = query(`);
    code.line(`  collection(firestore, '${targetCollection}'),`);
    code.line(`  where('${rel.foreignKey}', '==', item.id),`);
    code.line('  fbLimit(1)');
    code.line(');');
    code.line(`const ${rel.name}Snapshot = await getDocs(${rel.name}Query);`);
    code.line(`result.${rel.name} = ${rel.name}Snapshot.docs[0] ? { id: ${rel.name}Snapshot.docs[0].id, ...${rel.name}Snapshot.docs[0].data() } : null;`);
  } else if (rel.type === 'belongsTo') {
    code.line(`const ${rel.name}Ref = doc(firestore, '${targetCollection}', (item as Record<string, unknown>).${rel.localField} as string);`);
    code.line(`const ${rel.name}Snapshot = await getDoc(${rel.name}Ref);`);
    code.line(`result.${rel.name} = ${rel.name}Snapshot.exists() ? { id: ${rel.name}Snapshot.id, ...${rel.name}Snapshot.data() } : null;`);
  } else if (rel.type === 'manyToMany' && rel.through) {
    const throughCollection = getCollection(rel.through);
    // foreignKey is the FK on the junction table pointing to the source entity
    code.comment('Load manyToMany via junction collection');
    code.line(`const junctionQuery = query(`);
    code.line(`  collection(firestore, '${throughCollection}'),`);
    code.line(`  where('${rel.foreignKey}', '==', item.id)`);
    code.line(');');
    code.line(`const junctionSnapshot = await getDocs(junctionQuery);`);
    code.line(`const relatedIds = junctionSnapshot.docs.map(d => (d.data() as Record<string, unknown>).${rel.otherKey}) as string[];`);
    code.line();
    code.block('if (relatedIds.length > 0) {', () => {
      code.comment('Firebase in query limited to 10 items, batch if needed');
      code.line(`const ${rel.name}Results: unknown[] = [];`);
      code.block('for (let i = 0; i < relatedIds.length; i += 10) {', () => {
        code.line('const batch = relatedIds.slice(i, i + 10);');
        code.line(`const batchQuery = query(`);
        code.line(`  collection(firestore, '${targetCollection}'),`);
        code.line("  where('__name__', 'in', batch)");
        code.line(');');
        code.line('const batchSnapshot = await getDocs(batchQuery);');
        code.line(`${rel.name}Results.push(...batchSnapshot.docs.map(d => ({ id: d.id, ...d.data() })));`);
      });
      code.line(`result.${rel.name} = ${rel.name}Results;`);
    }, '} else {');
    code.indent();
    code.line(`result.${rel.name} = [];`);
    code.dedent();
    code.line('}');
  }
}
