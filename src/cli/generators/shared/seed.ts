/**
 * Unified seed utilities generator
 *
 * Generates seed, reset, and getAll utilities using an internal client with
 * RLS bypass enabled. This allows seed operations to work without user context
 * (e.g., creating first superadmin, bootstrap data) while keeping the public
 * api.* client RLS-protected for normal developers.
 *
 * @module cli/generators/shared/seed
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedField } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import { toSafePropertyName } from '../../utils/pluralize';

/**
 * Configuration for seed generation
 */
export interface SeedConfig {
  /** Default seed counts per entity */
  seed?: Record<string, number>;
  /** Faker seed for reproducible data */
  fakerSeed?: number;
}

/**
 * Generate seed and reset utilities using an internal client with RLS bypass
 *
 * The generated code uses `_createInternalClient({ _bypassRLS: true })` to
 * bypass RLS checks. This is intentional for seed operations that need to
 * create data without user context (e.g., bootstrap operations, superadmin setup).
 *
 * @param schemas - Analyzed schemas (topologically sorted)
 * @param config - Seed configuration
 * @returns Generated TypeScript code
 */
export function generateUnifiedSeed(schemas: AnalyzedSchema[], config: SeedConfig = {}): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line("import { _createInternalClient } from './client';");
  code.line("import { faker } from '@faker-js/faker';");
  code.line();

  // Create internal client with RLS bypass for seed operations
  code.comment('Internal client with RLS bypass for seed operations');
  code.line('const _seedClient = _createInternalClient({ _bypassRLS: true });');
  code.line();

  // Set faker seed
  if (config.fakerSeed !== undefined) {
    code.line(`faker.seed(${config.fakerSeed});`);
  } else {
    code.line('faker.seed(Date.now());');
  }
  code.line();

  // Type for seed counts
  code.block('export interface SeedCounts {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      code.line(`${safeName}?: number;`);
    }
  });
  code.line();

  // Default counts
  code.block('const defaultCounts: Required<SeedCounts> = {', () => {
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      const count = config.seed?.[schema.name] ?? 10;
      code.line(`${safeName}: ${count},`);
    }
  }, '};');
  code.line();

  // Helper to pick random item from array
  code.block('function pickRandom<T>(arr: T[]): T | undefined {', () => {
    code.line('if (arr.length === 0) return undefined;');
    code.line('return arr[Math.floor(Math.random() * arr.length)];');
  });
  code.line();

  // Generate entity data generator functions
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityGenerator(code, schema);
    code.line();
  }

  // Seed function - creates relational data with valid foreign keys
  code.multiDocComment([
    'Seed the database with fake data.',
    '',
    'Creates entities in dependency order to ensure valid foreign key references.',
    'Uses an internal client with RLS bypass enabled for bootstrap operations.',
    '',
    '@param counts - Optional count overrides per entity',
    '',
    '@example',
    '```typescript',
    '// Seed with defaults',
    'await seed();',
    '',
    '// Seed with custom counts',
    'await seed({ user: 5, post: 20 });',
    '```',
  ]);
  code.block('export async function seed(counts: SeedCounts = {}): Promise<void> {', () => {
    code.line('const merged = { ...defaultCounts, ...counts };');
    code.line();
    code.comment('Track created entity IDs for foreign key references');
    code.line('const ids: Record<string, string[]> = {};');
    code.line();

    // Generate in dependency order (schemas are already sorted)
    for (const schema of schemas) {
      if (schema.isJunctionTable) continue;

      const safeName = toSafePropertyName(schema.name);

      // Find FK fields from belongsTo relations (these need valid parent IDs)
      const belongsToRels = schema.relations.filter((r) => r.type === 'belongsTo');
      // Map: localField -> target entity name
      const fkFields = belongsToRels.map((r) => ({
        fieldName: r.localField || r.foreignKey,
        target: toSafePropertyName(r.target),
        nullable: schema.fields.find((f) => f.name === (r.localField || r.foreignKey))?.nullable ?? false,
      }));

      code.line(`ids.${safeName} = [];`);
      code.block(`for (let i = 0; i < merged.${safeName}; i++) {`, () => {
        code.line(`const data = generate${schema.pascalName}();`);

        // Set FK values from parent entities
        if (fkFields.length > 0) {
          for (const fk of fkFields) {
            if (fk.nullable) {
              // Nullable FK: sometimes null, sometimes valid ID
              code.line(`data.${fk.fieldName} = Math.random() > 0.3 ? pickRandom(ids.${fk.target}) ?? null : null;`);
            } else {
              // Required FK: always use valid parent ID
              code.line(`data.${fk.fieldName} = pickRandom(ids.${fk.target})!;`);
            }
          }
        }

        code.line();
        code.line(`const result = await _seedClient.${safeName}.create(data as Parameters<typeof _seedClient.${safeName}.create>[0]);`);
        code.line(`ids.${safeName}.push(result.data.id);`);
      });
      code.line();
    }

    code.line("console.log('✓ Database seeded');");
  });
  code.line();

  // Reset function - delete all data
  code.multiDocComment([
    'Reset the database by deleting all data.',
    '',
    'Deletes entities in reverse dependency order to respect foreign key constraints.',
    '',
    '@example',
    '```typescript',
    'await reset();',
    '```',
  ]);
  code.block('export async function reset(): Promise<void> {', () => {
    // Delete in reverse order (dependents first)
    for (const schema of [...schemas].reverse()) {
      if (schema.isJunctionTable) continue;
      const safeName = toSafePropertyName(schema.name);
      code.line(`const ${safeName}List = await _seedClient.${safeName}.list({ limit: 10000 });`);
      code.block(`for (const item of ${safeName}List.data) {`, () => {
        code.line(`await _seedClient.${safeName}.delete(item.id);`);
      });
      code.line();
    }

    code.line("console.log('✓ Database reset');");
  });
  code.line();

  // Get all function (for debugging)
  code.multiDocComment([
    'Get all data from the database.',
    '',
    'Useful for debugging and testing.',
    '',
    '@returns Record of entity name to array of items',
    '',
    '@example',
    '```typescript',
    'const data = await getAll();',
    'console.log(data.user); // All users',
    '```',
  ]);
  code.block('export async function getAll(): Promise<Record<string, unknown[]>> {', () => {
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        const safeName = toSafePropertyName(schema.name);
        code.line(`${safeName}: (await _seedClient.${safeName}.list({ limit: 10000 })).data,`);
      }
    }, '};');
  });
  code.line();

  // Count function
  code.multiDocComment([
    'Get the count of each entity in the database.',
    '',
    '@returns Record of entity name to count',
    '',
    '@example',
    '```typescript',
    'const counts = await count();',
    'console.log(counts.user); // Number of users',
    '```',
  ]);
  code.block('export async function count(): Promise<Record<string, number>> {', () => {
    code.block('return {', () => {
      for (const schema of schemas) {
        if (schema.isJunctionTable) continue;
        const safeName = toSafePropertyName(schema.name);
        code.line(`${safeName}: (await _seedClient.${safeName}.list({ limit: 1 })).meta.total,`);
      }
    }, '};');
  });

  return code.toString();
}

/**
 * Generate a function that creates fake entity data
 */
function generateEntityGenerator(code: CodeBuilder, schema: AnalyzedSchema): void {
  // Build the return type shape for fields
  const fieldTypes: string[] = [];
  for (const field of schema.fields) {
    if (field.name === 'id') continue; // UUID auto-generated by DB/client
    if (field.readOnly) continue; // Skip readOnly fields (createdAt, updatedAt)
    if (field.isRef) {
      // FK fields - respect nullable property
      fieldTypes.push(`${field.name}: string${field.nullable ? ' | null' : ''}`);
    } else {
      fieldTypes.push(`${field.name}: ${field.tsType}${field.nullable ? ' | null' : ''}`);
    }
  }

  code.block(`function generate${schema.pascalName}(): { ${fieldTypes.join('; ')} } {`, () => {
    code.block('return {', () => {
      for (const field of schema.fields) {
        if (field.name === 'id') continue; // UUID auto-generated
        if (field.readOnly) continue; // Skip readOnly fields
        if (field.isRef) {
          // FK fields - placeholder, will be set by seed function
          if (field.nullable) {
            code.line(`${field.name}: null,`);
          } else {
            // Non-nullable FK: use empty string as placeholder (will be overwritten)
            code.line(`${field.name}: '',`);
          }
        } else {
          generateFieldValue(code, field);
        }
      }
    }, '};');
  });
}

/**
 * Generate faker call for a field
 */
function generateFieldValue(code: CodeBuilder, field: AnalyzedField): void {
  // Handle nullable fields
  if (field.nullable) {
    code.line(`${field.name}: Math.random() > 0.1 ? ${field.fakerCall} : null,`);
  } else {
    code.line(`${field.name}: ${field.fakerCall},`);
  }
}
