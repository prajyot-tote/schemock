/**
 * TypeScript types generator
 *
 * @module cli/generators/types
 * @category CLI
 */

import type { AnalyzedSchema, AnalyzedRelation } from '../types';
import { CodeBuilder } from '../utils/code-builder';
import { toPascalCase } from '../utils/pluralize';

/**
 * Generate TypeScript type definitions for all schemas
 *
 * @param schemas - Analyzed schemas
 * @returns Generated TypeScript code
 */
export function generateTypes(schemas: AnalyzedSchema[]): string {
  const code = new CodeBuilder();

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.comment('Regenerate with: npx schemock generate');
  code.line();

  // Generate types for each non-junction schema
  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;
    generateEntityTypes(code, schema, schemas);
  }

  // Generate common types
  generateCommonTypes(code);

  return code.toString();
}

/**
 * Generate types for a single entity
 */
function generateEntityTypes(code: CodeBuilder, schema: AnalyzedSchema, allSchemas: AnalyzedSchema[]): void {
  const { pascalName, fields, relations, computed, hasTimestamps } = schema;

  // ========== Main Entity Type ==========
  code.docComment(`${pascalName} entity`);
  code.block(`export interface ${pascalName} {`, () => {
    // Index signature for Record<string, unknown> compatibility
    code.line('[key: string]: unknown;');

    // Fields (includes timestamps if schema has timestamps: true)
    for (const field of fields) {
      const opt = field.nullable ? '?' : '';
      code.line(`${field.name}${opt}: ${field.tsType};`);
    }

    // Computed
    for (const comp of computed) {
      code.line(`${comp.name}: ${comp.tsType};`);
    }

    // Relations (optional - loaded on demand)
    for (const rel of relations) {
      const relType = rel.type === 'hasMany' || rel.type === 'manyToMany' ? `${rel.targetPascal}[]` : rel.targetPascal;
      code.line(`${rel.name}?: ${relType};`);
    }
  });
  code.line();

  // ========== With-Relation Types ==========
  for (const rel of relations) {
    const relType = rel.type === 'hasMany' || rel.type === 'manyToMany' ? `${rel.targetPascal}[]` : rel.targetPascal;
    const typeName = `${pascalName}With${toPascalCase(rel.name)}`;

    code.docComment(`${pascalName} with ${rel.name} loaded`);
    code.block(`export interface ${typeName} extends Omit<${pascalName}, '${rel.name}'> {`, () => {
      code.line(`${rel.name}: ${relType};`);
    });
    code.line();
  }

  // ========== Create Type ==========
  code.docComment(`Data for creating a ${pascalName}`);
  code.block(`export interface ${pascalName}Create {`, () => {
    for (const field of fields) {
      if (field.name === 'id' || field.readOnly) continue;
      const opt = field.nullable || field.hasDefault ? '?' : '';
      code.line(`${field.name}${opt}: ${field.tsType};`);
    }

    // Nested creates for hasMany/hasOne
    for (const rel of relations) {
      if (rel.type === 'hasMany') {
        code.line(`${rel.name}?: ${rel.targetPascal}Create[];`);
      } else if (rel.type === 'hasOne') {
        code.line(`${rel.name}?: ${rel.targetPascal}Create;`);
      }
    }
  });
  code.line();

  // ========== Update Type ==========
  code.docComment(`Data for updating a ${pascalName}`);
  code.block(`export interface ${pascalName}Update {`, () => {
    for (const field of fields) {
      if (field.name === 'id' || field.readOnly) continue;
      code.line(`${field.name}?: ${field.tsType};`);
    }
  });
  code.line();

  // ========== Filter Type ==========
  code.docComment(`Filter options for querying ${pascalName}`);
  code.block(`export interface ${pascalName}Filter {`, () => {
    // Index signature for compatibility with Record<string, unknown>
    code.line('[key: string]: unknown;');
    for (const field of fields) {
      code.line(`${field.name}?: ${field.tsType} | FieldFilter<${field.tsType}>;`);
    }
  });
  code.line();

  // ========== Include Type ==========
  if (relations.length > 0) {
    const relNames = relations.map((r) => `'${r.name}'`).join(' | ');
    code.docComment(`Relations that can be included when fetching ${pascalName}`);
    code.line(`export type ${pascalName}Include = ${relNames};`);
    code.line();
  }
}

/**
 * Generate common utility types
 */
function generateCommonTypes(code: CodeBuilder): void {
  // Field filter type
  code.docComment('Generic field filter for complex queries');
  code.block('export interface FieldFilter<T> {', () => {
    code.line('equals?: T;');
    code.line('not?: T;');
    code.line('in?: T[];');
    code.line('notIn?: T[];');
    code.line('lt?: T;');
    code.line('lte?: T;');
    code.line('gt?: T;');
    code.line('gte?: T;');
    code.line('contains?: string;');
    code.line('startsWith?: string;');
    code.line('endsWith?: string;');
    code.line('isNull?: boolean;');
  });
  code.line();

  // Query options
  code.docComment('Common query options');
  code.block('export interface QueryOptions<TFilter, TInclude extends string = never> {', () => {
    code.line('where?: TFilter;');
    code.line('include?: TInclude[];');
    code.line('orderBy?: Record<string, "asc" | "desc">;');
    code.line('limit?: number;');
    code.line('offset?: number;');
    code.line('cursor?: string;');
  });
  code.line();

  // List response
  code.docComment('Paginated list response');
  code.block('export interface ListResponse<T> {', () => {
    code.line('data: T[];');
    code.block('meta: {', () => {
      code.line('total: number;');
      code.line('limit: number;');
      code.line('offset: number;');
      code.line('hasMore: boolean;');
      code.line('nextCursor?: string;');
    });
  });
  code.line();

  // Item response
  code.docComment('Single item response');
  code.block('export interface ItemResponse<T> {', () => {
    code.line('data: T;');
  });
  code.line();
}
