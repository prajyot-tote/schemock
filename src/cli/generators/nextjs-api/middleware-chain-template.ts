/**
 * Next.js API Middleware Chain Template
 *
 * Generates a middleware chain file that coordinates all configured
 * middleware for Next.js API routes. Unlike Express, Next.js doesn't have
 * router.use(), so this provides a utility to run middleware in sequence.
 *
 * @module cli/generators/nextjs-api/middleware-chain-template
 * @category CLI
 */

import type {
  SchemockConfig,
  MiddlewareConfig,
  AnalyzedMiddleware,
  AuthMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
} from '../../types';

/**
 * Default middleware execution order
 */
const DEFAULT_MIDDLEWARE_ORDER = [
  'auth',
  'rateLimit',
  'logger',
  'context',
  'rls',
  'cache',
  'validation',
];

/**
 * Generate the middleware chain file for Next.js
 */
export function generateNextjsMiddlewareChain(
  config: SchemockConfig,
  customMiddleware: AnalyzedMiddleware[] = []
): string {
  const middleware = config.middleware ?? {};
  const enabledMiddleware = getEnabledMiddleware(middleware);
  const orderedMiddleware = orderMiddleware(enabledMiddleware, middleware.chain, customMiddleware);

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
    '',
  ];

  // Generate imports for each enabled middleware
  const imports = generateMiddlewareImports(orderedMiddleware, customMiddleware);
  lines.push(...imports);

  lines.push('');
  lines.push('/**');
  lines.push(' * Middleware context passed through the chain');
  lines.push(' */');
  lines.push('export interface MiddlewareChainContext {');
  lines.push('  userId?: string;');
  lines.push('  email?: string;');
  lines.push('  role?: string;');
  lines.push('  tenantId?: string;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(' * Middleware chain result');
  lines.push(' */');
  lines.push('export interface MiddlewareChainResult {');
  lines.push('  error: boolean;');
  lines.push('  response?: NextResponse;');
  lines.push('  context: MiddlewareChainContext;');
  lines.push('  /** Function to call after route handler completes (for logging, cache, etc) */');
  lines.push('  onComplete?: (response: NextResponse, status: number) => NextResponse;');
  lines.push('}');
  lines.push('');

  // Generate the runMiddlewareChain function
  lines.push('/**');
  lines.push(' * Run all configured middleware in order');
  lines.push(' *');
  lines.push(' * Middleware execution order:');
  for (const name of orderedMiddleware) {
    lines.push(` *   - ${name}`);
  }
  lines.push(' *');
  lines.push(' * @param request - Next.js request object');
  lines.push(' * @param entity - Entity name for RLS filtering (optional)');
  lines.push(' * @param operation - RLS operation type (optional)');
  lines.push(' * @returns Middleware chain result with context or error response');
  lines.push(' */');
  lines.push('export async function runMiddlewareChain(');
  lines.push('  request: NextRequest,');
  lines.push("  entity?: string,");
  lines.push("  operation?: 'select' | 'insert' | 'update' | 'delete'");
  lines.push('): Promise<MiddlewareChainResult> {');
  lines.push('  const context: MiddlewareChainContext = {};');
  lines.push('  const completionHandlers: Array<(response: NextResponse, status: number) => NextResponse> = [];');
  lines.push('');

  if (orderedMiddleware.length === 0) {
    lines.push('  // No middleware configured');
    lines.push('  return { error: false, context };');
  } else {
    // Generate middleware calls in order
    for (const name of orderedMiddleware) {
      lines.push(`  // ${name} middleware`);

      if (name === 'auth') {
        lines.push('  const authResult = await authMiddleware(request);');
        lines.push('  if (authResult.error) {');
        lines.push('    return { error: true, response: authResult.response, context };');
        lines.push('  }');
        lines.push('  if (authResult.context) {');
        lines.push('    context.userId = authResult.context.userId;');
        lines.push('    context.email = authResult.context.email;');
        lines.push('    context.role = authResult.context.role;');
        lines.push('    Object.assign(context, authResult.context);');
        lines.push('  }');
      } else if (name === 'rateLimit') {
        lines.push('  const rateLimitResult = rateLimitMiddleware(request, context.userId);');
        lines.push('  if (rateLimitResult.error) {');
        lines.push('    return { error: true, response: rateLimitResult.response, context };');
        lines.push('  }');
        lines.push('  // Store rate limit info for response headers');
        lines.push('  if (rateLimitResult.remaining !== undefined) {');
        lines.push('    completionHandlers.push((response) => {');
        lines.push('      return addRateLimitHeaders(response, rateLimitResult.remaining!, rateLimitResult.resetTime!);');
        lines.push('    });');
        lines.push('  }');
      } else if (name === 'logger') {
        lines.push('  const logger = loggerMiddleware(request, context.userId);');
        lines.push('  completionHandlers.push((response, status) => {');
        lines.push('    logger.finish(status);');
        lines.push('    return response;');
        lines.push('  });');
      } else if (name === 'context') {
        lines.push('  const extractedContext = contextMiddleware(request);');
        lines.push('  Object.assign(context, extractedContext);');
      } else if (name === 'rls') {
        lines.push('  if (entity && operation) {');
        lines.push('    const rlsResult = applyRLSFilter(entity, operation, context);');
        lines.push('    if (!rlsResult.allowed) {');
        lines.push('      return { error: true, response: rlsResult.error, context };');
        lines.push('    }');
        lines.push('    if (rlsResult.filter) {');
        lines.push("      context['rlsFilter'] = rlsResult.filter;");
        lines.push('    }');
        lines.push('  }');
      } else if (name === 'cache') {
        lines.push('  const cacheResult = cacheMiddleware(request, context.userId);');
        lines.push('  if (cacheResult.hit) {');
        lines.push('    // Return cached response');
        lines.push('    const cachedResponse = NextResponse.json(cacheResult.data);');
        lines.push("    cachedResponse.headers.set('X-Cache', 'HIT');");
        lines.push('    return { error: false, context, response: cachedResponse };');
        lines.push('  }');
      } else {
        // Custom middleware
        const customMw = customMiddleware.find((m) => m.name === name);
        if (customMw) {
          const handlerName = `${name}Middleware`;
          lines.push(`  const ${name}Result = await ${handlerName}(request, context);`);
          lines.push(`  if (${name}Result.error) {`);
          lines.push(`    return { error: true, response: ${name}Result.response, context };`);
          lines.push('  }');
          lines.push(`  if (${name}Result.context) {`);
          lines.push(`    Object.assign(context, ${name}Result.context);`);
          lines.push('  }');
        }
      }

      lines.push('');
    }

    // Generate the onComplete function
    lines.push('  // Build onComplete handler from completion handlers');
    lines.push('  const onComplete = completionHandlers.length > 0');
    lines.push('    ? (response: NextResponse, status: number) => {');
    lines.push('        let result = response;');
    lines.push('        for (const handler of completionHandlers) {');
    lines.push('          result = handler(result, status);');
    lines.push('        }');
    lines.push('        return result;');
    lines.push('      }');
    lines.push('    : undefined;');
    lines.push('');
    lines.push('  return { error: false, context, onComplete };');
  }

  lines.push('}');
  lines.push('');

  // Export individual middleware for selective use
  lines.push('/**');
  lines.push(' * Individual middleware exports for selective use');
  lines.push(' */');
  lines.push('export const middleware = {');
  for (const name of orderedMiddleware) {
    const handlerName = getMiddlewareHandlerName(name);
    lines.push(`  ${name}: ${handlerName},`);
  }
  lines.push('} as const;');
  lines.push('');

  // Export the ordered list
  lines.push('/**');
  lines.push(' * Middleware execution order');
  lines.push(' */');
  lines.push(`export const middlewareOrder = ${JSON.stringify(orderedMiddleware)} as const;`);
  lines.push('');

  // Helper to wrap route handler with middleware
  lines.push('/**');
  lines.push(' * Helper to wrap a route handler with middleware chain');
  lines.push(' *');
  lines.push(' * @example');
  lines.push(' * ```ts');
  lines.push(' * export const GET = withMiddleware(async (request, context) => {');
  lines.push(" *   const { data } = await supabase.from('users').select();");
  lines.push(' *   return NextResponse.json({ data });');
  lines.push(' * });');
  lines.push(' * ```');
  lines.push(' */');
  lines.push('export function withMiddleware(');
  lines.push('  handler: (');
  lines.push('    request: NextRequest,');
  lines.push('    context: MiddlewareChainContext');
  lines.push('  ) => Promise<NextResponse>,');
  lines.push('  options?: {');
  lines.push('    entity?: string;');
  lines.push("    operation?: 'select' | 'insert' | 'update' | 'delete';");
  lines.push('  }');
  lines.push(') {');
  lines.push('  return async (request: NextRequest) => {');
  lines.push('    const result = await runMiddlewareChain(');
  lines.push('      request,');
  lines.push('      options?.entity,');
  lines.push('      options?.operation');
  lines.push('    );');
  lines.push('');
  lines.push('    if (result.error) {');
  lines.push("      return result.response ?? NextResponse.json({ error: 'Middleware error' }, { status: 500 });");
  lines.push('    }');
  lines.push('');
  lines.push('    // If middleware returned a response (e.g., cache hit), return it');
  lines.push('    if (result.response) {');
  lines.push('      return result.response;');
  lines.push('    }');
  lines.push('');
  lines.push('    try {');
  lines.push('      const response = await handler(request, result.context);');
  lines.push('');
  lines.push('      // Run completion handlers (logging, headers, etc)');
  lines.push('      if (result.onComplete) {');
  lines.push('        return result.onComplete(response, response.status);');
  lines.push('      }');
  lines.push('');
  lines.push('      return response;');
  lines.push('    } catch (error) {');
  lines.push("      console.error('Route handler error:', error);");
  lines.push('');
  lines.push('      // Still run completion handlers for error logging');
  lines.push('      if (result.onComplete) {');
  lines.push("        const errorResponse = NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('        return result.onComplete(errorResponse, 500);');
  lines.push('      }');
  lines.push('');
  lines.push("      return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('    }');
  lines.push('  };');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Get list of enabled middleware from config
 */
function getEnabledMiddleware(config: MiddlewareConfig): string[] {
  const enabled: string[] = [];

  if (config.auth) enabled.push('auth');
  if (config.rateLimit) enabled.push('rateLimit');
  if (config.logger) enabled.push('logger');
  if (config.context) enabled.push('context');
  if (config.rls) enabled.push('rls');
  if (config.cache) enabled.push('cache');
  if (config.validation) enabled.push('validation');

  return enabled;
}

/**
 * Order middleware based on config.chain or default order
 */
function orderMiddleware(
  enabled: string[],
  customOrder?: string[],
  customMiddleware: AnalyzedMiddleware[] = []
): string[] {
  // Get custom middleware names categorized by order
  const earlyCustom = customMiddleware.filter((m) => m.order === 'early').map((m) => m.name);
  const normalCustom = customMiddleware.filter((m) => m.order === 'normal').map((m) => m.name);
  const lateCustom = customMiddleware.filter((m) => m.order === 'late').map((m) => m.name);

  if (customOrder && customOrder.length > 0) {
    // Use custom order, but only include enabled middleware
    const allEnabled = new Set([...enabled, ...customMiddleware.map((m) => m.name)]);
    return customOrder.filter((name) => allEnabled.has(name));
  }

  // Use default order, inserting custom middleware at appropriate positions
  const ordered: string[] = [];

  // Early custom middleware first
  ordered.push(...earlyCustom.filter((n) => !enabled.includes(n)));

  // Built-in middleware in default order
  for (const name of DEFAULT_MIDDLEWARE_ORDER) {
    if (enabled.includes(name)) {
      ordered.push(name);
    }
  }

  // Normal custom middleware after built-in
  ordered.push(...normalCustom.filter((n) => !enabled.includes(n)));

  // Late custom middleware last
  ordered.push(...lateCustom.filter((n) => !enabled.includes(n)));

  return ordered;
}

/**
 * Generate import statements for middleware
 */
function generateMiddlewareImports(
  orderedMiddleware: string[],
  customMiddleware: AnalyzedMiddleware[]
): string[] {
  const lines: string[] = [];
  const customNames = new Set(customMiddleware.map((m) => m.name));

  // Track what we need to import from each file
  const authImports: string[] = [];
  const rateLimitImports: string[] = [];
  const cacheImports: string[] = [];
  const loggerImports: string[] = [];
  const contextImports: string[] = [];
  const rlsImports: string[] = [];
  const validationImports: string[] = [];

  for (const name of orderedMiddleware) {
    if (customNames.has(name)) continue;

    switch (name) {
      case 'auth':
        authImports.push('authMiddleware');
        break;
      case 'rateLimit':
        rateLimitImports.push('rateLimitMiddleware', 'addRateLimitHeaders');
        break;
      case 'cache':
        cacheImports.push('cacheMiddleware', 'setCacheEntry');
        break;
      case 'logger':
        loggerImports.push('loggerMiddleware');
        break;
      case 'context':
        contextImports.push('contextMiddleware');
        break;
      case 'rls':
        rlsImports.push('applyRLSFilter');
        break;
      case 'validation':
        // Validation is imported per-schema, not here
        break;
    }
  }

  // Generate import statements
  if (authImports.length > 0) {
    lines.push(`import { ${authImports.join(', ')} } from './auth';`);
  }
  if (rateLimitImports.length > 0) {
    lines.push(`import { ${rateLimitImports.join(', ')} } from './rate-limit';`);
  }
  if (cacheImports.length > 0) {
    lines.push(`import { ${cacheImports.join(', ')} } from './cache';`);
  }
  if (loggerImports.length > 0) {
    lines.push(`import { ${loggerImports.join(', ')} } from './logger';`);
  }
  if (contextImports.length > 0) {
    lines.push(`import { ${contextImports.join(', ')} } from './context';`);
  }
  if (rlsImports.length > 0) {
    lines.push(`import { ${rlsImports.join(', ')} } from './rls';`);
  }

  // Custom middleware imports
  for (const mw of customMiddleware) {
    if (orderedMiddleware.includes(mw.name)) {
      const handlerName = `${mw.name}Middleware`;
      lines.push(`import { ${handlerName} } from './custom/${mw.name}';`);
    }
  }

  return lines;
}

/**
 * Get the handler function name for a middleware
 */
function getMiddlewareHandlerName(name: string): string {
  // Handle hyphenated names like 'rate-limit' -> 'rateLimitMiddleware'
  const camelCase = name.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
  return `${camelCase}Middleware`;
}

/**
 * Normalize middleware config helpers
 */
export function normalizeAuthConfig(
  config: AuthMiddlewareConfig | boolean | undefined
): AuthMiddlewareConfig | undefined {
  if (!config) return undefined;
  if (config === true) {
    return { provider: 'jwt', required: true };
  }
  return config;
}

export function normalizeLoggerConfig(
  config: LoggerMiddlewareConfig | boolean | undefined
): LoggerMiddlewareConfig | undefined {
  if (!config) return undefined;
  if (config === true) {
    return { level: 'info' };
  }
  return config;
}

export function normalizeCacheConfig(
  config: CacheMiddlewareConfig | boolean | undefined
): CacheMiddlewareConfig | undefined {
  if (!config) return undefined;
  if (config === true) {
    return { ttl: 300000, operations: ['findOne', 'findMany'] };
  }
  return config;
}
