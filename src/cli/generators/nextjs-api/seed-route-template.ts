/**
 * Next.js Seed Route Template
 *
 * Generates the `_seed/route.ts` file for production seeding via HTTP endpoint.
 *
 * @module cli/generators/nextjs-api/seed-route-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget, SchemockConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';
import {
  emitSeedRefHelpers,
  emitEntityOrderAndTableMap,
  emitSeedTypes,
  emitEscapeSQL,
  emitSupabaseKillSwitchHelpers,
  emitNeonKillSwitchHelpers,
  emitFirebaseKillSwitchHelpers,
  emitSupabaseInsertLogic,
  emitNeonInsertLogic,
  emitFirebaseInsertLogic,
  getBackendType,
} from '../shared/seed-handler-helpers';

/**
 * Generate the seed route file for Next.js App Router
 *
 * @param schemas - Analyzed schemas (topologically sorted)
 * @param target - Target configuration
 * @param config - Schemock config
 * @param libRelativePath - Relative path from _seed directory to _lib
 * @returns Generated TypeScript code
 */
export function generateSeedRouteFile(
  schemas: AnalyzedSchema[],
  target: GenerationTarget,
  config: SchemockConfig,
  libRelativePath: string = '../_lib'
): string {
  const code = new CodeBuilder();
  const backend = getBackendType(target);

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  code.line("import { NextRequest, NextResponse } from 'next/server';");

  // Backend-specific imports
  if (backend === 'supabase') {
    code.line(`import { supabase } from '${libRelativePath}/supabase';`);
  } else if (backend === 'firebase') {
    code.line(`import { db } from '${libRelativePath}/firebase';`);
  } else if (backend === 'neon') {
    code.line(`import { sql } from '${libRelativePath}/db';`);
  } else if (backend === 'pglite') {
    code.line(`import { db } from '${libRelativePath}/db';`);
  }

  code.line();

  // Emit types
  emitSeedTypes(code);

  // Emit entity order and table name mapping
  emitEntityOrderAndTableMap(code, schemas);

  // Emit seed reference helpers
  emitSeedRefHelpers(code);

  // Emit escapeSQL for SQL-based backends
  if (backend === 'neon' || backend === 'pglite') {
    emitEscapeSQL(code);
  }

  // Emit kill switch helpers based on backend
  if (backend === 'supabase') {
    emitSupabaseKillSwitchHelpers(code);
  } else if (backend === 'neon' || backend === 'pglite') {
    emitNeonKillSwitchHelpers(code);
  } else if (backend === 'firebase') {
    emitFirebaseKillSwitchHelpers(code);
  }

  // Generate the POST handler function
  generatePostHandler(code, backend, config, libRelativePath);

  return code.toString();
}

/**
 * Generate the POST handler function
 */
function generatePostHandler(
  code: CodeBuilder,
  backend: string,
  config: SchemockConfig,
  libRelativePath: string
): void {
  code.multiDocComment([
    'POST /_seed',
    '',
    'Production seed endpoint with secret validation and kill switch.',
    '',
    'Request body: { secret: string }',
    '',
    'Response codes:',
    '- 200: Seed successful',
    '- 400: Missing secret in request body',
    '- 401: Invalid secret',
    '- 409: Already seeded (kill switch active)',
    '- 500: Server error during seeding',
  ]);

  code.block('export async function POST(request: NextRequest): Promise<NextResponse> {', () => {
    // Environment guard
    code.comment('Environment guard: only allow in non-production or with explicit flag');
    code.block(
      "if (process.env.NODE_ENV === 'production' && process.env.SCHEMOCK_ALLOW_SEED !== 'true') {",
      () => {
        code.line('return NextResponse.json(');
        code.line("  { error: 'Seed endpoint disabled in production' },");
        code.line('  { status: 403 }');
        code.line(');');
      }
    );
    code.line();

    code.block('try {', () => {
      code.line('const body = await request.json().catch(() => ({}));');
      code.line('const { secret } = body;');
      code.line();

      // Validate secret is present
      code.block("if (!secret || typeof secret !== 'string') {", () => {
        code.line('return NextResponse.json(');
        code.line("  { success: false, error: 'MISSING_SECRET' } as SeedResult,");
        code.line('  { status: 400 }');
        code.line(');');
      });
      code.line();

      // Dynamic import of seed data
      code.comment('Dynamic import of seed data');
      const seedDataPath = config.productionSeed?.dataPath || './src/seed-data';
      const cleanPath = seedDataPath.replace(/^\.\//, '').replace(/\.ts$/, '');
      // Calculate depth: _seed is 1 level down from output root
      const depth = libRelativePath.split('../').length;
      const importPath = '../'.repeat(depth) + cleanPath;
      code.line(`const seedModule = await import('${importPath}');`);
      code.line('const seedConfig: ProductionSeedData = seedModule.seedConfig ?? seedModule.default;');
      code.line();

      // Validate secret
      code.comment('1. Validate secret');
      code.block('if (secret !== seedConfig.secret) {', () => {
        code.line('return NextResponse.json(');
        code.line("  { success: false, error: 'INVALID_SECRET' } as SeedResult,");
        code.line('  { status: 401 }');
        code.line(');');
      });
      code.line();

      // Check kill switch
      code.comment('2. Check kill switch');
      code.block('if (await isSeeded()) {', () => {
        code.line('const seededAt = await getSeededAt();');
        code.line('return NextResponse.json(');
        code.line('  {');
        code.line('    success: false,');
        code.line("    error: 'ALREADY_SEEDED',");
        code.line('    seededAt: seededAt ?? undefined,');
        code.line('  } as SeedResult,');
        code.line('  { status: 409 }');
        code.line(');');
      });
      code.line();

      // Insert data in order
      code.comment('3. Insert data for each entity (ordered by dependencies)');
      code.line('const createdRecords = new Map<string, Record<string, unknown>[]>();');
      code.line();

      code.comment('Determine insertion order: entityOrder first, then any remaining keys');
      code.line('const orderedEntities = [');
      code.line('  ...entityOrder.filter((e) => e in seedConfig.data),');
      code.line('  ...Object.keys(seedConfig.data).filter((e) => !entityOrder.includes(e)),');
      code.line('];');
      code.line();

      // Emit backend-specific INSERT logic
      if (backend === 'supabase') {
        emitSupabaseInsertLogic(code);
      } else if (backend === 'neon' || backend === 'pglite') {
        emitNeonInsertLogic(code);
      } else if (backend === 'firebase') {
        emitFirebaseInsertLogic(code);
      }
      code.line();

      // Set kill switch
      code.comment('4. Set kill switch');
      code.line('await setSeeded();');
      code.line('const seededAt = new Date();');
      code.line();

      code.line("console.log('\\u2713 Production data seeded via API');");
      code.line('return NextResponse.json({ success: true, seededAt } as SeedResult);');
    }, '} catch (error) {');
    code.indent();
    code.line("console.error('Seed error:', error);");
    code.line('return NextResponse.json(');
    code.line("  { error: error instanceof Error ? error.message : 'Unknown error' },");
    code.line('  { status: 500 }');
    code.line(');');
    code.dedent();
    code.line('}');
  });
}
