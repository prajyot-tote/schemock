/**
 * Next.js API Middleware Templates
 *
 * Generates middleware files for Next.js API routes from the v1.0 middleware config.
 * Middleware follows the Next.js pattern of returning NextResponse on error
 * or passing context through the middleware chain.
 *
 * @module cli/generators/nextjs-api/middleware-template
 * @category CLI
 */

import type {
  AnalyzedSchema,
  AuthMiddlewareConfig,
  RateLimitMiddlewareConfig,
  CacheMiddlewareConfig,
  LoggerMiddlewareConfig,
  AnalyzedMiddleware,
} from '../../types';

/**
 * Generate auth middleware from new v1.0 config format
 */
export function generateAuthMiddlewareNextjs(config: AuthMiddlewareConfig): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
  ];

  // Provider-specific imports
  if (config.provider === 'supabase-auth') {
    lines.push("import { supabase } from './supabase';");
  } else if (config.provider === 'jwt') {
    lines.push("import jwt from 'jsonwebtoken';");
  } else if (config.provider === 'nextauth') {
    lines.push("import { getServerSession } from 'next-auth';");
    lines.push("import { authOptions } from '@/lib/auth';");
  } else if (config.provider === 'clerk') {
    lines.push("import { auth } from '@clerk/nextjs/server';");
  }

  lines.push('');
  lines.push('/**');
  lines.push(' * Auth context extracted from request');
  lines.push(' */');
  lines.push('export interface AuthContext {');
  lines.push('  userId: string;');
  lines.push('  email?: string;');
  lines.push('  role?: string;');
  lines.push('  [key: string]: unknown;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Auth middleware result');
  lines.push(' */');
  lines.push('export interface AuthResult {');
  lines.push('  error: boolean;');
  lines.push('  response?: NextResponse;');
  lines.push('  context?: AuthContext;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Auth middleware - validates request authentication');
  lines.push(' */');
  lines.push('export async function authMiddleware(request: NextRequest): Promise<AuthResult> {');

  if (config.provider === 'supabase-auth') {
    lines.push("  const authHeader = request.headers.get('authorization');");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: NextResponse.json({ error: 'Missing authorization header' }, { status: 401 }),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  const { data: { user }, error } = await supabase.auth.getUser(token);');
    lines.push('');
    lines.push('  if (error || !user) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  return {');
    lines.push('    error: false,');
    lines.push('    context: {');
    lines.push('      userId: user.id,');
    lines.push('      email: user.email,');
    lines.push('      role: user.user_metadata?.role,');
    lines.push('    },');
    lines.push('  };');
  } else if (config.provider === 'jwt') {
    const secretEnvVar = config.secretEnvVar || 'JWT_SECRET';
    lines.push("  const authHeader = request.headers.get('authorization');");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: NextResponse.json({ error: 'Missing authorization header' }, { status: 401 }),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push(`    const decoded = jwt.verify(token, process.env.${secretEnvVar}!) as {`);
    lines.push('      sub: string;');
    lines.push('      email?: string;');
    lines.push('      role?: string;');
    lines.push('    };');
    lines.push('');
    lines.push('    return {');
    lines.push('      error: false,');
    lines.push('      context: {');
    lines.push('        userId: decoded.sub,');
    lines.push('        email: decoded.email,');
    lines.push('        role: decoded.role,');
    lines.push('      },');
    lines.push('    };');
    lines.push('  } catch {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
  } else if (config.provider === 'nextauth') {
    lines.push('  const session = await getServerSession(authOptions);');
    lines.push('');
    lines.push('  if (!session?.user) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: NextResponse.json({ error: 'Not authenticated' }, { status: 401 }),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  return {');
    lines.push('    error: false,');
    lines.push('    context: {');
    lines.push('      userId: session.user.id || session.user.email!,');
    lines.push('      email: session.user.email || undefined,');
    lines.push('    },');
    lines.push('  };');
  } else if (config.provider === 'clerk') {
    lines.push('  const { userId } = await auth();');
    lines.push('');
    lines.push('  if (!userId) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: NextResponse.json({ error: 'Not authenticated' }, { status: 401 }),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  return {');
    lines.push('    error: false,');
    lines.push('    context: { userId },');
    lines.push('  };');
  } else {
    // Custom provider
    lines.push('  // Custom auth implementation');
    lines.push("  const authHeader = request.headers.get('authorization');");
    lines.push('');
    lines.push('  if (!authHeader) {');
    if (config.required) {
      lines.push('    return {');
      lines.push('      error: true,');
      lines.push("      response: NextResponse.json({ error: 'Not authenticated' }, { status: 401 }),");
      lines.push('    };');
    } else {
      lines.push('    return { error: false };');
    }
    lines.push('  }');
    lines.push('');
    lines.push('  // TODO: Implement your custom auth logic here');
    lines.push("  return { error: false, context: { userId: 'custom-user-id' } };");
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate rate limit middleware
 */
export function generateRateLimitMiddlewareNextjs(config: RateLimitMiddlewareConfig): string {
  const max = config.max ?? 100;
  const windowMs = config.windowMs ?? 60000;
  const keyBy = config.keyBy || 'ip';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
    '',
    '/**',
    ' * Rate limit entry',
    ' */',
    'interface RateLimitEntry {',
    '  count: number;',
    '  resetTime: number;',
    '}',
    '',
    '// In-memory rate limit store (consider using Redis in production)',
    'const rateLimitStore = new Map<string, RateLimitEntry>();',
    '',
    `const RATE_LIMIT_MAX = ${max};`,
    `const RATE_LIMIT_WINDOW_MS = ${windowMs};`,
    '',
    '/**',
    ' * Rate limit result',
    ' */',
    'export interface RateLimitResult {',
    '  error: boolean;',
    '  response?: NextResponse;',
    '  remaining?: number;',
    '  resetTime?: number;',
    '}',
    '',
    '/**',
    ' * Get rate limit key from request',
    ' */',
    'function getRateLimitKey(request: NextRequest, userId?: string): string {',
  ];

  if (keyBy === 'user') {
    lines.push("  // Key by user ID (requires auth middleware to run first)");
    lines.push("  if (userId) return `user:${userId}`;");
    lines.push("  // Fall back to IP if no user");
  }

  lines.push("  const forwarded = request.headers.get('x-forwarded-for');");
  lines.push("  const ip = forwarded?.split(',')[0] ?? 'unknown';");
  lines.push("  return `ip:${ip}`;");
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Rate limit middleware');
  lines.push(' */');
  lines.push('export function rateLimitMiddleware(');
  lines.push('  request: NextRequest,');
  lines.push('  userId?: string');
  lines.push('): RateLimitResult {');
  lines.push('  const key = getRateLimitKey(request, userId);');
  lines.push('  const now = Date.now();');
  lines.push('');
  lines.push('  let entry = rateLimitStore.get(key);');
  lines.push('');
  lines.push('  // Clean up expired entry');
  lines.push('  if (entry && entry.resetTime < now) {');
  lines.push('    rateLimitStore.delete(key);');
  lines.push('    entry = undefined;');
  lines.push('  }');
  lines.push('');
  lines.push('  if (!entry) {');
  lines.push('    entry = {');
  lines.push('      count: 1,');
  lines.push('      resetTime: now + RATE_LIMIT_WINDOW_MS,');
  lines.push('    };');
  lines.push('    rateLimitStore.set(key, entry);');
  lines.push('  } else {');
  lines.push('    entry.count++;');
  lines.push('  }');
  lines.push('');
  lines.push('  const remaining = Math.max(0, RATE_LIMIT_MAX - entry.count);');
  lines.push('  const resetTime = entry.resetTime;');
  lines.push('');
  lines.push('  if (entry.count > RATE_LIMIT_MAX) {');
  lines.push('    const retryAfter = Math.ceil((resetTime - now) / 1000);');
  lines.push('    return {');
  lines.push('      error: true,');
  lines.push('      response: NextResponse.json(');
  lines.push("        { error: 'Too many requests', retryAfter },");
  lines.push('        {');
  lines.push('          status: 429,');
  lines.push('          headers: {');
  lines.push("            'X-RateLimit-Limit': RATE_LIMIT_MAX.toString(),");
  lines.push("            'X-RateLimit-Remaining': '0',");
  lines.push("            'X-RateLimit-Reset': Math.ceil(resetTime / 1000).toString(),");
  lines.push("            'Retry-After': retryAfter.toString(),");
  lines.push('          },');
  lines.push('        }');
  lines.push('      ),');
  lines.push('      remaining: 0,');
  lines.push('      resetTime,');
  lines.push('    };');
  lines.push('  }');
  lines.push('');
  lines.push('  return { error: false, remaining, resetTime };');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Add rate limit headers to response');
  lines.push(' */');
  lines.push('export function addRateLimitHeaders(');
  lines.push('  response: NextResponse,');
  lines.push('  remaining: number,');
  lines.push('  resetTime: number');
  lines.push('): NextResponse {');
  lines.push("  response.headers.set('X-RateLimit-Limit', RATE_LIMIT_MAX.toString());");
  lines.push("  response.headers.set('X-RateLimit-Remaining', remaining.toString());");
  lines.push("  response.headers.set('X-RateLimit-Reset', Math.ceil(resetTime / 1000).toString());");
  lines.push('  return response;');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate cache middleware
 */
export function generateCacheMiddlewareNextjs(config: CacheMiddlewareConfig): string {
  const ttl = config.ttl ?? 300000;
  const operations = config.operations ?? ['findOne', 'findMany'];

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
    '',
    '/**',
    ' * Cache entry',
    ' */',
    'interface CacheEntry {',
    '  data: unknown;',
    '  expiresAt: number;',
    '}',
    '',
    '// In-memory cache store (consider using Redis in production)',
    'const cacheStore = new Map<string, CacheEntry>();',
    '',
    `const CACHE_TTL_MS = ${ttl};`,
    `const CACHED_OPERATIONS = ${JSON.stringify(operations)};`,
    '',
    '/**',
    ' * Cache result',
    ' */',
    'export interface CacheResult {',
    '  hit: boolean;',
    '  data?: unknown;',
    '}',
    '',
    '/**',
    ' * Generate cache key from request',
    ' */',
    'function getCacheKey(request: NextRequest, userId?: string): string {',
    '  const url = new URL(request.url);',
    "  const baseKey = `${request.method}:${url.pathname}:${url.searchParams.toString()}`;",
    "  return userId ? `${baseKey}:user:${userId}` : baseKey;",
    '}',
    '',
    '/**',
    ' * Check if operation should be cached',
    ' */',
    'function shouldCache(request: NextRequest, pathname: string): boolean {',
    "  if (request.method !== 'GET') return false;",
    '',
    '  // Determine operation type from pathname',
    "  const hasId = /\\/[a-zA-Z0-9-]+$/.test(pathname) && !pathname.endsWith('s');",
    "  const operation = hasId ? 'findOne' : 'findMany';",
    '',
    '  return CACHED_OPERATIONS.includes(operation);',
    '}',
    '',
    '/**',
    ' * Cache middleware - check cache for GET requests',
    ' */',
    'export function cacheMiddleware(',
    '  request: NextRequest,',
    '  userId?: string',
    '): CacheResult {',
    '  const url = new URL(request.url);',
    '',
    '  if (!shouldCache(request, url.pathname)) {',
    '    return { hit: false };',
    '  }',
    '',
    '  const key = getCacheKey(request, userId);',
    '  const entry = cacheStore.get(key);',
    '',
    '  if (entry && entry.expiresAt > Date.now()) {',
    '    return { hit: true, data: entry.data };',
    '  }',
    '',
    '  // Clean up expired entry',
    '  if (entry) {',
    '    cacheStore.delete(key);',
    '  }',
    '',
    '  return { hit: false };',
    '}',
    '',
    '/**',
    ' * Store response in cache',
    ' */',
    'export function setCacheEntry(',
    '  request: NextRequest,',
    '  data: unknown,',
    '  userId?: string',
    '): void {',
    '  const url = new URL(request.url);',
    '',
    '  if (!shouldCache(request, url.pathname)) return;',
    '',
    '  const key = getCacheKey(request, userId);',
    '  cacheStore.set(key, {',
    '    data,',
    '    expiresAt: Date.now() + CACHE_TTL_MS,',
    '  });',
    '}',
    '',
    '/**',
    ' * Invalidate cache entries matching a pattern',
    ' */',
    'export function invalidateCache(pattern?: string | RegExp): void {',
    '  if (!pattern) {',
    '    cacheStore.clear();',
    '    return;',
    '  }',
    '',
    '  const regex = typeof pattern === "string" ? new RegExp(pattern) : pattern;',
    '  for (const key of cacheStore.keys()) {',
    '    if (regex.test(key)) {',
    '      cacheStore.delete(key);',
    '    }',
    '  }',
    '}',
    '',
    '/**',
    ' * Invalidate cache for an entity',
    ' */',
    'export function invalidateEntityCache(entityPath: string): void {',
    '  invalidateCache(new RegExp(`GET:.*${entityPath}`));',
    '}',
    '',
  ];

  return lines.join('\n');
}

/**
 * Generate logger middleware
 */
export function generateLoggerMiddlewareNextjs(config: LoggerMiddlewareConfig): string {
  const level = config.level ?? 'info';
  const redactFields = config.redactFields ?? ['password', 'token', 'secret', 'authorization'];

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest } from 'next/server';",
    '',
    `const LOG_LEVEL = '${level}';`,
    `const REDACT_FIELDS = ${JSON.stringify(redactFields)};`,
    '',
    '/**',
    ' * Log levels',
    ' */',
    "const LOG_LEVELS = { debug: 0, info: 1, warn: 2, error: 3 } as const;",
    '',
    '/**',
    ' * Request log entry',
    ' */',
    'export interface RequestLog {',
    '  timestamp: string;',
    '  method: string;',
    '  path: string;',
    '  query?: Record<string, string>;',
    '  userId?: string;',
    '  duration?: number;',
    '  status?: number;',
    '}',
    '',
    '/**',
    ' * Redact sensitive fields from object',
    ' */',
    'function redactSensitive(obj: Record<string, unknown>): Record<string, unknown> {',
    '  const result: Record<string, unknown> = {};',
    '  for (const [key, value] of Object.entries(obj)) {',
    '    if (REDACT_FIELDS.some((f) => key.toLowerCase().includes(f.toLowerCase()))) {',
    "      result[key] = '[REDACTED]';",
    '    } else if (typeof value === "object" && value !== null) {',
    '      result[key] = redactSensitive(value as Record<string, unknown>);',
    '    } else {',
    '      result[key] = value;',
    '    }',
    '  }',
    '  return result;',
    '}',
    '',
    '/**',
    ' * Log a message at the specified level',
    ' */',
    "function log(level: keyof typeof LOG_LEVELS, message: string, data?: Record<string, unknown>): void {",
    '  if (LOG_LEVELS[level] < LOG_LEVELS[LOG_LEVEL as keyof typeof LOG_LEVELS]) return;',
    '',
    '  const logEntry = {',
    '    timestamp: new Date().toISOString(),',
    '    level,',
    '    message,',
    '    ...redactSensitive(data || {}),',
    '  };',
    '',
    "  if (level === 'error') {",
    '    console.error(JSON.stringify(logEntry));',
    "  } else if (level === 'warn') {",
    '    console.warn(JSON.stringify(logEntry));',
    '  } else {',
    '    console.log(JSON.stringify(logEntry));',
    '  }',
    '}',
    '',
    '/**',
    ' * Logger middleware - log request start',
    ' * Returns a function to call when request completes',
    ' */',
    'export function loggerMiddleware(',
    '  request: NextRequest,',
    '  userId?: string',
    '): { finish: (status: number) => void } {',
    '  const startTime = Date.now();',
    '  const url = new URL(request.url);',
    '',
    '  const logData: RequestLog = {',
    '    timestamp: new Date().toISOString(),',
    '    method: request.method,',
    '    path: url.pathname,',
    '    userId,',
    '  };',
    '',
    '  // Log query params (redacted)',
    '  const queryParams: Record<string, string> = {};',
    '  url.searchParams.forEach((value, key) => {',
    '    queryParams[key] = value;',
    '  });',
    '  if (Object.keys(queryParams).length > 0) {',
    '    logData.query = redactSensitive(queryParams) as Record<string, string>;',
    '  }',
    '',
    "  log('debug', 'Request started', logData as unknown as Record<string, unknown>);",
    '',
    '  return {',
    '    finish: (status: number) => {',
    '      const duration = Date.now() - startTime;',
    "      log('info', 'Request completed', {",
    '        ...logData,',
    '        status,',
    '        duration,',
    '      } as unknown as Record<string, unknown>);',
    '    },',
    '  };',
    '}',
    '',
  ];

  return lines.join('\n');
}

/**
 * Generate context extraction middleware
 */
export function generateContextMiddlewareNextjs(): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest } from 'next/server';",
    '',
    '/**',
    ' * Request context extracted from headers/JWT',
    ' */',
    'export interface RequestContext {',
    '  userId?: string;',
    '  email?: string;',
    '  role?: string;',
    '  tenantId?: string;',
    '  [key: string]: unknown;',
    '}',
    '',
    '/**',
    ' * Decode JWT payload (without verification - auth middleware handles that)',
    ' */',
    'function decodeJwtPayload(token: string): Record<string, unknown> | null {',
    '  try {',
    "    const parts = token.split('.');",
    '    if (parts.length !== 3) return null;',
    '    const payload = Buffer.from(parts[1], "base64").toString("utf-8");',
    '    return JSON.parse(payload);',
    '  } catch {',
    '    return null;',
    '  }',
    '}',
    '',
    '/**',
    ' * Context middleware - extracts context from request headers and JWT',
    ' */',
    'export function contextMiddleware(request: NextRequest): RequestContext {',
    '  const context: RequestContext = {};',
    '',
    '  // Extract from Authorization header (JWT)',
    "  const authHeader = request.headers.get('authorization');",
    '  if (authHeader) {',
    "    const token = authHeader.split(' ')[1];",
    '    if (token) {',
    '      const payload = decodeJwtPayload(token);',
    '      if (payload) {',
    '        context.userId = payload.sub as string;',
    '        context.email = payload.email as string;',
    '        context.role = payload.role as string;',
    '      }',
    '    }',
    '  }',
    '',
    '  // Extract from custom headers',
    "  const tenantId = request.headers.get('x-tenant-id');",
    '  if (tenantId) context.tenantId = tenantId;',
    '',
    "  const userId = request.headers.get('x-user-id');",
    '  if (userId && !context.userId) context.userId = userId;',
    '',
    "  const role = request.headers.get('x-user-role');",
    '  if (role && !context.role) context.role = role;',
    '',
    '  return context;',
    '}',
    '',
  ];

  return lines.join('\n');
}

/**
 * Generate RLS middleware
 */
export function generateRlsMiddlewareNextjs(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextResponse } from 'next/server';",
    "import type { RequestContext } from './context';",
    '',
    '/**',
    ' * RLS operation type',
    ' */',
    "export type RLSOperation = 'select' | 'insert' | 'update' | 'delete';",
    '',
    '/**',
    ' * RLS filter result',
    ' */',
    'export interface RLSFilter {',
    '  allowed: boolean;',
    '  filter?: Record<string, unknown>;',
    '  error?: NextResponse;',
    '}',
    '',
    '/**',
    ' * Entity RLS policies',
    ' */',
    'interface EntityRLSPolicy {',
    '  scope?: Array<{ field: string; contextKey: string }>;',
    '  bypass?: Array<{ contextKey: string; values: string[] }>;',
    '}',
    '',
    '/**',
    ' * RLS policies by entity',
    ' */',
    'const rlsPolicies: Record<string, EntityRLSPolicy> = {',
  ];

  // Generate policies for each schema with RLS config
  for (const schema of schemas) {
    if (!schema.rlsConfig) continue;

    lines.push(`  '${schema.tableName}': {`);

    if (schema.rlsConfig.scope) {
      lines.push('    scope: [');
      for (const scopeItem of schema.rlsConfig.scope) {
        lines.push(`      { field: '${scopeItem.field}', contextKey: '${scopeItem.contextKey}' },`);
      }
      lines.push('    ],');
    }

    if (schema.rlsConfig.bypass) {
      lines.push('    bypass: [');
      for (const bypassItem of schema.rlsConfig.bypass) {
        lines.push(`      { contextKey: '${bypassItem.contextKey}', values: ${JSON.stringify(bypassItem.values)} },`);
      }
      lines.push('    ],');
    }

    lines.push('  },');
  }

  lines.push('};');
  lines.push('');
  lines.push('/**');
  lines.push(' * Check if context bypasses RLS');
  lines.push(' */');
  lines.push('function checkBypass(policy: EntityRLSPolicy, context: RequestContext): boolean {');
  lines.push('  if (!policy.bypass) return false;');
  lines.push('');
  lines.push('  for (const bypass of policy.bypass) {');
  lines.push('    const contextValue = context[bypass.contextKey] as string;');
  lines.push('    if (contextValue && bypass.values.includes(contextValue)) {');
  lines.push('      return true;');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  lines.push('  return false;');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Apply RLS filter for an operation');
  lines.push(' */');
  lines.push('export function applyRLSFilter(');
  lines.push('  entity: string,');
  lines.push('  operation: RLSOperation,');
  lines.push('  context: RequestContext');
  lines.push('): RLSFilter {');
  lines.push('  const policy = rlsPolicies[entity];');
  lines.push('');
  lines.push('  // No RLS policy for this entity');
  lines.push('  if (!policy) {');
  lines.push('    return { allowed: true };');
  lines.push('  }');
  lines.push('');
  lines.push('  // Check bypass');
  lines.push('  if (checkBypass(policy, context)) {');
  lines.push('    return { allowed: true };');
  lines.push('  }');
  lines.push('');
  lines.push('  // Build filter from scope');
  lines.push('  if (policy.scope) {');
  lines.push('    const filter: Record<string, unknown> = {};');
  lines.push('');
  lines.push('    for (const scope of policy.scope) {');
  lines.push('      const contextValue = context[scope.contextKey];');
  lines.push('');
  lines.push('      if (contextValue === undefined) {');
  lines.push("        // Missing required context value");
  lines.push('        return {');
  lines.push('          allowed: false,');
  lines.push('          error: NextResponse.json(');
  lines.push('            { error: `Access denied: missing ${scope.contextKey}` },');
  lines.push('            { status: 403 }');
  lines.push('          ),');
  lines.push('        };');
  lines.push('      }');
  lines.push('');
  lines.push('      filter[scope.field] = contextValue;');
  lines.push('    }');
  lines.push('');
  lines.push('    return { allowed: true, filter };');
  lines.push('  }');
  lines.push('');
  lines.push('  return { allowed: true };');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Check if a row passes RLS policy');
  lines.push(' */');
  lines.push('export function checkRLSPermission(');
  lines.push('  entity: string,');
  lines.push('  row: Record<string, unknown>,');
  lines.push('  context: RequestContext');
  lines.push('): boolean {');
  lines.push('  const policy = rlsPolicies[entity];');
  lines.push('');
  lines.push('  if (!policy) return true;');
  lines.push('  if (checkBypass(policy, context)) return true;');
  lines.push('');
  lines.push('  if (policy.scope) {');
  lines.push('    for (const scope of policy.scope) {');
  lines.push('      const rowValue = row[scope.field];');
  lines.push('      const contextValue = context[scope.contextKey];');
  lines.push('');
  lines.push('      if (rowValue !== contextValue) {');
  lines.push('        return false;');
  lines.push('      }');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  lines.push('  return true;');
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate custom middleware from defineMiddleware() definition
 */
export function generateCustomMiddlewareNextjs(analyzed: AnalyzedMiddleware): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
    '',
  ];

  // Generate config type if middleware has config
  if (analyzed.configFields.length > 0) {
    lines.push('/**');
    lines.push(` * ${analyzed.name} middleware config`);
    lines.push(' */');
    lines.push(`export interface ${pascalCase(analyzed.name)}Config {`);
    for (const field of analyzed.configFields) {
      const optional = field.defaultValue !== undefined ? '?' : '';
      lines.push(`  ${field.name}${optional}: ${field.type};`);
    }
    lines.push('}');
    lines.push('');

    // Generate default config
    lines.push(`const defaultConfig: ${pascalCase(analyzed.name)}Config = {`);
    for (const field of analyzed.configFields) {
      if (field.defaultValue !== undefined) {
        lines.push(`  ${field.name}: ${JSON.stringify(field.defaultValue)},`);
      }
    }
    lines.push('};');
    lines.push('');
  }

  lines.push('/**');
  lines.push(` * ${analyzed.name} middleware context`);
  lines.push(' */');
  lines.push('export interface MiddlewareContext {');
  lines.push('  request: NextRequest;');
  lines.push('  headers: Record<string, string | null>;');
  lines.push('  context: Record<string, unknown>;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(` * ${analyzed.name} middleware result`);
  lines.push(' */');
  lines.push(`export interface ${pascalCase(analyzed.name)}Result {`);
  lines.push('  error: boolean;');
  lines.push('  response?: NextResponse;');
  lines.push('  context?: Record<string, unknown>;');
  lines.push('}');
  lines.push('');

  lines.push('/**');
  lines.push(` * ${analyzed.name} middleware`);
  if (analyzed.description) {
    lines.push(` * ${analyzed.description}`);
  }
  lines.push(' */');

  // Generate the middleware function
  const hasConfig = analyzed.configFields.length > 0;
  if (hasConfig) {
    lines.push(`export async function ${analyzed.name}Middleware(`);
    lines.push('  request: NextRequest,');
    lines.push(`  userConfig?: Partial<${pascalCase(analyzed.name)}Config>,`);
    lines.push('  existingContext?: Record<string, unknown>');
    lines.push(`): Promise<${pascalCase(analyzed.name)}Result> {`);
    lines.push('  const config = { ...defaultConfig, ...userConfig };');
  } else {
    lines.push(`export async function ${analyzed.name}Middleware(`);
    lines.push('  request: NextRequest,');
    lines.push('  existingContext?: Record<string, unknown>');
    lines.push(`): Promise<${pascalCase(analyzed.name)}Result> {`);
  }

  lines.push('');
  lines.push('  // Build middleware context');
  lines.push('  const headers: Record<string, string | null> = {};');
  lines.push('  request.headers.forEach((value, key) => {');
  lines.push('    headers[key.toLowerCase()] = value;');
  lines.push('  });');
  lines.push('');
  lines.push('  const ctx: MiddlewareContext = {');
  lines.push('    request,');
  lines.push('    headers,');
  lines.push('    context: existingContext || {},');
  lines.push('  };');
  lines.push('');

  // Inject the handler code
  if (analyzed.handlerCode) {
    // Transform the handler code for Next.js
    lines.push('  // Custom handler (adapted from defineMiddleware)');
    lines.push('  try {');
    lines.push('    const handlerResult = await (async () => {');
    lines.push('      ' + analyzed.handlerCode.split('\n').join('\n      '));
    lines.push('    })();');
    lines.push('');
    lines.push('    // If handler returned a value, merge into context');
    lines.push("    if (typeof handlerResult === 'object' && handlerResult !== null) {");
    lines.push('      Object.assign(ctx.context, handlerResult);');
    lines.push('    }');
    lines.push('');
    lines.push('    return { error: false, context: ctx.context };');
    lines.push('  } catch (err) {');
    lines.push('    const error = err as { message?: string; status?: number };');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push('      response: NextResponse.json(');
    lines.push("        { error: error.message || 'Middleware error' },");
    lines.push('        { status: error.status || 500 }');
    lines.push('      ),');
    lines.push('    };');
    lines.push('  }');
  } else {
    lines.push('  // No handler code - pass through');
    lines.push('  return { error: false, context: ctx.context };');
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate validation middleware (moved from lib-template for consistency)
 */
export function generateValidationNextjs(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '/**',
    ' * Validation error type',
    ' */',
    'export interface ValidationError {',
    '  field: string;',
    '  message: string;',
    '}',
    '',
    '/**',
    ' * Validation result type',
    ' */',
    'export interface ValidationResult<T = unknown> {',
    '  valid: boolean;',
    '  errors?: ValidationError[];',
    '  data?: T;',
    '}',
    '',
    '/**',
    ' * Email validation regex',
    ' */',
    'const EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
    '',
    '/**',
    ' * URL validation regex',
    ' */',
    'const URL_REGEX = /^https?:\\/\\/.+/;',
    '',
  ];

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    // Create validation function
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} creation data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}(data: unknown): ValidationResult {`);
    lines.push("  const errors: ValidationError[] = [];");
    lines.push("");
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push("  }");
    lines.push("");
    lines.push("  const obj = data as Record<string, unknown>;");
    lines.push("");

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const isRequired = !field.nullable && !field.hasDefault;

      // Required check
      if (isRequired) {
        lines.push(`  if (obj.${field.name} === undefined || obj.${field.name} === null) {`);
        lines.push(`    errors.push({ field: '${field.name}', message: '${field.name} is required' });`);
        lines.push("  }");
      }

      // Type-specific validation
      lines.push(`  if (obj.${field.name} !== undefined && obj.${field.name} !== null) {`);

      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        lines.push(`    if (typeof obj.${field.name} !== 'string') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a string' });`);
        lines.push("    } else {");

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min} characters' });`);
          lines.push("      }");
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max} characters' });`);
          lines.push("      }");
        }

        if (field.type === 'email') {
          lines.push(`      if (!EMAIL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid email format' });`);
          lines.push("      }");
        }

        if (field.type === 'url') {
          lines.push(`      if (!URL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid URL format' });`);
          lines.push("      }");
        }

        if (field.pattern) {
          lines.push(`      if (!/${field.pattern}/.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid format' });`);
          lines.push("      }");
        }

        lines.push("    }");
      } else if (field.type === 'int' || field.type === 'float' || field.type === 'number') {
        lines.push(`    if (typeof obj.${field.name} !== 'number') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a number' });`);
        lines.push("    } else {");

        if (field.type === 'int') {
          lines.push(`      if (!Number.isInteger(obj.${field.name})) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be an integer' });`);
          lines.push("      }");
        }

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min}' });`);
          lines.push("      }");
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max}' });`);
          lines.push("      }");
        }

        lines.push("    }");
      } else if (field.type === 'boolean') {
        lines.push(`    if (typeof obj.${field.name} !== 'boolean') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a boolean' });`);
        lines.push("    }");
      } else if (field.isEnum && field.enumValues) {
        const enumVals = field.enumValues.map((v) => `'${v}'`).join(', ');
        lines.push(`    if (![${enumVals}].includes(obj.${field.name} as string)) {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be one of: ${field.enumValues.join(', ')}' });`);
        lines.push("    }");
      }

      lines.push("  }");
      lines.push("");
    }

    lines.push("  return errors.length > 0 ? { valid: false, errors } : { valid: true, data: obj };");
    lines.push("}");
    lines.push("");

    // Update validation function
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} update data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}Update(data: unknown): ValidationResult {`);
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push("  }");
    lines.push("");
    lines.push("  const obj = data as Record<string, unknown>;");
    lines.push("  const errors: ValidationError[] = [];");
    lines.push("");
    lines.push("  // For updates, all fields are optional but must be valid if present");
    lines.push(`  const fullValidation = validate${schema.pascalName}({ ...obj });`);
    lines.push("");
    lines.push("  // Filter out 'required' errors for updates");
    lines.push("  const updateErrors = fullValidation.errors?.filter(");
    lines.push("    (err) => !err.message.includes('is required')");
    lines.push("  ) || [];");
    lines.push("");
    lines.push("  return updateErrors.length > 0 ? { valid: false, errors: updateErrors } : { valid: true, data: obj };");
    lines.push("}");
    lines.push("");
  }

  return lines.join('\n');
}

/**
 * Helper to convert string to PascalCase
 */
function pascalCase(str: string): string {
  return str
    .replace(/[-_](\w)/g, (_, c) => c.toUpperCase())
    .replace(/^(\w)/, (_, c) => c.toUpperCase());
}
