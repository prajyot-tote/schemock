/**
 * Next.js API Library Templates
 *
 * Generates shared library files for Next.js API routes.
 *
 * @module cli/generators/nextjs-api/lib-template
 * @category CLI
 */

import type { GenerationTarget, SchemockConfig, AnalyzedSchema } from '../../types';

/**
 * Generate all library files for the target
 */
export function generateLibFiles(
  target: GenerationTarget,
  _config: SchemockConfig
): Record<string, string> {
  const files: Record<string, string> = {};
  const backend = target.backend || 'supabase';

  // Always generate types re-export
  files['types.ts'] = generateTypesReexport();

  // Generate backend client
  if (backend === 'supabase') {
    files['supabase.ts'] = generateSupabaseClient(target);
  } else if (backend === 'firebase') {
    files['firebase.ts'] = generateFirebaseClient(target);
  } else if (backend === 'pglite') {
    files['pglite.ts'] = generatePGliteClient(target);
  }

  // Generate auth middleware if configured
  if (target.middleware?.auth) {
    files['auth.ts'] = generateAuthMiddleware(target);
  }

  return files;
}

/**
 * Generate types re-export file
 */
function generateTypesReexport(): string {
  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '// Re-export types from the main types file',
    '// You may need to adjust this path based on your project structure',
    "export * from '../../types';",
    '',
  ].join('\n');
}

/**
 * Generate Supabase client
 */
function generateSupabaseClient(target: GenerationTarget): string {
  const envPrefix = (target.options?.envPrefix as string) || 'NEXT_PUBLIC_SUPABASE';

  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { createClient } from '@supabase/supabase-js';",
    '',
    `const supabaseUrl = process.env.${envPrefix}_URL!;`,
    `const supabaseKey = process.env.${envPrefix}_ANON_KEY!;`,
    '',
    '// For server-side routes, you may want to use the service role key',
    `// const supabaseServiceKey = process.env.${envPrefix}_SERVICE_ROLE_KEY;`,
    '',
    'if (!supabaseUrl || !supabaseKey) {',
    "  throw new Error('Missing Supabase environment variables');",
    '}',
    '',
    'export const supabase = createClient(supabaseUrl, supabaseKey);',
    '',
    '// Server-side client with service role (use with caution)',
    '// export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey!);',
    '',
  ].join('\n');
}

/**
 * Generate Firebase client
 */
function generateFirebaseClient(_target: GenerationTarget): string {
  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { initializeApp, getApps, cert } from 'firebase-admin/app';",
    "import { getFirestore } from 'firebase-admin/firestore';",
    '',
    '// Initialize Firebase Admin SDK',
    'if (!getApps().length) {',
    '  initializeApp({',
    '    credential: cert({',
    '      projectId: process.env.FIREBASE_PROJECT_ID,',
    '      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,',
    '      privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\\\n/g, "\\n"),',
    '    }),',
    '  });',
    '}',
    '',
    'export const db = getFirestore();',
    '',
  ].join('\n');
}

/**
 * Generate PGlite client
 */
function generatePGliteClient(target: GenerationTarget): string {
  const persistence = (target.options?.persistence as string) || 'indexeddb';

  return [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { PGlite } from '@electric-sql/pglite';",
    '',
    '// Initialize PGlite database',
    `export const db = new PGlite('${persistence === 'memory' ? '' : `idb://${target.name}-db`}');`,
    '',
    '// Database initialization happens in a separate init function',
    '// Call initDb() before using the database',
    'let initialized = false;',
    '',
    'export async function initDb(): Promise<void> {',
    '  if (initialized) return;',
    '  // Add your table creation SQL here',
    '  initialized = true;',
    '}',
    '',
  ].join('\n');
}

/**
 * Generate auth middleware
 */
function generateAuthMiddleware(target: GenerationTarget): string {
  const authConfig = target.middleware?.auth;
  if (!authConfig) return '';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
  ];

  // Provider-specific imports
  if (authConfig.provider === 'supabase-auth') {
    lines.push("import { supabase } from './supabase';");
  } else if (authConfig.provider === 'jwt') {
    lines.push("import jwt from 'jsonwebtoken';");
  } else if (authConfig.provider === 'nextauth') {
    lines.push("import { getServerSession } from 'next-auth';");
    lines.push("import { authOptions } from '@/lib/auth';");
  } else if (authConfig.provider === 'clerk') {
    lines.push("import { auth } from '@clerk/nextjs/server';");
  }

  lines.push('');
  lines.push('/**');
  lines.push(' * Auth result type');
  lines.push(' */');
  lines.push('export interface AuthResult {');
  lines.push('  error: boolean;');
  lines.push('  response?: NextResponse;');
  lines.push('  user?: {');
  lines.push('    id: string;');
  lines.push('    email?: string;');
  lines.push('    [key: string]: unknown;');
  lines.push('  };');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Auth middleware - validates request authentication');
  lines.push(' */');
  lines.push('export async function authMiddleware(request: NextRequest): Promise<AuthResult> {');

  if (authConfig.provider === 'supabase-auth') {
    lines.push("  const authHeader = request.headers.get('authorization');");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Missing authorization header' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  const { data: { user }, error } = await supabase.auth.getUser(token);');
    lines.push('');
    lines.push('  if (error || !user) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  return { error: false, user: { id: user.id, email: user.email } };');
  } else if (authConfig.provider === 'jwt') {
    const secretEnvVar = authConfig.secretEnvVar || 'JWT_SECRET';
    lines.push("  const authHeader = request.headers.get('authorization');");
    lines.push("  const token = authHeader?.split(' ')[1];");
    lines.push('');
    lines.push('  if (!token) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Missing authorization header' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  try {');
    lines.push(`    const decoded = jwt.verify(token, process.env.${secretEnvVar}!) as { sub: string; email?: string };`);
    lines.push('    return { error: false, user: { id: decoded.sub, email: decoded.email } };');
    lines.push('  } catch {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Invalid or expired token' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
  } else if (authConfig.provider === 'nextauth') {
    lines.push('  const session = await getServerSession(authOptions);');
    lines.push('');
    lines.push('  if (!session?.user) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Not authenticated' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  return {');
    lines.push('    error: false,');
    lines.push('    user: {');
    lines.push('      id: session.user.id || session.user.email!,');
    lines.push('      email: session.user.email || undefined,');
    lines.push('    },');
    lines.push('  };');
  } else if (authConfig.provider === 'clerk') {
    lines.push('  const { userId } = await auth();');
    lines.push('');
    lines.push('  if (!userId) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Not authenticated' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  return { error: false, user: { id: userId } };');
  } else if (authConfig.provider === 'custom') {
    lines.push('  // Custom auth implementation');
    lines.push('  // TODO: Implement your custom auth logic here');
    lines.push("  const authHeader = request.headers.get('authorization');");
    lines.push('');
    lines.push('  if (!authHeader) {');
    lines.push('    return {');
    lines.push('      error: true,');
    lines.push("      response: NextResponse.json({ error: 'Not authenticated' }, { status: 401 }),");
    lines.push('    };');
    lines.push('  }');
    lines.push('');
    lines.push('  // Add your custom validation logic here');
    lines.push("  return { error: false, user: { id: 'custom-user-id' } };");
  }

  lines.push('}');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate validation functions for a schema
 */
export function generateValidation(schemas: AnalyzedSchema[]): string {
  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    '/**',
    ' * Validation error type',
    ' */',
    'export interface ValidationError {',
    '  field: string;',
    '  message: string;',
    '}',
    '',
    '/**',
    ' * Validation result type',
    ' */',
    'export interface ValidationResult<T = unknown> {',
    '  valid: boolean;',
    '  errors?: ValidationError[];',
    '  data?: T;',
    '}',
    '',
    '/**',
    ' * Email validation regex',
    ' */',
    'const EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;',
    '',
    '/**',
    ' * URL validation regex',
    ' */',
    'const URL_REGEX = /^https?:\\/\\/.+/;',
    '',
  ];

  for (const schema of schemas) {
    if (schema.isJunctionTable) continue;

    // Create validation function
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} creation data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}(data: unknown): ValidationResult {`);
    lines.push("  const errors: ValidationError[] = [];");
    lines.push("");
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push("  }");
    lines.push("");
    lines.push("  const obj = data as Record<string, unknown>;");
    lines.push("");

    for (const field of schema.fields) {
      if (field.readOnly || field.name === 'id' || field.isComputed) continue;

      const isRequired = !field.nullable && !field.hasDefault;

      // Required check
      if (isRequired) {
        lines.push(`  if (obj.${field.name} === undefined || obj.${field.name} === null) {`);
        lines.push(`    errors.push({ field: '${field.name}', message: '${field.name} is required' });`);
        lines.push("  }");
      }

      // Type-specific validation
      lines.push(`  if (obj.${field.name} !== undefined && obj.${field.name} !== null) {`);

      if (field.type === 'string' || field.type === 'email' || field.type === 'url') {
        lines.push(`    if (typeof obj.${field.name} !== 'string') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a string' });`);
        lines.push("    } else {");

        // Min/max length
        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min} characters' });`);
          lines.push("      }");
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as string).length > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max} characters' });`);
          lines.push("      }");
        }

        // Email validation
        if (field.type === 'email') {
          lines.push(`      if (!EMAIL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid email format' });`);
          lines.push("      }");
        }

        // URL validation
        if (field.type === 'url') {
          lines.push(`      if (!URL_REGEX.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid URL format' });`);
          lines.push("      }");
        }

        // Pattern validation
        if (field.pattern) {
          lines.push(`      if (!/${field.pattern}/.test(obj.${field.name} as string)) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Invalid format' });`);
          lines.push("      }");
        }

        lines.push("    }");
      } else if (field.type === 'int' || field.type === 'float' || field.type === 'number') {
        lines.push(`    if (typeof obj.${field.name} !== 'number') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a number' });`);
        lines.push("    } else {");

        if (field.type === 'int') {
          lines.push(`      if (!Number.isInteger(obj.${field.name})) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be an integer' });`);
          lines.push("      }");
        }

        if (field.min !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) < ${field.min}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at least ${field.min}' });`);
          lines.push("      }");
        }
        if (field.max !== undefined) {
          lines.push(`      if ((obj.${field.name} as number) > ${field.max}) {`);
          lines.push(`        errors.push({ field: '${field.name}', message: 'Must be at most ${field.max}' });`);
          lines.push("      }");
        }

        lines.push("    }");
      } else if (field.type === 'boolean') {
        lines.push(`    if (typeof obj.${field.name} !== 'boolean') {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be a boolean' });`);
        lines.push("    }");
      } else if (field.isEnum && field.enumValues) {
        const enumVals = field.enumValues.map((v) => `'${v}'`).join(', ');
        lines.push(`    if (![${enumVals}].includes(obj.${field.name} as string)) {`);
        lines.push(`      errors.push({ field: '${field.name}', message: 'Must be one of: ${field.enumValues.join(', ')}' });`);
        lines.push("    }");
      }

      lines.push("  }");
      lines.push("");
    }

    lines.push("  return errors.length > 0 ? { valid: false, errors } : { valid: true, data: obj };");
    lines.push("}");
    lines.push("");

    // Update validation function (all fields optional)
    lines.push(`/**`);
    lines.push(` * Validate ${schema.pascalName} update data`);
    lines.push(` */`);
    lines.push(`export function validate${schema.pascalName}Update(data: unknown): ValidationResult {`);
    lines.push("  if (typeof data !== 'object' || data === null) {");
    lines.push("    return { valid: false, errors: [{ field: '_root', message: 'Invalid data' }] };");
    lines.push("  }");
    lines.push("");
    lines.push("  const obj = data as Record<string, unknown>;");
    lines.push("  const errors: ValidationError[] = [];");
    lines.push("");
    lines.push("  // For updates, all fields are optional but must be valid if present");
    lines.push(`  const fullValidation = validate${schema.pascalName}({ ...obj });`);
    lines.push("");
    lines.push("  // Filter out 'required' errors for updates");
    lines.push("  const updateErrors = fullValidation.errors?.filter(");
    lines.push("    (err) => !err.message.includes('is required')");
    lines.push("  ) || [];");
    lines.push("");
    lines.push("  return updateErrors.length > 0 ? { valid: false, errors: updateErrors } : { valid: true, data: obj };");
    lines.push("}");
    lines.push("");
  }

  return lines.join('\n');
}
