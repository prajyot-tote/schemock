/**
 * Next.js API Route Templates
 *
 * Generates route.ts files for Next.js App Router.
 *
 * Supports two modes:
 * - Legacy: Direct database access per backend (for backward compatibility)
 * - Service: Uses service layer with withMiddleware (new pattern)
 *
 * @module cli/generators/nextjs-api/route-template
 * @category CLI
 */

import type { AnalyzedSchema, GenerationTarget, SchemockConfig } from '../../types';
import { CodeBuilder } from '../../utils/code-builder';

/**
 * Generate the collection route file (GET list, POST create)
 */
export function generateRouteFile(
  schema: AnalyzedSchema,
  target: GenerationTarget,
  config: SchemockConfig
): string {
  const hasNewMiddlewareConfig = config.middleware !== undefined;
  const hasAuth = hasNewMiddlewareConfig ? !!config.middleware?.auth : target.middleware?.auth !== undefined;
  const hasValidation = hasNewMiddlewareConfig ? !!config.middleware?.validation : target.middleware?.validation === true;
  const hasRateLimit = hasNewMiddlewareConfig && !!config.middleware?.rateLimit;
  const hasCache = hasNewMiddlewareConfig && !!config.middleware?.cache;
  const backend = target.backend || 'supabase';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
  ];

  // Import middleware based on config format
  if (hasNewMiddlewareConfig) {
    // New config format - use middleware chain
    lines.push("import { runMiddlewareChain, type MiddlewareChainContext } from '../_lib/chain';");
    if (hasCache) {
      lines.push("import { setCacheEntry } from '../_lib/cache';");
    }
  } else if (hasAuth) {
    // Legacy format - import auth middleware directly
    lines.push("import { authMiddleware, type AuthResult } from '../_lib/auth';");
  }

  // Import validation if configured (both formats)
  if (hasValidation) {
    lines.push(`import { validate${schema.pascalName} } from '../_lib/validate';`);
  }

  // Import backend client
  if (backend === 'supabase') {
    lines.push("import { supabase } from '../_lib/supabase';");
  } else if (backend === 'firebase') {
    lines.push("import { db } from '../_lib/firebase';");
  } else if (backend === 'pglite') {
    lines.push("import { db } from '../_lib/pglite';");
  }

  // Import types (using naming convention: UserCreate, UserUpdate)
  lines.push(`import type { ${schema.pascalName}, ${schema.pascalName}Create } from '../_lib/types';`);
  lines.push('');

  // GET handler - list all
  lines.push('/**');
  lines.push(` * GET /api/${schema.pluralName}`);
  lines.push(` * List all ${schema.pluralName}`);
  lines.push(' */');
  lines.push('export async function GET(request: NextRequest) {');

  if (hasNewMiddlewareConfig) {
    // New middleware chain
    lines.push('  // Run middleware chain');
    lines.push(`  const mwResult = await runMiddlewareChain(request, '${schema.tableName}', 'select');`);
    lines.push('  if (mwResult.error) {');
    lines.push("    return mwResult.response ?? NextResponse.json({ error: 'Middleware error' }, { status: 500 });");
    lines.push('  }');
    lines.push('');
    lines.push('  // Check for cached response');
    lines.push('  if (mwResult.response) {');
    lines.push('    return mwResult.response;');
    lines.push('  }');
    lines.push('');
  } else if (hasAuth) {
    // Legacy auth check
    lines.push('  // Auth check');
    lines.push('  const authResult = await authMiddleware(request);');
    lines.push('  if (authResult.error) {');
    lines.push('    return authResult.response;');
    lines.push('  }');
    lines.push('');
  }

  lines.push('  try {');
  lines.push('    // Parse query params');
  lines.push('    const { searchParams } = new URL(request.url);');
  lines.push("    const limit = parseInt(searchParams.get('limit') || '20', 10);");
  lines.push("    const offset = parseInt(searchParams.get('offset') || '0', 10);");
  lines.push('');

  // Backend-specific query
  if (backend === 'supabase') {
    lines.push(`    const { data, error, count } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push("      .select('*', { count: 'exact' })");
    lines.push('      .range(offset, offset + limit - 1);');
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      return NextResponse.json({ error: error.message }, { status: 500 });');
    lines.push('    }');
    lines.push('');
    lines.push('    return NextResponse.json({');
    lines.push(`      data: data as ${schema.pascalName}[],`);
    lines.push('      meta: { total: count ?? 0, limit, offset }');
    lines.push('    });');
  } else if (backend === 'firebase') {
    lines.push(`    const snapshot = await db.collection('${schema.tableName}')`);
    lines.push('      .limit(limit)');
    lines.push('      .offset(offset)');
    lines.push('      .get();');
    lines.push('');
    lines.push(`    const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })) as ${schema.pascalName}[];`);
    lines.push('');
    lines.push('    return NextResponse.json({ data, meta: { limit, offset } });');
  } else if (backend === 'pglite') {
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'SELECT * FROM ${schema.tableName} LIMIT $1 OFFSET $2',`);
    lines.push('      [limit, offset]');
    lines.push('    );');
    lines.push('');
    lines.push('    return NextResponse.json({ data: result.rows, meta: { limit, offset } });');
  }

  lines.push('  } catch (error) {');
  lines.push("    console.error('GET error:', error);");
  lines.push("    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // POST handler - create
  lines.push('/**');
  lines.push(` * POST /api/${schema.pluralName}`);
  lines.push(` * Create a new ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function POST(request: NextRequest) {');

  if (hasNewMiddlewareConfig) {
    // New middleware chain
    lines.push('  // Run middleware chain');
    lines.push(`  const mwResult = await runMiddlewareChain(request, '${schema.tableName}', 'insert');`);
    lines.push('  if (mwResult.error) {');
    lines.push("    return mwResult.response ?? NextResponse.json({ error: 'Middleware error' }, { status: 500 });");
    lines.push('  }');
    lines.push('');
  } else if (hasAuth) {
    // Legacy auth check
    lines.push('  // Auth check');
    lines.push('  const authResult = await authMiddleware(request);');
    lines.push('  if (authResult.error) {');
    lines.push('    return authResult.response;');
    lines.push('  }');
    lines.push('');
  }

  lines.push('  try {');
  lines.push(`    const body = await request.json() as ${schema.pascalName}Create;`);
  lines.push('');

  if (hasValidation) {
    lines.push('    // Validate input');
    lines.push(`    const validation = validate${schema.pascalName}(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      return NextResponse.json({ errors: validation.errors }, { status: 400 });');
    lines.push('    }');
    lines.push('');
  }

  // Backend-specific insert
  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .insert(body)');
    lines.push('      .select()');
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      return NextResponse.json({ error: error.message }, { status: 500 });');
    lines.push('    }');
    lines.push('');
    lines.push(`    return NextResponse.json(data as ${schema.pascalName}, { status: 201 });`);
  } else if (backend === 'firebase') {
    lines.push(`    const docRef = await db.collection('${schema.tableName}').add({`);
    lines.push('      ...body,');
    lines.push('      createdAt: new Date().toISOString(),');
    lines.push('      updatedAt: new Date().toISOString(),');
    lines.push('    });');
    lines.push('');
    lines.push('    const doc = await docRef.get();');
    lines.push(`    return NextResponse.json({ id: doc.id, ...doc.data() } as ${schema.pascalName}, { status: 201 });`);
  } else if (backend === 'pglite') {
    // Generate column list from schema fields
    const insertFields = schema.fields
      .filter((f) => !f.readOnly && f.name !== 'id' && !f.isComputed)
      .map((f) => f.name);
    const placeholders = insertFields.map((_, i) => `$${i + 1}`).join(', ');
    const values = insertFields.map((f) => `body.${f}`).join(', ');

    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'INSERT INTO ${schema.tableName} (${insertFields.join(', ')}) VALUES (${placeholders}) RETURNING *',`);
    lines.push(`      [${values}]`);
    lines.push('    );');
    lines.push('');
    lines.push('    return NextResponse.json(result.rows[0], { status: 201 });');
  }

  lines.push('  } catch (error) {');
  lines.push("    console.error('POST error:', error);");
  lines.push("    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Generate the dynamic route file (GET one, PUT update, DELETE)
 */
export function generateDynamicRouteFile(
  schema: AnalyzedSchema,
  target: GenerationTarget,
  config: SchemockConfig
): string {
  const hasNewMiddlewareConfig = config.middleware !== undefined;
  const hasAuth = hasNewMiddlewareConfig ? !!config.middleware?.auth : target.middleware?.auth !== undefined;
  const hasValidation = hasNewMiddlewareConfig ? !!config.middleware?.validation : target.middleware?.validation === true;
  const backend = target.backend || 'supabase';

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
  ];

  // Import middleware based on config format
  if (hasNewMiddlewareConfig) {
    // New config format - use middleware chain
    lines.push("import { runMiddlewareChain, type MiddlewareChainContext } from '../../_lib/chain';");
  } else if (hasAuth) {
    // Legacy format - import auth middleware directly
    lines.push("import { authMiddleware } from '../../_lib/auth';");
  }

  // Import validation if configured
  if (hasValidation) {
    lines.push(`import { validate${schema.pascalName}Update } from '../../_lib/validate';`);
  }

  // Import backend client
  if (backend === 'supabase') {
    lines.push("import { supabase } from '../../_lib/supabase';");
  } else if (backend === 'firebase') {
    lines.push("import { db } from '../../_lib/firebase';");
  } else if (backend === 'pglite') {
    lines.push("import { db } from '../../_lib/pglite';");
  }

  // Import types (using naming convention: UserCreate, UserUpdate)
  lines.push(`import type { ${schema.pascalName}, ${schema.pascalName}Update } from '../../_lib/types';`);
  lines.push('');

  // Route params type
  lines.push('interface RouteParams {');
  lines.push('  params: Promise<{ id: string }>;');
  lines.push('}');
  lines.push('');

  // GET handler - get one
  lines.push('/**');
  lines.push(` * GET /api/${schema.pluralName}/[id]`);
  lines.push(` * Get a single ${schema.singularName} by ID`);
  lines.push(' */');
  lines.push('export async function GET(request: NextRequest, { params }: RouteParams) {');

  if (hasNewMiddlewareConfig) {
    // New middleware chain
    lines.push('  // Run middleware chain');
    lines.push(`  const mwResult = await runMiddlewareChain(request, '${schema.tableName}', 'select');`);
    lines.push('  if (mwResult.error) {');
    lines.push("    return mwResult.response ?? NextResponse.json({ error: 'Middleware error' }, { status: 500 });");
    lines.push('  }');
    lines.push('');
    lines.push('  // Check for cached response');
    lines.push('  if (mwResult.response) {');
    lines.push('    return mwResult.response;');
    lines.push('  }');
    lines.push('');
  } else if (hasAuth) {
    lines.push('  const authResult = await authMiddleware(request);');
    lines.push('  if (authResult.error) return authResult.response;');
    lines.push('');
  }

  lines.push('  const { id } = await params;');
  lines.push('');
  lines.push('  try {');

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push("      .select('*')");
    lines.push("      .eq('id', id)");
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push("      if (error.code === 'PGRST116') {");
    lines.push("        return NextResponse.json({ error: 'Not found' }, { status: 404 });");
    lines.push('      }');
    lines.push('      return NextResponse.json({ error: error.message }, { status: 500 });');
    lines.push('    }');
    lines.push('');
    lines.push(`    return NextResponse.json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const doc = await db.collection('${schema.tableName}').doc(id).get();`);
    lines.push('');
    lines.push('    if (!doc.exists) {');
    lines.push("      return NextResponse.json({ error: 'Not found' }, { status: 404 });");
    lines.push('    }');
    lines.push('');
    lines.push(`    return NextResponse.json({ id: doc.id, ...doc.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      'SELECT * FROM ${schema.tableName} WHERE id = $1',`);
    lines.push('      [id]');
    lines.push('    );');
    lines.push('');
    lines.push('    if (result.rows.length === 0) {');
    lines.push("      return NextResponse.json({ error: 'Not found' }, { status: 404 });");
    lines.push('    }');
    lines.push('');
    lines.push('    return NextResponse.json(result.rows[0]);');
  }

  lines.push('  } catch (error) {');
  lines.push("    console.error('GET error:', error);");
  lines.push("    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // PUT handler - update
  lines.push('/**');
  lines.push(` * PUT /api/${schema.pluralName}/[id]`);
  lines.push(` * Update a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function PUT(request: NextRequest, { params }: RouteParams) {');

  if (hasNewMiddlewareConfig) {
    // New middleware chain
    lines.push('  // Run middleware chain');
    lines.push(`  const mwResult = await runMiddlewareChain(request, '${schema.tableName}', 'update');`);
    lines.push('  if (mwResult.error) {');
    lines.push("    return mwResult.response ?? NextResponse.json({ error: 'Middleware error' }, { status: 500 });");
    lines.push('  }');
    lines.push('');
  } else if (hasAuth) {
    lines.push('  const authResult = await authMiddleware(request);');
    lines.push('  if (authResult.error) return authResult.response;');
    lines.push('');
  }

  lines.push('  const { id } = await params;');
  lines.push('');
  lines.push('  try {');
  lines.push(`    const body = await request.json() as ${schema.pascalName}Update;`);
  lines.push('');

  if (hasValidation) {
    lines.push(`    const validation = validate${schema.pascalName}Update(body);`);
    lines.push('    if (!validation.valid) {');
    lines.push('      return NextResponse.json({ errors: validation.errors }, { status: 400 });');
    lines.push('    }');
    lines.push('');
  }

  if (backend === 'supabase') {
    lines.push(`    const { data, error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .update(body)');
    lines.push("      .eq('id', id)");
    lines.push('      .select()');
    lines.push('      .single();');
    lines.push('');
    lines.push('    if (error) {');
    lines.push("      if (error.code === 'PGRST116') {");
    lines.push("        return NextResponse.json({ error: 'Not found' }, { status: 404 });");
    lines.push('      }');
    lines.push('      return NextResponse.json({ error: error.message }, { status: 500 });');
    lines.push('    }');
    lines.push('');
    lines.push(`    return NextResponse.json(data as ${schema.pascalName});`);
  } else if (backend === 'firebase') {
    lines.push(`    const docRef = db.collection('${schema.tableName}').doc(id);`);
    lines.push('    const doc = await docRef.get();');
    lines.push('');
    lines.push('    if (!doc.exists) {');
    lines.push("      return NextResponse.json({ error: 'Not found' }, { status: 404 });");
    lines.push('    }');
    lines.push('');
    lines.push('    await docRef.update({ ...body, updatedAt: new Date().toISOString() });');
    lines.push('    const updated = await docRef.get();');
    lines.push('');
    lines.push(`    return NextResponse.json({ id: updated.id, ...updated.data() } as ${schema.pascalName});`);
  } else if (backend === 'pglite') {
    lines.push("    // Build dynamic UPDATE query");
    lines.push("    const entries = Object.entries(body);");
    lines.push("    if (entries.length === 0) {");
    lines.push("      return NextResponse.json({ error: 'No fields to update' }, { status: 400 });");
    lines.push("    }");
    lines.push("");
    lines.push("    const setClauses = entries.map(([key], i) => `${key} = $${i + 1}`).join(', ');");
    lines.push("    const values = entries.map(([, val]) => val);");
    lines.push("");
    lines.push(`    const result = await db.query<${schema.pascalName}>(`);
    lines.push(`      \`UPDATE ${schema.tableName} SET \${setClauses} WHERE id = $\${values.length + 1} RETURNING *\`,`);
    lines.push("      [...values, id]");
    lines.push("    );");
    lines.push("");
    lines.push("    if (result.rows.length === 0) {");
    lines.push("      return NextResponse.json({ error: 'Not found' }, { status: 404 });");
    lines.push("    }");
    lines.push("");
    lines.push("    return NextResponse.json(result.rows[0]);");
  }

  lines.push('  } catch (error) {');
  lines.push("    console.error('PUT error:', error);");
  lines.push("    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('  }');
  lines.push('}');
  lines.push('');

  // DELETE handler
  lines.push('/**');
  lines.push(` * DELETE /api/${schema.pluralName}/[id]`);
  lines.push(` * Delete a ${schema.singularName}`);
  lines.push(' */');
  lines.push('export async function DELETE(request: NextRequest, { params }: RouteParams) {');

  if (hasNewMiddlewareConfig) {
    // New middleware chain
    lines.push('  // Run middleware chain');
    lines.push(`  const mwResult = await runMiddlewareChain(request, '${schema.tableName}', 'delete');`);
    lines.push('  if (mwResult.error) {');
    lines.push("    return mwResult.response ?? NextResponse.json({ error: 'Middleware error' }, { status: 500 });");
    lines.push('  }');
    lines.push('');
  } else if (hasAuth) {
    lines.push('  const authResult = await authMiddleware(request);');
    lines.push('  if (authResult.error) return authResult.response;');
    lines.push('');
  }

  lines.push('  const { id } = await params;');
  lines.push('');
  lines.push('  try {');

  if (backend === 'supabase') {
    lines.push(`    const { error } = await supabase`);
    lines.push(`      .from('${schema.tableName}')`);
    lines.push('      .delete()');
    lines.push("      .eq('id', id);");
    lines.push('');
    lines.push('    if (error) {');
    lines.push('      return NextResponse.json({ error: error.message }, { status: 500 });');
    lines.push('    }');
    lines.push('');
    lines.push('    return new NextResponse(null, { status: 204 });');
  } else if (backend === 'firebase') {
    lines.push(`    await db.collection('${schema.tableName}').doc(id).delete();`);
    lines.push('    return new NextResponse(null, { status: 204 });');
  } else if (backend === 'pglite') {
    lines.push(`    await db.query('DELETE FROM ${schema.tableName} WHERE id = $1', [id]);`);
    lines.push('    return new NextResponse(null, { status: 204 });');
  }

  lines.push('  } catch (error) {');
  lines.push("    console.error('DELETE error:', error);");
  lines.push("    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}

/**
 * Configuration for service-based route generation
 */
export interface ServiceRouteConfig {
  /** Path to import services from */
  servicesImport?: string;
  /** Path to import middleware from */
  middlewareImport?: string;
  /** Path to import types from */
  typesImport?: string;
  /** Operations to skip generating */
  skip?: string[];
}

/**
 * Generate the collection route file using service layer (GET list, POST create)
 *
 * This is the new pattern that uses services instead of direct database access.
 * Services encapsulate business logic and RLS enforcement, handlers just orchestrate.
 *
 * @param schema - Analyzed schema
 * @param config - Service route configuration
 * @returns Generated route.ts content
 */
export function generateServiceRouteFile(
  schema: AnalyzedSchema,
  config: ServiceRouteConfig = {}
): string {
  const {
    servicesImport = '../_lib/services',
    middlewareImport = '../_lib/middleware',
    typesImport = '../_lib/types',
    skip = [],
  } = config;

  const code = new CodeBuilder();
  const { name, pascalName, singularName, pluralName } = schema;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  code.line("import { NextRequest, NextResponse } from 'next/server';");
  code.line(`import { withMiddleware, getMiddleware } from '${middlewareImport}';`);
  code.line(`import { ${singularName}Service } from '${servicesImport}';`);
  code.line(`import type { ${pascalName}Create } from '${typesImport}';`);
  code.line();

  // Query options parser
  generateServiceQueryOptionsParser(code);

  // GET - List
  if (!skip.includes(`${name}.list`)) {
    code.multiDocComment([
      `GET /api/${pluralName}`,
      `List all ${pluralName}`,
    ]);
    code.block('export async function GET(request: NextRequest) {', () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'list'), request, async (ctx) => {`);
      code.indent();
      code.line('const options = parseQueryOptions(request.nextUrl);');
      code.line(`const data = await ${singularName}Service.list(ctx, options);`);
      code.line('return NextResponse.json({');
      code.line('  data,');
      code.line('  meta: { limit: options.limit ?? 20, offset: options.offset ?? 0 },');
      code.line('});');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // POST - Create
  if (!skip.includes(`${name}.create`)) {
    code.multiDocComment([
      `POST /api/${pluralName}`,
      `Create new ${singularName}`,
    ]);
    code.block('export async function POST(request: NextRequest) {', () => {
      code.line(`return withMiddleware(getMiddleware('${name}', 'create'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Create;`);
      code.line(`const data = await ${singularName}Service.create(ctx, body);`);
      code.line('return NextResponse.json({ data }, { status: 201 });');
      code.dedent();
      code.line('});');
    });
  }

  return code.toString();
}

/**
 * Generate the dynamic route file using service layer (GET one, PUT update, DELETE)
 *
 * @param schema - Analyzed schema
 * @param config - Service route configuration
 * @returns Generated route.ts content for [id] route
 */
export function generateServiceDynamicRouteFile(
  schema: AnalyzedSchema,
  config: ServiceRouteConfig = {}
): string {
  const {
    servicesImport = '../../_lib/services',
    middlewareImport = '../../_lib/middleware',
    typesImport = '../../_lib/types',
    skip = [],
  } = config;

  const code = new CodeBuilder();
  const { name, pascalName, singularName, pluralName } = schema;

  code.comment('GENERATED BY SCHEMOCK - DO NOT EDIT');
  code.line();

  // Imports
  code.line("import { NextRequest, NextResponse } from 'next/server';");
  code.line(`import { withMiddleware, getMiddleware } from '${middlewareImport}';`);
  code.line(`import { ${singularName}Service } from '${servicesImport}';`);
  code.line(`import type { ${pascalName}Update } from '${typesImport}';`);
  code.line();

  // Route params type
  code.block('interface RouteParams {', () => {
    code.line('params: Promise<{ id: string }>;');
  });
  code.line();

  // GET - Single
  if (!skip.includes(`${name}.get`)) {
    code.multiDocComment([
      `GET /api/${pluralName}/[id]`,
      `Get single ${singularName} by ID`,
    ]);
    code.block('export async function GET(request: NextRequest, { params }: RouteParams) {', () => {
      code.line('const { id } = await params;');
      code.line(`return withMiddleware(getMiddleware('${name}', 'get'), request, async (ctx) => {`);
      code.indent();
      code.line(`const data = await ${singularName}Service.get(ctx, id);`);
      code.line('return NextResponse.json({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // PUT - Update
  if (!skip.includes(`${name}.update`)) {
    code.multiDocComment([
      `PUT /api/${pluralName}/[id]`,
      `Update ${singularName}`,
    ]);
    code.block('export async function PUT(request: NextRequest, { params }: RouteParams) {', () => {
      code.line('const { id } = await params;');
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
      code.line('return NextResponse.json({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();

    // PATCH - Partial update
    code.multiDocComment([
      `PATCH /api/${pluralName}/[id]`,
      `Partial update ${singularName}`,
    ]);
    code.block('export async function PATCH(request: NextRequest, { params }: RouteParams) {', () => {
      code.line('const { id } = await params;');
      code.line(`return withMiddleware(getMiddleware('${name}', 'update'), request, async (ctx) => {`);
      code.indent();
      code.line(`const body = await request.json() as ${pascalName}Update;`);
      code.line(`const data = await ${singularName}Service.update(ctx, id, body);`);
      code.line('return NextResponse.json({ data });');
      code.dedent();
      code.line('});');
    });
    code.line();
  }

  // DELETE
  if (!skip.includes(`${name}.delete`)) {
    code.multiDocComment([
      `DELETE /api/${pluralName}/[id]`,
      `Delete ${singularName}`,
    ]);
    code.block('export async function DELETE(request: NextRequest, { params }: RouteParams) {', () => {
      code.line('const { id } = await params;');
      code.line(`return withMiddleware(getMiddleware('${name}', 'delete'), request, async (ctx) => {`);
      code.indent();
      code.line(`await ${singularName}Service.delete(ctx, id);`);
      code.line('return new NextResponse(null, { status: 204 });');
      code.dedent();
      code.line('});');
    });
  }

  return code.toString();
}

/**
 * Generate query options parser for service routes
 */
function generateServiceQueryOptionsParser(code: CodeBuilder): void {
  code.multiDocComment([
    'Parse query options from URL search params',
  ]);
  code.block('function parseQueryOptions(url: { searchParams: URLSearchParams }): { limit?: number; offset?: number } {', () => {
    code.line("const limit = url.searchParams.get('limit');");
    code.line("const offset = url.searchParams.get('offset');");
    code.line();
    code.line('return {');
    code.line('  limit: limit ? parseInt(limit, 10) : undefined,');
    code.line('  offset: offset ? parseInt(offset, 10) : undefined,');
    code.line('};');
  });
  code.line();
}
