/**
 * Next.js Endpoint Route Template
 *
 * Generates Next.js App Router route.ts files for custom endpoints
 * defined via defineEndpoint().
 *
 * @module cli/generators/nextjs-api/endpoint-route-template
 * @category CLI
 */

import type { AnalyzedEndpoint, GenerationTarget, SchemockConfig } from '../../types';
import {
  generateParamParsingExpression,
  generateEndpointTodoBody,
  getQueryParams,
  type BackendType,
} from '../shared/endpoint-helpers';

/**
 * Convert an endpoint path to Next.js App Router directory segments.
 *
 * Examples:
 *   /api/search -> ['search']
 *   /api/auth/login -> ['auth', 'login']
 *   /api/users/:id/posts -> ['users', '[id]', 'posts']
 *
 * @param path - The endpoint path (e.g., /api/users/:id/posts)
 * @param apiPrefix - The API prefix to strip (e.g., /api)
 * @returns Array of directory segments
 */
export function pathToNextjsSegments(path: string, apiPrefix: string): string[] {
  // Strip the api prefix
  let relativePath = path;
  if (relativePath.startsWith(apiPrefix)) {
    relativePath = relativePath.slice(apiPrefix.length);
  }
  // Remove leading slash
  relativePath = relativePath.replace(/^\//, '');

  // Convert :param to [param]
  return relativePath
    .split('/')
    .filter(Boolean)
    .map(segment => {
      if (segment.startsWith(':')) {
        return `[${segment.slice(1)}]`;
      }
      return segment;
    });
}

/**
 * Generate a Next.js App Router route file for a custom endpoint
 */
export function generateEndpointRouteFile(
  endpoint: AnalyzedEndpoint,
  target: GenerationTarget,
  config: SchemockConfig,
  libRelativePath: string
): string {
  const backend = (target.backend || 'supabase') as BackendType;
  const hasBody = endpoint.body.length > 0;
  const hasParams = endpoint.params.length > 0 || endpoint.pathParams.length > 0;
  const hasResponse = endpoint.response.length > 0;
  const queryParams = getQueryParams(endpoint);
  const hasPathParams = endpoint.pathParams.length > 0;

  const lines: string[] = [
    '// GENERATED BY SCHEMOCK - DO NOT EDIT',
    `// Custom endpoint: ${endpoint.method} ${endpoint.path}`,
    '',
    "import { NextRequest, NextResponse } from 'next/server';",
  ];

  // Import backend client
  if (backend === 'supabase') {
    lines.push(`import { supabase } from '${libRelativePath}/supabase';`);
  } else if (backend === 'firebase') {
    lines.push(`import { db } from '${libRelativePath}/firebase';`);
  } else if (backend === 'pglite') {
    lines.push(`import { db } from '${libRelativePath}/pglite';`);
  }

  // Import endpoint types
  const typeImports: string[] = [];
  if (hasParams) typeImports.push(`${endpoint.pascalName}Params`);
  if (hasBody) typeImports.push(`${endpoint.pascalName}Body`);
  if (hasResponse) typeImports.push(`${endpoint.pascalName}Response`);

  if (typeImports.length > 0) {
    lines.push(`import type { ${typeImports.join(', ')} } from '${libRelativePath}/endpoint-types';`);
  }

  lines.push('');

  // Route params type (if path has dynamic segments)
  if (hasPathParams) {
    const paramsType = endpoint.pathParams.map(p => `${p}: string`).join('; ');
    lines.push('interface RouteParams {');
    lines.push(`  params: Promise<{ ${paramsType} }>;`);
    lines.push('}');
    lines.push('');
  }

  // Handler function
  const methodName = endpoint.method.toUpperCase();
  lines.push('/**');
  lines.push(` * ${endpoint.method} ${endpoint.path}`);
  if (endpoint.description) {
    lines.push(` * ${endpoint.description}`);
  }
  lines.push(' */');

  if (hasPathParams) {
    lines.push(`export async function ${methodName}(request: NextRequest, { params }: RouteParams) {`);
  } else {
    lines.push(`export async function ${methodName}(request: NextRequest) {`);
  }

  // Parse path params
  if (hasPathParams) {
    const destructured = endpoint.pathParams.join(', ');
    lines.push(`  const { ${destructured} } = await params;`);
    lines.push('');
  }

  lines.push('  try {');

  // Parse query params
  if (queryParams.length > 0) {
    lines.push('    const { searchParams } = new URL(request.url);');
    for (const param of queryParams) {
      const accessPattern = `searchParams.get('${param.name}')`;
      const parsed = generateParamParsingExpression(param, accessPattern);
      lines.push(`    const ${param.name} = ${parsed};`);
    }
    lines.push('');
  }

  // Parse body
  if (hasBody) {
    lines.push(`    const body = await request.json() as ${endpoint.pascalName}Body;`);
    lines.push('');
  }

  // TODO body with DB-specific example
  const todoLines = generateEndpointTodoBody(endpoint, backend);
  lines.push(...todoLines);
  lines.push('');

  // Default response
  lines.push("    return NextResponse.json({ error: 'Not implemented' }, { status: 501 });");

  lines.push('  } catch (error) {');
  lines.push(`    console.error('${methodName} ${endpoint.path} error:', error);`);
  lines.push("    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });");
  lines.push('  }');
  lines.push('}');

  return lines.join('\n');
}
